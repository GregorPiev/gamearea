/*
 AngularJS v1.4.4
 (c) 2010-2015 Google, Inc. http://angularjs.org
 License: MIT
 */
(function(O, W, t){'use strict'; function L(b){return function(){var a = arguments[0], c; c = "[" + (b?b + ":":"") + a + "] http://errors.angularjs.org/1.4.4/" + (b?b + "/":"") + a; for (a = 1; a < arguments.length; a++){c = c + (1 == a?"?":"&") + "p" + (a - 1) + "="; var d = encodeURIComponent, e; e = arguments[a]; e = "function" == typeof e?e.toString().replace(/ \{[\s\S]*$/, ""):"undefined" == typeof e?"undefined":"string" != typeof e?JSON.stringify(e):e; c += d(e)}return Error(c)}}function Da(b){if (null == b || Ya(b))return!1; var a = "length"in Object(b) && b.length;
        return b.nodeType === pa && a?!0:I(b) || G(b) || 0 === a || "number" === typeof a && 0 < a && a - 1 in b}function m(b, a, c){var d, e; if (b)if (C(b))for (d in b)"prototype" == d || "length" == d || "name" == d || b.hasOwnProperty && !b.hasOwnProperty(d) || a.call(c, b[d], d, b);  else if (G(b) || Da(b)){var f = "object" !== typeof b; d = 0; for (e = b.length; d < e; d++)(f || d in b) && a.call(c, b[d], d, b)} else if (b.forEach && b.forEach !== m)b.forEach(a, c, b);  else if (lc(b))for (d in b)a.call(c, b[d], d, b);  else if ("function" === typeof b.hasOwnProperty)for (d in b)b.hasOwnProperty(d) &&
        a.call(c, b[d], d, b);  else for (d in b)Na.call(b, d) && a.call(c, b[d], d, b); return b}function mc(b, a, c){for (var d = Object.keys(b).sort(), e = 0; e < d.length; e++)a.call(c, b[d[e]], d[e]); return d}function nc(b){return function(a, c){b(c, a)}}function Ud(){return++mb}function oc(b, a){a?b.$$hashKey = a:delete b.$$hashKey}function Mb(b, a, c){for (var d = b.$$hashKey, e = 0, f = a.length; e < f; ++e){var g = a[e]; if (D(g) || C(g))for (var h = Object.keys(g), l = 0, k = h.length; l < k; l++){var n = h[l], q = g[n]; c && D(q)?ca(q)?b[n] = new Date(q.valueOf()):Oa(q)?
b[n] = new RegExp(q):(D(b[n]) || (b[n] = G(q)?[]:{}), Mb(b[n], [q], !0)):b[n] = q}}oc(b, d); return b}function Q(b){return Mb(b, xa.call(arguments, 1), !1)}function Vd(b){return Mb(b, xa.call(arguments, 1), !0)}function Y(b){return parseInt(b, 10)}function Nb(b, a){return Q(Object.create(b), a)}function v(){}function Za(b){return b}function qa(b){return function(){return b}}function pc(b){return C(b.toString) && b.toString !== Object.prototype.toString}function y(b){return"undefined" === typeof b}function x(b){return"undefined" !==
        typeof b}function D(b){return null !== b && "object" === typeof b}function lc(b){return null !== b && "object" === typeof b && !qc(b)}function I(b){return"string" === typeof b}function X(b){return"number" === typeof b}function ca(b){return"[object Date]" === sa.call(b)}function C(b){return"function" === typeof b}function Oa(b){return"[object RegExp]" === sa.call(b)}function Ya(b){return b && b.window === b}function $a(b){return b && b.$evalAsync && b.$watch}function ab(b){return"boolean" === typeof b}function rc(b){return!(!b || !(b.nodeName ||
        b.prop && b.attr && b.find))}function Wd(b){var a = {}; b = b.split(","); var c; for (c = 0; c < b.length; c++)a[b[c]] = !0; return a}function ta(b){return M(b.nodeName || b[0] && b[0].nodeName)}function bb(b, a){var c = b.indexOf(a); 0 <= c && b.splice(c, 1); return c}function fa(b, a, c, d){if (Ya(b) || $a(b))throw Ea("cpws"); if (sc.test(sa.call(a)))throw Ea("cpta"); if (a){if (b === a)throw Ea("cpi"); c = c || []; d = d || []; D(b) && (c.push(b), d.push(a)); var e; if (G(b))for (e = a.length = 0; e < b.length; e++)a.push(fa(b[e], null, c, d));  else{var f = a.$$hashKey; G(a)?
        a.length = 0:m(a, function(b, c){delete a[c]}); if (lc(b))for (e in b)a[e] = fa(b[e], null, c, d);  else if (b && "function" === typeof b.hasOwnProperty)for (e in b)b.hasOwnProperty(e) && (a[e] = fa(b[e], null, c, d));  else for (e in b)Na.call(b, e) && (a[e] = fa(b[e], null, c, d)); oc(a, f)}} else if (a = b, D(b)){if (c && - 1 !== (f = c.indexOf(b)))return d[f]; if (G(b))return fa(b, [], c, d); if (sc.test(sa.call(b)))a = new b.constructor(b);  else if (ca(b))a = new Date(b.getTime());  else if (Oa(b))a = new RegExp(b.source, b.toString().match(/[^\/]*$/)[0]), a.lastIndex =
        b.lastIndex;  else return e = Object.create(qc(b)), fa(b, e, c, d); d && (c.push(b), d.push(a))}return a}function ia(b, a){if (G(b)){a = a || []; for (var c = 0, d = b.length; c < d; c++)a[c] = b[c]} else if (D(b))for (c in a = a || {}, b)if ("$" !== c.charAt(0) || "$" !== c.charAt(1))a[c] = b[c]; return a || b}function ka(b, a){if (b === a)return!0; if (null === b || null === a)return!1; if (b !== b && a !== a)return!0; var c = typeof b, d; if (c == typeof a && "object" == c)if (G(b)){if (!G(a))return!1; if ((c = b.length) == a.length){for (d = 0; d < c; d++)if (!ka(b[d], a[d]))return!1; return!0}} else{if (ca(b))return ca(a)?
        ka(b.getTime(), a.getTime()):!1; if (Oa(b))return Oa(a)?b.toString() == a.toString():!1; if ($a(b) || $a(a) || Ya(b) || Ya(a) || G(a) || ca(a) || Oa(a))return!1; c = ga(); for (d in b)if ("$" !== d.charAt(0) && !C(b[d])){if (!ka(b[d], a[d]))return!1; c[d] = !0}for (d in a)if (!(d in c || "$" === d.charAt(0) || a[d] === t || C(a[d])))return!1; return!0}return!1}function cb(b, a, c){return b.concat(xa.call(a, c))}function tc(b, a){var c = 2 < arguments.length?xa.call(arguments, 2):[]; return!C(a) || a instanceof RegExp?a:c.length?function(){return arguments.length?
        a.apply(b, cb(c, arguments, 0)):a.apply(b, c)}:function(){return arguments.length?a.apply(b, arguments):a.call(b)}}function Xd(b, a){var c = a; "string" === typeof b && "$" === b.charAt(0) && "$" === b.charAt(1)?c = t:Ya(a)?c = "$WINDOW":a && W === a?c = "$DOCUMENT":$a(a) && (c = "$SCOPE"); return c}function db(b, a){if ("undefined" === typeof b)return t; X(a) || (a = a?2:null); return JSON.stringify(b, Xd, a)}function uc(b){return I(b)?JSON.parse(b):b}function vc(b, a){var c = Date.parse("Jan 01, 1970 00:00:00 " + b) / 6E4; return isNaN(c)?a:c}function Ob(b,
        a, c){c = c? - 1:1; var d = vc(a, b.getTimezoneOffset()); a = b; b = c * (d - b.getTimezoneOffset()); a = new Date(a.getTime()); a.setMinutes(a.getMinutes() + b); return a}function ua(b){b = z(b).clone(); try{b.empty()} catch (a){}var c = z("<div>").append(b).html(); try{return b[0].nodeType === Pa?M(c):c.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function(a, b){return"<" + M(b)})} catch (d){return M(c)}}function wc(b){try{return decodeURIComponent(b)} catch (a){}}function xc(b){var a = {}; m((b || "").split("&"), function(b){var d, e, f; b && (e =
        b = b.replace(/\+/g, "%20"), d = b.indexOf("="), - 1 !== d && (e = b.substring(0, d), f = b.substring(d + 1)), e = wc(e), x(e) && (f = x(f)?wc(f):!0, Na.call(a, e)?G(a[e])?a[e].push(f):a[e] = [a[e], f]:a[e] = f))}); return a}function Pb(b){var a = []; m(b, function(b, d){G(b)?m(b, function(b){a.push(ma(d, !0) + (!0 === b?"":"=" + ma(b, !0)))}):a.push(ma(d, !0) + (!0 === b?"":"=" + ma(b, !0)))}); return a.length?a.join("&"):""}function nb(b){return ma(b, !0).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+")}function ma(b, a){return encodeURIComponent(b).replace(/%40/gi,
        "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%20/g, a?"%20":"+")}function Yd(b, a){var c, d, e = Qa.length; for (d = 0; d < e; ++d)if (c = Qa[d] + a, I(c = b.getAttribute(c)))return c; return null}function Zd(b, a){var c, d, e = {}; m(Qa, function(a){a += "app"; !c && b.hasAttribute && b.hasAttribute(a) && (c = b, d = b.getAttribute(a))}); m(Qa, function(a){a += "app"; var e; !c && (e = b.querySelector("[" + a.replace(":", "\\:") + "]")) && (c = e, d = e.getAttribute(a))}); c && (e.strictDi = null !== Yd(c, "strict-di"),
        a(c, d?[d]:[], e))}function yc(b, a, c){D(c) || (c = {}); c = Q({strictDi:!1}, c); var d = function(){b = z(b); if (b.injector()){var d = b[0] === W?"document":ua(b); throw Ea("btstrpd", d.replace(/</, "&lt;").replace(/>/, "&gt;")); }a = a || []; a.unshift(["$provide", function(a){a.value("$rootElement", b)}]); c.debugInfoEnabled && a.push(["$compileProvider", function(a){a.debugInfoEnabled(!0)}]); a.unshift("ng"); d = eb(a, c.strictDi); d.invoke(["$rootScope", "$rootElement", "$compile", "$injector", function(a, b, c, d){a.$apply(function(){b.data("$injector",
        d); c(b)(a)})}]); return d}, e = /^NG_ENABLE_DEBUG_INFO!/, f = /^NG_DEFER_BOOTSTRAP!/; O && e.test(O.name) && (c.debugInfoEnabled = !0, O.name = O.name.replace(e, "")); if (O && !f.test(O.name))return d(); O.name = O.name.replace(f, ""); aa.resumeBootstrap = function(b){m(b, function(b){a.push(b)}); return d()}; C(aa.resumeDeferredBootstrap) && aa.resumeDeferredBootstrap()}function $d(){O.name = "NG_ENABLE_DEBUG_INFO!" + O.name; O.location.reload()}function ae(b){b = aa.element(b).injector(); if (!b)throw Ea("test"); return b.get("$$testability")}
function zc(b, a){a = a || "_"; return b.replace(be, function(b, d){return(d?a:"") + b.toLowerCase()})}function ce(){var b; if (!Ac){var a = ob(); la = O.jQuery; x(a) && (la = null === a?t:O[a]); la && la.fn.on?(z = la, Q(la.fn, {scope:Ra.scope, isolateScope:Ra.isolateScope, controller:Ra.controller, injector:Ra.injector, inheritedData:Ra.inheritedData}), b = la.cleanData, la.cleanData = function(a){var d; if (Qb)Qb = !1;  else for (var e = 0, f; null != (f = a[e]); e++)(d = la._data(f, "events")) && d.$destroy && la(f).triggerHandler("$destroy"); b(a)}):z = R; aa.element =
        z; Ac = !0}}function pb(b, a, c){if (!b)throw Ea("areq", a || "?", c || "required"); return b}function Sa(b, a, c){c && G(b) && (b = b[b.length - 1]); pb(C(b), a, "not a function, got " + (b && "object" === typeof b?b.constructor.name || "Object":typeof b)); return b}function Ta(b, a){if ("hasOwnProperty" === b)throw Ea("badname", a); }function Bc(b, a, c){if (!a)return b; a = a.split("."); for (var d, e = b, f = a.length, g = 0; g < f; g++)d = a[g], b && (b = (e = b)[d]); return!c && C(b)?tc(e, b):b}function qb(b){var a = b[0]; b = b[b.length - 1]; var c = [a]; do{a = a.nextSibling;
        if (!a)break; c.push(a)}while (a !== b); return z(c)}function ga(){return Object.create(null)}function de(b){function a(a, b, c){return a[b] || (a[b] = c())}var c = L("$injector"), d = L("ng"); b = a(b, "angular", Object); b.$$minErr = b.$$minErr || L; return a(b, "module", function(){var b = {}; return function(f, g, h){if ("hasOwnProperty" === f)throw d("badname", "module"); g && b.hasOwnProperty(f) && (b[f] = null); return a(b, f, function(){function a(b, c, e, f){f || (f = d); return function(){f[e || "push"]([b, c, arguments]); return B}}function b(a, c){return function(b,
        e){e && C(e) && (e.$$moduleName = f); d.push([a, c, arguments]); return B}}if (!g)throw c("nomod", f); var d = [], e = [], r = [], u = a("$injector", "invoke", "push", e), B = {_invokeQueue:d, _configBlocks:e, _runBlocks:r, requires:g, name:f, provider:b("$provide", "provider"), factory:b("$provide", "factory"), service:b("$provide", "service"), value:a("$provide", "value"), constant:a("$provide", "constant", "unshift"), decorator:b("$provide", "decorator"), animation:b("$animateProvider", "register"), filter:b("$filterProvider", "register"), controller:b("$controllerProvider",
        "register"), directive:b("$compileProvider", "directive"), config:u, run:function(a){r.push(a); return this}}; h && u(h); return B})}})}function ee(b){Q(b, {bootstrap:yc, copy:fa, extend:Q, merge:Vd, equals:ka, element:z, forEach:m, injector:eb, noop:v, bind:tc, toJson:db, fromJson:uc, identity:Za, isUndefined:y, isDefined:x, isString:I, isFunction:C, isObject:D, isNumber:X, isElement:rc, isArray:G, version:fe, isDate:ca, lowercase:M, uppercase:rb, callbacks:{counter:0}, getTestability:ae, $$minErr:L, $$csp:Fa, reloadWithDebugInfo:$d});
        Rb = de(O); Rb("ng", ["ngLocale"], ["$provide", function(a){a.provider({$$sanitizeUri:ge}); a.provider("$compile", Cc).directive({a:he, input:Dc, textarea:Dc, form:ie, script:je, select:ke, style:le, option:me, ngBind:ne, ngBindHtml:oe, ngBindTemplate:pe, ngClass:qe, ngClassEven:re, ngClassOdd:se, ngCloak:te, ngController:ue, ngForm:ve, ngHide:we, ngIf:xe, ngInclude:ye, ngInit:ze, ngNonBindable:Ae, ngPluralize:Be, ngRepeat:Ce, ngShow:De, ngStyle:Ee, ngSwitch:Fe, ngSwitchWhen:Ge, ngSwitchDefault:He, ngOptions:Ie, ngTransclude:Je, ngModel:Ke,
        ngList:Le, ngChange:Me, pattern:Ec, ngPattern:Ec, required:Fc, ngRequired:Fc, minlength:Gc, ngMinlength:Gc, maxlength:Hc, ngMaxlength:Hc, ngValue:Ne, ngModelOptions:Oe}).directive({ngInclude:Pe}).directive(sb).directive(Ic); a.provider({$anchorScroll:Qe, $animate:Re, $animateCss:Se, $$animateQueue:Te, $$AnimateRunner:Ue, $browser:Ve, $cacheFactory:We, $controller:Xe, $document:Ye, $exceptionHandler:Ze, $filter:Jc, $$forceReflow:$e, $interpolate:af, $interval:bf, $http:cf, $httpParamSerializer:df, $httpParamSerializerJQLike:ef,
        $httpBackend:ff, $location:gf, $log:hf, $parse:jf, $rootScope:kf, $q:lf, $$q:mf, $sce:nf, $sceDelegate:of, $sniffer:pf, $templateCache:qf, $templateRequest:rf, $$testability:sf, $timeout:tf, $window:uf, $$rAF:vf, $$jqLite:wf, $$HashMap:xf, $$cookieReader:yf})}])}function fb(b){return b.replace(zf, function(a, b, d, e){return e?d.toUpperCase():d}).replace(Af, "Moz$1")}function Kc(b){b = b.nodeType; return b === pa || !b || 9 === b}function Lc(b, a){var c, d, e = a.createDocumentFragment(), f = []; if (Sb.test(b)){c = c || e.appendChild(a.createElement("div"));
        d = (Bf.exec(b) || ["", ""])[1].toLowerCase(); d = na[d] || na._default; c.innerHTML = d[1] + b.replace(Cf, "<$1></$2>") + d[2]; for (d = d[0]; d--; )c = c.lastChild; f = cb(f, c.childNodes); c = e.firstChild; c.textContent = ""} else f.push(a.createTextNode(b)); e.textContent = ""; e.innerHTML = ""; m(f, function(a){e.appendChild(a)}); return e}function R(b){if (b instanceof R)return b; var a; I(b) && (b = T(b), a = !0); if (!(this instanceof R)){if (a && "<" != b.charAt(0))throw Tb("nosel"); return new R(b)}if (a){a = W; var c; b = (c = Df.exec(b))?[a.createElement(c[1])]:
        (c = Lc(b, a))?c.childNodes:[]}Mc(this, b)}function Ub(b){return b.cloneNode(!0)}function tb(b, a){a || ub(b); if (b.querySelectorAll)for (var c = b.querySelectorAll("*"), d = 0, e = c.length; d < e; d++)ub(c[d])}function Nc(b, a, c, d){if (x(d))throw Tb("offargs"); var e = (d = vb(b)) && d.events, f = d && d.handle; if (f)if (a)m(a.split(" "), function(a){if (x(c)){var d = e[a]; bb(d || [], c); if (d && 0 < d.length)return}b.removeEventListener(a, f, !1); delete e[a]});  else for (a in e)"$destroy" !== a && b.removeEventListener(a, f, !1), delete e[a]}function ub(b,
        a){var c = b.ng339, d = c && gb[c]; d && (a?delete d.data[a]:(d.handle && (d.events.$destroy && d.handle({}, "$destroy"), Nc(b)), delete gb[c], b.ng339 = t))}function vb(b, a){var c = b.ng339, c = c && gb[c]; a && !c && (b.ng339 = c = ++Ef, c = gb[c] = {events:{}, data:{}, handle:t}); return c}function Vb(b, a, c){if (Kc(b)){var d = x(c), e = !d && a && !D(a), f = !a; b = (b = vb(b, !e)) && b.data; if (d)b[a] = c;  else{if (f)return b; if (e)return b && b[a]; Q(b, a)}}}function wb(b, a){return b.getAttribute? - 1 < (" " + (b.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " +
        a + " "):!1}function xb(b, a){a && b.setAttribute && m(a.split(" "), function(a){b.setAttribute("class", T((" " + (b.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").replace(" " + T(a) + " ", " ")))})}function yb(b, a){if (a && b.setAttribute){var c = (" " + (b.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " "); m(a.split(" "), function(a){a = T(a); - 1 === c.indexOf(" " + a + " ") && (c += a + " ")}); b.setAttribute("class", T(c))}}function Mc(b, a){if (a)if (a.nodeType)b[b.length++] = a;  else{var c = a.length; if ("number" === typeof c && a.window !==
        a){if (c)for (var d = 0; d < c; d++)b[b.length++] = a[d]} else b[b.length++] = a}}function Oc(b, a){return zb(b, "$" + (a || "ngController") + "Controller")}function zb(b, a, c){9 == b.nodeType && (b = b.documentElement); for (a = G(a)?a:[a]; b; ){for (var d = 0, e = a.length; d < e; d++)if ((c = z.data(b, a[d])) !== t)return c; b = b.parentNode || 11 === b.nodeType && b.host}}function Pc(b){for (tb(b, !0); b.firstChild; )b.removeChild(b.firstChild)}function Wb(b, a){a || tb(b); var c = b.parentNode; c && c.removeChild(b)}function Ff(b, a){a = a || O; if ("complete" === a.document.readyState)a.setTimeout(b);
        else z(a).on("load", b)}function Qc(b, a){var c = Ab[a.toLowerCase()]; return c && Rc[ta(b)] && c}function Gf(b, a){var c = b.nodeName; return("INPUT" === c || "TEXTAREA" === c) && Sc[a]}function Hf(b, a){var c = function(c, e){c.isDefaultPrevented = function(){return c.defaultPrevented}; var f = a[e || c.type], g = f?f.length:0; if (g){if (y(c.immediatePropagationStopped)){var h = c.stopImmediatePropagation; c.stopImmediatePropagation = function(){c.immediatePropagationStopped = !0; c.stopPropagation && c.stopPropagation(); h && h.call(c)}}c.isImmediatePropagationStopped =
        function(){return!0 === c.immediatePropagationStopped}; 1 < g && (f = ia(f)); for (var l = 0; l < g; l++)c.isImmediatePropagationStopped() || f[l].call(b, c)}}; c.elem = b; return c}function wf(){this.$get = function(){return Q(R, {hasClass:function(b, a){b.attr && (b = b[0]); return wb(b, a)}, addClass:function(b, a){b.attr && (b = b[0]); return yb(b, a)}, removeClass:function(b, a){b.attr && (b = b[0]); return xb(b, a)}})}}function Ga(b, a){var c = b && b.$$hashKey; if (c)return"function" === typeof c && (c = b.$$hashKey()), c; c = typeof b; return c = "function" ==
        c || "object" == c && null !== b?b.$$hashKey = c + ":" + (a || Ud)():c + ":" + b}function Ua(b, a){if (a){var c = 0; this.nextUid = function(){return++c}}m(b, this.put, this)}function If(b){return(b = b.toString().replace(Tc, "").match(Uc))?"function(" + (b[1] || "").replace(/[\s\r\n]+/, " ") + ")":"fn"}function eb(b, a){function c(a){return function(b, c){if (D(b))m(b, nc(a));  else return a(b, c)}}function d(a, b){Ta(a, "service"); if (C(b) || G(b))b = r.instantiate(b); if (!b.$get)throw Ha("pget", a); return q[a + "Provider"] = b}function e(a, b){return function(){var c =
        B.invoke(b, this); if (y(c))throw Ha("undef", a); return c}}function f(a, b, c){return d(a, {$get:!1 !== c?e(a, b):b})}function g(a){pb(y(a) || G(a), "modulesToLoad", "not an array"); var b = [], c; m(a, function(a){function d(a){var b, c; b = 0; for (c = a.length; b < c; b++){var e = a[b], f = r.get(e[0]); f[e[1]].apply(f, e[2])}}if (!n.get(a)){n.put(a, !0); try{I(a)?(c = Rb(a), b = b.concat(g(c.requires)).concat(c._runBlocks), d(c._invokeQueue), d(c._configBlocks)):C(a)?b.push(r.invoke(a)):G(a)?b.push(r.invoke(a)):Sa(a, "module")} catch (e){throw G(a) &&
        (a = a[a.length - 1]), e.message && e.stack && - 1 == e.stack.indexOf(e.message) && (e = e.message + "\n" + e.stack), Ha("modulerr", a, e.stack || e.message || e); }}}); return b}function h(b, c){function d(a, e){if (b.hasOwnProperty(a)){if (b[a] === l)throw Ha("cdep", a + " <- " + k.join(" <- ")); return b[a]}try{return k.unshift(a), b[a] = l, b[a] = c(a, e)} catch (f){throw b[a] === l && delete b[a], f; } finally{k.shift()}}function e(b, c, f, g){"string" === typeof f && (g = f, f = null); var h = [], k = eb.$$annotate(b, a, g), l, r, n; r = 0; for (l = k.length; r < l; r++){n = k[r]; if ("string" !==
        typeof n)throw Ha("itkn", n); h.push(f && f.hasOwnProperty(n)?f[n]:d(n, g))}G(b) && (b = b[l]); return b.apply(c, h)}return{invoke:e, instantiate:function(a, b, c){var d = Object.create((G(a)?a[a.length - 1]:a).prototype || null); a = e(a, d, b, c); return D(a) || C(a)?a:d}, get:d, annotate:eb.$$annotate, has:function(a){return q.hasOwnProperty(a + "Provider") || b.hasOwnProperty(a)}}}a = !0 === a; var l = {}, k = [], n = new Ua([], !0), q = {$provide:{provider:c(d), factory:c(f), service:c(function(a, b){return f(a, ["$injector", function(a){return a.instantiate(b)}])}),
        value:c(function(a, b){return f(a, qa(b), !1)}), constant:c(function(a, b){Ta(a, "constant"); q[a] = b; u[a] = b}), decorator:function(a, b){var c = r.get(a + "Provider"), d = c.$get; c.$get = function(){var a = B.invoke(d, c); return B.invoke(b, null, {$delegate:a})}}}}, r = q.$injector = h(q, function(a, b){aa.isString(b) && k.push(b); throw Ha("unpr", k.join(" <- ")); }), u = {}, B = u.$injector = h(u, function(a, b){var c = r.get(a + "Provider", b); return B.invoke(c.$get, c, t, a)}); m(g(b), function(a){a && B.invoke(a)}); return B}function Qe(){var b = !0; this.disableAutoScrolling =
        function(){b = !1}; this.$get = ["$window", "$location", "$rootScope", function(a, c, d){function e(a){var b = null; Array.prototype.some.call(a, function(a){if ("a" === ta(a))return b = a, !0}); return b}function f(b){if (b){b.scrollIntoView(); var c; c = g.yOffset; C(c)?c = c():rc(c)?(c = c[0], c = "fixed" !== a.getComputedStyle(c).position?0:c.getBoundingClientRect().bottom):X(c) || (c = 0); c && (b = b.getBoundingClientRect().top, a.scrollBy(0, b - c))} else a.scrollTo(0, 0)}function g(a){a = I(a)?a:c.hash(); var b; a?(b = h.getElementById(a))?f(b):
        (b = e(h.getElementsByName(a)))?f(b):"top" === a && f(null):f(null)}var h = a.document; b && d.$watch(function(){return c.hash()}, function(a, b){a === b && "" === a || Ff(function(){d.$evalAsync(g)})}); return g}]}function hb(b, a){if (!b && !a)return""; if (!b)return a; if (!a)return b; G(b) && (b = b.join(" ")); G(a) && (a = a.join(" ")); return b + " " + a}function Jf(b){I(b) && (b = b.split(" ")); var a = ga(); m(b, function(b){b.length && (a[b] = !0)}); return a}function Ia(b){return D(b)?b:{}}function Kf(b, a, c, d){function e(a){try{a.apply(null, xa.call(arguments,
        1))} finally{if (B--, 0 === B)for (; K.length; )try{K.pop()()} catch (b){c.error(b)}}}function f(){g(); h()}function g(){a:{try{w = n.state; break a} catch (a){}w = void 0}w = y(w)?null:w; ka(w, F) && (w = F); F = w}function h(){if (A !== l.url() || p !== w)A = l.url(), p = w, m(N, function(a){a(l.url(), w)})}var l = this, k = b.location, n = b.history, q = b.setTimeout, r = b.clearTimeout, u = {}; l.isMock = !1; var B = 0, K = []; l.$$completeOutstandingRequest = e; l.$$incOutstandingRequestCount = function(){B++}; l.notifyWhenNoOutstandingRequests = function(a){0 === B?a():
        K.push(a)}; var w, p, A = k.href, s = a.find("base"), H = null; g(); p = w; l.url = function(a, c, e){y(e) && (e = null); k !== b.location && (k = b.location); n !== b.history && (n = b.history); if (a){var f = p === e; if (A === a && (!d.history || f))return l; var h = A && Ja(A) === Ja(a); A = a; p = e; if (!d.history || h && f){if (!h || H)H = a; c?k.replace(a):h?(c = k, e = a.indexOf("#"), a = - 1 === e?"":a.substr(e), c.hash = a):k.href = a} else n[c?"replaceState":"pushState"](e, "", a), g(), p = w; return l}return H || k.href.replace(/%27/g, "'")}; l.state = function(){return w}; var N = [], J = !1, F =
        null; l.onUrlChange = function(a){if (!J){if (d.history)z(b).on("popstate", f); z(b).on("hashchange", f); J = !0}N.push(a); return a}; l.$$applicationDestroyed = function(){z(b).off("hashchange popstate", f)}; l.$$checkUrlChange = h; l.baseHref = function(){var a = s.attr("href"); return a?a.replace(/^(https?\:)?\/\/[^\/]*/, ""):""}; l.defer = function(a, b){var c; B++; c = q(function(){delete u[c]; e(a)}, b || 0); u[c] = !0; return c}; l.defer.cancel = function(a){return u[a]?(delete u[a], r(a), e(v), !0):!1}}function Ve(){this.$get = ["$window",
        "$log", "$sniffer", "$document", function(b, a, c, d){return new Kf(b, d, a, c)}]}function We(){this.$get = function(){function b(b, d){function e(a){a != q && (r?r == a && (r = a.n):r = a, f(a.n, a.p), f(a, q), q = a, q.n = null)}function f(a, b){a != b && (a && (a.p = b), b && (b.n = a))}if (b in a)throw L("$cacheFactory")("iid", b); var g = 0, h = Q({}, d, {id:b}), l = {}, k = d && d.capacity || Number.MAX_VALUE, n = {}, q = null, r = null; return a[b] = {put:function(a, b){if (!y(b)){if (k < Number.MAX_VALUE){var c = n[a] || (n[a] = {key:a}); e(c)}a in l || g++; l[a] = b; g > k && this.remove(r.key);
        return b}}, get:function(a){if (k < Number.MAX_VALUE){var b = n[a]; if (!b)return; e(b)}return l[a]}, remove:function(a){if (k < Number.MAX_VALUE){var b = n[a]; if (!b)return; b == q && (q = b.p); b == r && (r = b.n); f(b.n, b.p); delete n[a]}delete l[a]; g--}, removeAll:function(){l = {}; g = 0; n = {}; q = r = null}, destroy:function(){n = h = l = null; delete a[b]}, info:function(){return Q({}, h, {size:g})}}}var a = {}; b.info = function(){var b = {}; m(a, function(a, e){b[e] = a.info()}); return b}; b.get = function(b){return a[b]}; return b}}function qf(){this.$get =
        ["$cacheFactory", function(b){return b("templates")}]}function Cc(b, a){function c(a, b, c){var d = /^\s*([@&]|=(\*?))(\??)\s*(\w*)\s*$/, e = {}; m(a, function(a, f){var g = a.match(d); if (!g)throw ea("iscp", b, f, a, c?"controller bindings definition":"isolate scope definition"); e[f] = {mode:g[1][0], collection:"*" === g[2], optional:"?" === g[3], attrName:g[4] || f}}); return e}function d(a){var b = a.charAt(0); if (!b || b !== M(b))throw ea("baddir", a); if (a !== a.trim())throw ea("baddir", a); }var e = {}, f = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/,
        g = /(([\w\-]+)(?:\:([^;]+))?;?)/, h = Wd("ngSrc,ngSrcset,src,srcset"), l = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/, k = /^(on[a-z]+|formaction)$/; this.directive = function r(a, f){Ta(a, "directive"); I(a)?(d(a), pb(f, "directiveFactory"), e.hasOwnProperty(a) || (e[a] = [], b.factory(a + "Directive", ["$injector", "$exceptionHandler", function(b, d){var f = []; m(e[a], function(e, g){try{var h = b.invoke(e); C(h)?h = {compile:qa(h)}:!h.compile && h.link && (h.compile = qa(h.link)); h.priority = h.priority || 0; h.index = g; h.name = h.name || a; h.require = h.require ||
        h.controller && h.name; h.restrict = h.restrict || "EA"; var k = h, l = h, r = h.name, n = {isolateScope:null, bindToController:null}; D(l.scope) && (!0 === l.bindToController?(n.bindToController = c(l.scope, r, !0), n.isolateScope = {}):n.isolateScope = c(l.scope, r, !1)); D(l.bindToController) && (n.bindToController = c(l.bindToController, r, !0)); if (D(n.bindToController)){var S = l.controller, B = l.controllerAs; if (!S)throw ea("noctrl", r); var ha; a:if (B && I(B))ha = B;  else{if (I(S)){var m = Vc.exec(S); if (m){ha = m[3]; break a}}ha = void 0}if (!ha)throw ea("noident",
        r); }var s = k.$$bindings = n; D(s.isolateScope) && (h.$$isolateBindings = s.isolateScope); h.$$moduleName = e.$$moduleName; f.push(h)} catch (t){d(t)}}); return f}])), e[a].push(f)):m(a, nc(r)); return this}; this.aHrefSanitizationWhitelist = function(b){return x(b)?(a.aHrefSanitizationWhitelist(b), this):a.aHrefSanitizationWhitelist()}; this.imgSrcSanitizationWhitelist = function(b){return x(b)?(a.imgSrcSanitizationWhitelist(b), this):a.imgSrcSanitizationWhitelist()}; var n = !0; this.debugInfoEnabled = function(a){return x(a)?
        (n = a, this):n}; this.$get = ["$injector", "$interpolate", "$exceptionHandler", "$templateRequest", "$parse", "$controller", "$rootScope", "$document", "$sce", "$animate", "$$sanitizeUri", function(a, b, c, d, w, p, A, s, H, N, J){function F(a, b){try{a.addClass(b)} catch (c){}}function V(a, b, c, d, e){a instanceof z || (a = z(a)); m(a, function(b, c){b.nodeType == Pa && b.nodeValue.match(/\S+/) && (a[c] = z(b).wrap("<span></span>").parent()[0])}); var f = S(a, b, a, c, d, e); V.$$addScopeClass(a); var g = null; return function(b, c, d){pb(b, "scope"); d = d || {};
        var e = d.parentBoundTranscludeFn, h = d.transcludeControllers; d = d.futureParentElement; e && e.$$boundTransclude && (e = e.$$boundTransclude); g || (g = (d = d && d[0])?"foreignobject" !== ta(d) && d.toString().match(/SVG/)?"svg":"html":"html"); d = "html" !== g?z(Xb(g, z("<div>").append(a).html())):c?Ra.clone.call(a):a; if (h)for (var l in h)d.data("$" + l + "Controller", h[l].instance); V.$$addScopeInfo(d, b); c && c(d, b); f && f(b, d, d, e); return d}}function S(a, b, c, d, e, f){function g(a, c, d, e){var f, l, k, r, n, u, N; if (p)for (N = Array(c.length), r = 0; r <
        h.length; r += 3)f = h[r], N[f] = c[f];  else N = c; r = 0; for (n = h.length; r < n; )if (l = N[h[r++]], c = h[r++], f = h[r++], c){if (c.scope){if (k = a.$new(), V.$$addScopeInfo(z(l), k), u = c.$$destroyBindings)c.$$destroyBindings = null, k.$on("$destroyed", u)} else k = a; u = c.transcludeOnThisElement?P(a, c.transclude, e):!c.templateOnThisElement && e?e:!e && b?P(a, b):null; c(f, k, l, d, u, c)} else f && f(a, l.childNodes, t, e)}for (var h = [], l, k, r, n, p, u = 0; u < a.length; u++){l = new aa; k = ha(a[u], [], l, 0 === u?d:t, e); (f = k.length?E(k, a[u], l, b, c, null, [], [], f):null) && f.scope &&
        V.$$addScopeClass(l.$$element); l = f && f.terminal || !(r = a[u].childNodes) || !r.length?null:S(r, f?(f.transcludeOnThisElement || !f.templateOnThisElement) && f.transclude:b); if (f || l)h.push(u, f, l), n = !0, p = p || f; f = null}return n?g:null}function P(a, b, c){return function(d, e, f, g, h){d || (d = a.$new(!1, h), d.$$transcluded = !0); return b(d, e, {parentBoundTranscludeFn:c, transcludeControllers:f, futureParentElement:g})}}function ha(a, b, c, d, e){var h = c.$attr, l; switch (a.nodeType){case pa:x(b, va(ta(a)), "E", d, e); for (var k, r, n, p = a.attributes,
        u = 0, N = p && p.length; u < N; u++){var K = !1, J = !1; k = p[u]; l = k.name; r = T(k.value); k = va(l); if (n = ia.test(k))l = l.replace(Xc, "").substr(8).replace(/_(.)/g, function(a, b){return b.toUpperCase()}); var S = k.replace(/(Start|End)$/, ""); L(S) && k === S + "Start" && (K = l, J = l.substr(0, l.length - 5) + "end", l = l.substr(0, l.length - 6)); k = va(l.toLowerCase()); h[k] = l; if (n || !c.hasOwnProperty(k))c[k] = r, Qc(a, k) && (c[k] = !0); X(a, b, r, k, n); x(b, k, "A", d, e, K, J)}a = a.className; D(a) && (a = a.animVal); if (I(a) && "" !== a)for (; l = g.exec(a); )k = va(l[2]), x(b, k, "C", d,
        e) && (c[k] = T(l[3])), a = a.substr(l.index + l[0].length); break; case Pa:if (11 === Va)for (; a.parentNode && a.nextSibling && a.nextSibling.nodeType === Pa; )a.nodeValue += a.nextSibling.nodeValue, a.parentNode.removeChild(a.nextSibling); wa(b, a.nodeValue); break; case 8:try{if (l = f.exec(a.nodeValue))k = va(l[1]), x(b, k, "M", d, e) && (c[k] = T(l[2]))} catch (B){}}b.sort(za); return b}function ya(a, b, c){var d = [], e = 0; if (b && a.hasAttribute && a.hasAttribute(b)){do{if (!a)throw ea("uterdir", b, c); a.nodeType == pa && (a.hasAttribute(b) && e++, a.hasAttribute(c) &&
        e--); d.push(a); a = a.nextSibling}while (0 < e)} else d.push(a); return z(d)}function Wc(a, b, c){return function(d, e, f, g, h){e = ya(e[0], b, c); return a(d, e, f, g, h)}}function E(a, b, d, e, f, g, h, k, r){function n(a, b, c, d){if (a){c && (a = Wc(a, c, d)); a.require = E.require; a.directiveName = x; if (P === E || E.$$isolateScope)a = Z(a, {isolateScope:!0}); h.push(a)}if (b){c && (b = Wc(b, c, d)); b.require = E.require; b.directiveName = x; if (P === E || E.$$isolateScope)b = Z(b, {isolateScope:!0}); k.push(b)}}function u(a, b, c, d){var e; if (I(b)){var f = b.match(l); b =
        b.substring(f[0].length); var g = f[1] || f[3], f = "?" === f[2]; "^^" === g?c = c.parent():e = (e = d && d[b]) && e.instance; e || (d = "$" + b + "Controller", e = g?c.inheritedData(d):c.data(d)); if (!e && !f)throw ea("ctreq", b, a); } else if (G(b))for (e = [], g = 0, f = b.length; g < f; g++)e[g] = u(a, b[g], c, d); return e || null}function N(a, b, c, d, e, f){var g = ga(), h; for (h in d){var l = d[h], k = {$scope:l === P || l.$$isolateScope?e:f, $element:a, $attrs:b, $transclude:c}, r = l.controller; "@" == r && (r = b[l.name]); k = p(r, k, !0, l.controllerAs); g[l.name] = k; s || a.data("$" + l.name +
        "Controller", k.instance)}return g}function K(a, c, e, f, g, l){function r(a, b, c){var d; $a(a) || (c = b, b = a, a = t); s && (d = A); c || (c = s?ja.parent():ja); return g(a, b, d, c, ya)}var n, p, J, B, A, ha, ja; b === e?(f = d, ja = d.$$element):(ja = z(e), f = new aa(ja, d)); P && (B = c.$new(!0)); g && (ha = r, ha.$$boundTransclude = g); w && (A = N(ja, f, ha, w, B, c)); P && (V.$$addScopeInfo(ja, B, !0, !(F && (F === P || F === P.$$originalDirective))), V.$$addScopeClass(ja, !0), B.$$isolateBindings = P.$$isolateBindings, Y(c, f, B, B.$$isolateBindings, P, B)); if (A){var m = P || S, H; m && A[m.name] &&
        (p = m.$$bindings.bindToController, (J = A[m.name]) && J.identifier && p && (H = J, l.$$destroyBindings = Y(c, f, J.instance, p, m))); for (n in A){J = A[n]; var E = J(); E !== J.instance && (J.instance = E, ja.data("$" + n + "Controller", E), J === H && (l.$$destroyBindings(), l.$$destroyBindings = Y(c, f, E, p, m)))}}n = 0; for (l = h.length; n < l; n++)p = h[n], $(p, p.isolateScope?B:c, ja, f, p.require && u(p.directiveName, p.require, ja, A), ha); var ya = c; P && (P.template || null === P.templateUrl) && (ya = B); a && a(ya, e.childNodes, t, g); for (n = k.length - 1; 0 <= n; n--)p = k[n], $(p, p.isolateScope?
        B:c, ja, f, p.require && u(p.directiveName, p.require, ja, A), ha)}r = r || {}; for (var J = - Number.MAX_VALUE, S = r.newScopeDirective, w = r.controllerDirectives, P = r.newIsolateScopeDirective, F = r.templateDirective, A = r.nonTlbTranscludeDirective, m = !1, H = !1, s = r.hasElementTranscludeDirective, ba = d.$$element = z(b), E, x, v, y = e, za, wa = 0, L = a.length; wa < L; wa++){E = a[wa]; var Bb = E.$$start, M = E.$$end; Bb && (ba = ya(b, Bb, M)); v = t; if (J > E.priority)break; if (v = E.scope)E.templateUrl || (D(v)?(O("new/isolated scope", P || S, E, ba), P = E):O("new/isolated scope",
        P, E, ba)), S = S || E; x = E.name; !E.templateUrl && E.controller && (v = E.controller, w = w || ga(), O("'" + x + "' controller", w[x], E, ba), w[x] = E); if (v = E.transclude)m = !0, E.$$tlb || (O("transclusion", A, E, ba), A = E), "element" == v?(s = !0, J = E.priority, v = ba, ba = d.$$element = z(W.createComment(" " + x + ": " + d[x] + " ")), b = ba[0], U(f, xa.call(v, 0), b), y = V(v, e, J, g && g.name, {nonTlbTranscludeDirective:A})):(v = z(Ub(b)).contents(), ba.empty(), y = V(v, e)); if (E.template)if (H = !0, O("template", F, E, ba), F = E, v = C(E.template)?E.template(ba, d):E.template, v = fa(v),
        E.replace){g = E; v = Sb.test(v)?Yc(Xb(E.templateNamespace, T(v))):[]; b = v[0]; if (1 != v.length || b.nodeType !== pa)throw ea("tplrt", x, ""); U(f, ba, b); L = {$attr:{}}; v = ha(b, [], L); var Q = a.splice(wa + 1, a.length - (wa + 1)); P && Zc(v); a = a.concat(v).concat(Q); $c(d, L); L = a.length} else ba.html(v); if (E.templateUrl)H = !0, O("template", F, E, ba), F = E, E.replace && (g = E), K = Lf(a.splice(wa, a.length - wa), ba, d, f, m && y, h, k, {controllerDirectives:w, newScopeDirective:S !== E && S, newIsolateScopeDirective:P, templateDirective:F, nonTlbTranscludeDirective:A}),
        L = a.length;  else if (E.compile)try{za = E.compile(ba, d, y), C(za)?n(null, za, Bb, M):za && n(za.pre, za.post, Bb, M)} catch (R){c(R, ua(ba))}E.terminal && (K.terminal = !0, J = Math.max(J, E.priority))}K.scope = S && !0 === S.scope; K.transcludeOnThisElement = m; K.templateOnThisElement = H; K.transclude = y; r.hasElementTranscludeDirective = s; return K}function Zc(a){for (var b = 0, c = a.length; b < c; b++)a[b] = Nb(a[b], {$$isolateScope:!0})}function x(b, d, f, g, h, l, k){if (d === h)return null; h = null; if (e.hasOwnProperty(d)){var n; d = a.get(d + "Directive"); for (var p =
        0, u = d.length; p < u; p++)try{n = d[p], (g === t || g > n.priority) && - 1 != n.restrict.indexOf(f) && (l && (n = Nb(n, {$$start:l, $$end:k})), b.push(n), h = n)} catch (J){c(J)}}return h}function L(b){if (e.hasOwnProperty(b))for (var c = a.get(b + "Directive"), d = 0, f = c.length; d < f; d++)if (b = c[d], b.multiElement)return!0; return!1}function $c(a, b){var c = b.$attr, d = a.$attr, e = a.$$element; m(a, function(d, e){"$" != e.charAt(0) && (b[e] && b[e] !== d && (d += ("style" === e?";":" ") + b[e]), a.$set(e, d, !0, c[e]))}); m(b, function(b, f){"class" == f?(F(e, b), a["class"] = (a["class"]?
a["class"] + " ":"") + b):"style" == f?(e.attr("style", e.attr("style") + ";" + b), a.style = (a.style?a.style + ";":"") + b):"$" == f.charAt(0) || a.hasOwnProperty(f) || (a[f] = b, d[f] = c[f])})}function Lf(a, b, c, e, f, g, h, l){var k = [], r, n, p = b[0], u = a.shift(), J = Nb(u, {templateUrl:null, transclude:null, replace:null, $$originalDirective:u}), N = C(u.templateUrl)?u.templateUrl(b, c):u.templateUrl, B = u.templateNamespace; b.empty(); d(N).then(function(d){var K, w; d = fa(d); if (u.replace){d = Sb.test(d)?Yc(Xb(B, T(d))):[]; K = d[0]; if (1 != d.length || K.nodeType !==
        pa)throw ea("tplrt", u.name, N); d = {$attr:{}}; U(e, b, K); var A = ha(K, [], d); D(u.scope) && Zc(A); a = A.concat(a); $c(c, d)} else K = p, b.html(d); a.unshift(J); r = E(a, K, c, f, b, u, g, h, l); m(e, function(a, c){a == K && (e[c] = b[0])}); for (n = S(b[0].childNodes, f); k.length; ){d = k.shift(); w = k.shift(); var H = k.shift(), V = k.shift(), A = b[0]; if (!d.$$destroyed){if (w !== p){var ya = w.className; l.hasElementTranscludeDirective && u.replace || (A = Ub(K)); U(H, z(w), A); F(z(A), ya)}w = r.transcludeOnThisElement?P(d, r.transclude, V):V; r(n, d, A, e, w, r)}}k = null}); return function(a,
        b, c, d, e){a = e; b.$$destroyed || (k?k.push(b, c, d, a):(r.transcludeOnThisElement && (a = P(b, r.transclude, e)), r(n, b, c, d, a, r)))}}function za(a, b){var c = b.priority - a.priority; return 0 !== c?c:a.name !== b.name?a.name < b.name? - 1:1:a.index - b.index}function O(a, b, c, d){function e(a){return a?" (module: " + a + ")":""}if (b)throw ea("multidir", b.name, e(b.$$moduleName), c.name, e(c.$$moduleName), a, ua(d)); }function wa(a, c){var d = b(c, !0); d && a.push({priority:0, compile:function(a){a = a.parent(); var b = !!a.length; b && V.$$addBindingClass(a);
        return function(a, c){var e = c.parent(); b || V.$$addBindingClass(e); V.$$addBindingInfo(e, d.expressions); a.$watch(d, function(a){c[0].nodeValue = a})}}})}function Xb(a, b){a = M(a || "html"); switch (a){case "svg":case "math":var c = W.createElement("div"); c.innerHTML = "<" + a + ">" + b + "</" + a + ">"; return c.childNodes[0].childNodes; default:return b}}function R(a, b){if ("srcdoc" == b)return H.HTML; var c = ta(a); if ("xlinkHref" == b || "form" == c && "action" == b || "img" != c && ("src" == b || "ngSrc" == b))return H.RESOURCE_URL}function X(a, c, d, e,
        f){var g = R(a, e); f = h[e] || f; var l = b(d, !0, g, f); if (l){if ("multiple" === e && "select" === ta(a))throw ea("selmulti", ua(a)); c.push({priority:100, compile:function(){return{pre:function(a, c, h){c = h.$$observers || (h.$$observers = {}); if (k.test(e))throw ea("nodomevents"); var r = h[e]; r !== d && (l = r && b(r, !0, g, f), d = r); l && (h[e] = l(a), (c[e] || (c[e] = [])).$$inter = !0, (h.$$observers && h.$$observers[e].$$scope || a).$watch(l, function(a, b){"class" === e && a != b?h.$updateClass(a, b):h.$set(e, a)}))}}}})}}function U(a, b, c){var d = b[0], e = b.length,
        f = d.parentNode, g, h; if (a)for (g = 0, h = a.length; g < h; g++)if (a[g] == d){a[g++] = c; h = g + e - 1; for (var l = a.length; g < l; g++, h++)h < l?a[g] = a[h]:delete a[g]; a.length -= e - 1; a.context === d && (a.context = c); break}f && f.replaceChild(c, d); a = W.createDocumentFragment(); a.appendChild(d); z.hasData(d) && (z(c).data(z(d).data()), la?(Qb = !0, la.cleanData([d])):delete z.cache[d[z.expando]]); d = 1; for (e = b.length; d < e; d++)f = b[d], z(f).remove(), a.appendChild(f), delete b[d]; b[0] = c; b.length = 1}function Z(a, b){return Q(function(){return a.apply(null,
        arguments)}, a, b)}function $(a, b, d, e, f, g){try{a(b, d, e, f, g)} catch (h){c(h, ua(d))}}function Y(a, c, d, e, f, g){var h; m(e, function(e, g){var l = e.attrName, k = e.optional, r, n, p, K; switch (e.mode){case "@":k || Na.call(c, l) || (d[g] = c[l] = void 0); c.$observe(l, function(a){I(a) && (d[g] = a)}); c.$$observers[l].$$scope = a; I(c[l]) && (d[g] = b(c[l])(a)); break; case "=":if (!Na.call(c, l)){if (k)break; c[l] = void 0}if (k && !c[l])break; n = w(c[l]); K = n.literal?ka:function(a, b){return a === b || a !== a && b !== b}; p = n.assign || function(){r = d[g] = n(a); throw ea("nonassign",
c[l], f.name); }; r = d[g] = n(a); k = function(b){K(b, d[g]) || (K(b, r)?p(a, b = d[g]):d[g] = b); return r = b}; k.$stateful = !0; k = e.collection?a.$watchCollection(c[l], k):a.$watch(w(c[l], k), null, n.literal); h = h || []; h.push(k); break; case "&":n = c.hasOwnProperty(l)?w(c[l]):v; if (n === v && k)break; d[g] = function(b){return n(a, b)}}}); e = h?function(){for (var a = 0, b = h.length; a < b; ++a)h[a]()}:v; return g && e !== v?(g.$on("$destroy", e), v):e}var aa = function(a, b){if (b){var c = Object.keys(b), d, e, f; d = 0; for (e = c.length; d < e; d++)f = c[d], this[f] = b[f]} else this.$attr =
{}; this.$$element = a}; aa.prototype = {$normalize:va, $addClass:function(a){a && 0 < a.length && N.addClass(this.$$element, a)}, $removeClass:function(a){a && 0 < a.length && N.removeClass(this.$$element, a)}, $updateClass:function(a, b){var c = ad(a, b); c && c.length && N.addClass(this.$$element, c); (c = ad(b, a)) && c.length && N.removeClass(this.$$element, c)}, $set:function(a, b, d, e){var f = this.$$element[0], g = Qc(f, a), h = Gf(f, a), f = a; g?(this.$$element.prop(a, b), e = g):h && (this[h] = b, f = h); this[a] = b; e?this.$attr[a] = e:(e = this.$attr[a]) || (this.$attr[a] =
        e = zc(a, "-")); g = ta(this.$$element); if ("a" === g && "href" === a || "img" === g && "src" === a)this[a] = b = J(b, "src" === a);  else if ("img" === g && "srcset" === a){for (var g = "", h = T(b), l = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/, l = /\s/.test(h)?l:/(,)/, h = h.split(l), l = Math.floor(h.length / 2), k = 0; k < l; k++)var r = 2 * k, g = g + J(T(h[r]), !0), g = g + (" " + T(h[r + 1])); h = T(h[2 * k]).split(/\s/); g += J(T(h[0]), !0); 2 === h.length && (g += " " + T(h[1])); this[a] = b = g}!1 !== d && (null === b || b === t?this.$$element.removeAttr(e):this.$$element.attr(e, b)); (a = this.$$observers) &&
        m(a[f], function(a){try{a(b)} catch (d){c(d)}})}, $observe:function(a, b){var c = this, d = c.$$observers || (c.$$observers = ga()), e = d[a] || (d[a] = []); e.push(b); A.$evalAsync(function(){e.$$inter || !c.hasOwnProperty(a) || y(c[a]) || b(c[a])}); return function(){bb(e, b)}}}; var ca = b.startSymbol(), da = b.endSymbol(), fa = "{{" == ca || "}}" == da?Za:function(a){return a.replace(/\{\{/g, ca).replace(/}}/g, da)}, ia = /^ngAttr[A-Z]/; V.$$addBindingInfo = n?function(a, b){var c = a.data("$binding") || []; G(b)?c = c.concat(b):c.push(b); a.data("$binding",
        c)}:v; V.$$addBindingClass = n?function(a){F(a, "ng-binding")}:v; V.$$addScopeInfo = n?function(a, b, c, d){a.data(c?d?"$isolateScopeNoTemplate":"$isolateScope":"$scope", b)}:v; V.$$addScopeClass = n?function(a, b){F(a, b?"ng-isolate-scope":"ng-scope")}:v; return V}]}function va(b){return fb(b.replace(Xc, ""))}function ad(b, a){var c = "", d = b.split(/\s+/), e = a.split(/\s+/), f = 0; a:for (; f < d.length; f++){for (var g = d[f], h = 0; h < e.length; h++)if (g == e[h])continue a; c += (0 < c.length?" ":"") + g}return c}function Yc(b){b = z(b); var a = b.length;
        if (1 >= a)return b; for (; a--; )8 === b[a].nodeType && Mf.call(b, a, 1); return b}function Xe(){var b = {}, a = !1; this.register = function(a, d){Ta(a, "controller"); D(a)?Q(b, a):b[a] = d}; this.allowGlobals = function(){a = !0}; this.$get = ["$injector", "$window", function(c, d){function e(a, b, c, d){if (!a || !D(a.$scope))throw L("$controller")("noscp", d, b); a.$scope[b] = c}return function(f, g, h, l){var k, n, q; h = !0 === h; l && I(l) && (q = l); if (I(f)){l = f.match(Vc); if (!l)throw Nf("ctrlfmt", f); n = l[1]; q = q || l[3]; f = b.hasOwnProperty(n)?b[n]:Bc(g.$scope,
        n, !0) || (a?Bc(d, n, !0):t); Sa(f, n, !0)}if (h)return h = (G(f)?f[f.length - 1]:f).prototype, k = Object.create(h || null), q && e(g, q, k, n || f.name), Q(function(){var a = c.invoke(f, k, g, n); a !== k && (D(a) || C(a)) && (k = a, q && e(g, q, k, n || f.name)); return k}, {instance:k, identifier:q}); k = c.instantiate(f, g, n); q && e(g, q, k, n || f.name); return k}}]}function Ye(){this.$get = ["$window", function(b){return z(b.document)}]}function Ze(){this.$get = ["$log", function(b){return function(a, c){b.error.apply(b, arguments)}}]}function Yb(b){return D(b)?
        ca(b)?b.toISOString():db(b):b}function df(){this.$get = function(){return function(b){if (!b)return""; var a = []; mc(b, function(b, d){null === b || y(b) || (G(b)?m(b, function(b, c){a.push(ma(d) + "=" + ma(Yb(b)))}):a.push(ma(d) + "=" + ma(Yb(b))))}); return a.join("&")}}}function ef(){this.$get = function(){return function(b){function a(b, e, f){null === b || y(b) || (G(b)?m(b, function(b, c){a(b, e + "[" + (D(b)?c:"") + "]")}):D(b) && !ca(b)?mc(b, function(b, c){a(b, e + (f?"":"[") + c + (f?"":"]"))}):c.push(ma(e) + "=" + ma(Yb(b))))}if (!b)return""; var c =
[]; a(b, "", !0); return c.join("&")}}}function Zb(b, a){if (I(b)){var c = b.replace(Of, "").trim(); if (c){var d = a("Content-Type"); (d = d && 0 === d.indexOf(bd)) || (d = (d = c.match(Pf)) && Qf[d[0]].test(c)); d && (b = uc(c))}}return b}function cd(b){var a = ga(), c; I(b)?m(b.split("\n"), function(b){c = b.indexOf(":"); var e = M(T(b.substr(0, c))); b = T(b.substr(c + 1)); e && (a[e] = a[e]?a[e] + ", " + b:b)}):D(b) && m(b, function(b, c){var f = M(c), g = T(b); f && (a[f] = a[f]?a[f] + ", " + g:g)}); return a}function dd(b){var a; return function(c){a || (a = cd(b)); return c?
        (c = a[M(c)], void 0 === c && (c = null), c):a}}function ed(b, a, c, d){if (C(d))return d(b, a, c); m(d, function(d){b = d(b, a, c)}); return b}function cf(){var b = this.defaults = {transformResponse:[Zb], transformRequest:[function(a){return D(a) && "[object File]" !== sa.call(a) && "[object Blob]" !== sa.call(a) && "[object FormData]" !== sa.call(a)?db(a):a}], headers:{common:{Accept:"application/json, text/plain, */*"}, post:ia($b), put:ia($b), patch:ia($b)}, xsrfCookieName:"XSRF-TOKEN", xsrfHeaderName:"X-XSRF-TOKEN", paramSerializer:"$httpParamSerializer"},
        a = !1; this.useApplyAsync = function(b){return x(b)?(a = !!b, this):a}; var c = !0; this.useLegacyPromiseExtensions = function(a){return x(a)?(c = !!a, this):c}; var d = this.interceptors = []; this.$get = ["$httpBackend", "$$cookieReader", "$cacheFactory", "$rootScope", "$q", "$injector", function(e, f, g, h, l, k){function n(a){function d(a){var b = Q({}, a); b.data = a.data?ed(a.data, a.headers, a.status, f.transformResponse):a.data; a = a.status; return 200 <= a && 300 > a?b:l.reject(b)}function e(a, b){var c, d = {}; m(a, function(a, e){C(a)?(c = a(b), null !=
        c && (d[e] = c)):d[e] = a}); return d}if (!aa.isObject(a))throw L("$http")("badreq", a); var f = Q({method:"get", transformRequest:b.transformRequest, transformResponse:b.transformResponse, paramSerializer:b.paramSerializer}, a); f.headers = function(a){var c = b.headers, d = Q({}, a.headers), f, g, h, c = Q({}, c.common, c[M(a.method)]); a:for (f in c){g = M(f); for (h in d)if (M(h) === g)continue a; d[f] = c[f]}return e(d, ia(a))}(a); f.method = rb(f.method); f.paramSerializer = I(f.paramSerializer)?k.get(f.paramSerializer):f.paramSerializer; var g =
        [function(a){var c = a.headers, e = ed(a.data, dd(c), t, a.transformRequest); y(e) && m(c, function(a, b){"content-type" === M(b) && delete c[b]}); y(a.withCredentials) && !y(b.withCredentials) && (a.withCredentials = b.withCredentials); return q(a, e).then(d, d)}, t], h = l.when(f); for (m(B, function(a){(a.request || a.requestError) && g.unshift(a.request, a.requestError); (a.response || a.responseError) && g.push(a.response, a.responseError)}); g.length; ){a = g.shift(); var r = g.shift(), h = h.then(a, r)}c?(h.success = function(a){Sa(a, "fn"); h.then(function(b){a(b.data,
        b.status, b.headers, f)}); return h}, h.error = function(a){Sa(a, "fn"); h.then(null, function(b){a(b.data, b.status, b.headers, f)}); return h}):(h.success = fd("success"), h.error = fd("error")); return h}function q(c, d){function g(b, c, d, e){function f(){k(c, b, d, e)}F && (200 <= b && 300 > b?F.put(P, [b, c, cd(d), e]):F.remove(P)); a?h.$applyAsync(f):(f(), h.$$phase || h.$apply())}function k(a, b, d, e){b = Math.max(b, 0); (200 <= b && 300 > b?N.resolve:N.reject)({data:a, status:b, headers:dd(d), config:c, statusText:e})}function q(a){k(a.data, a.status,
        ia(a.headers()), a.statusText)}function B(){var a = n.pendingRequests.indexOf(c); - 1 !== a && n.pendingRequests.splice(a, 1)}var N = l.defer(), J = N.promise, F, m, S = c.headers, P = r(c.url, c.paramSerializer(c.params)); n.pendingRequests.push(c); J.then(B, B); !c.cache && !b.cache || !1 === c.cache || "GET" !== c.method && "JSONP" !== c.method || (F = D(c.cache)?c.cache:D(b.cache)?b.cache:u); F && (m = F.get(P), x(m)?m && C(m.then)?m.then(q, q):G(m)?k(m[1], m[0], ia(m[2]), m[3]):k(m, 200, {}, "OK"):F.put(P, J)); y(m) && ((m = gd(c.url)?f()[c.xsrfCookieName ||
        b.xsrfCookieName]:t) && (S[c.xsrfHeaderName || b.xsrfHeaderName] = m), e(c.method, P, d, g, S, c.timeout, c.withCredentials, c.responseType)); return J}function r(a, b){0 < b.length && (a += ( - 1 == a.indexOf("?")?"?":"&") + b); return a}var u = g("$http"); b.paramSerializer = I(b.paramSerializer)?k.get(b.paramSerializer):b.paramSerializer; var B = []; m(d, function(a){B.unshift(I(a)?k.get(a):k.invoke(a))}); n.pendingRequests = []; (function(a){m(arguments, function(a){n[a] = function(b, c){return n(Q({}, c || {}, {method:a, url:b}))}})})("get", "delete",
        "head", "jsonp"); (function(a){m(arguments, function(a){n[a] = function(b, c, d){return n(Q({}, d || {}, {method:a, url:b, data:c}))}})})("post", "put", "patch"); n.defaults = b; return n}]}function Rf(){return new O.XMLHttpRequest}function ff(){this.$get = ["$browser", "$window", "$document", function(b, a, c){return Sf(b, Rf, b.defer, a.angular.callbacks, c[0])}]}function Sf(b, a, c, d, e){function f(a, b, c){var f = e.createElement("script"), n = null; f.type = "text/javascript"; f.src = a; f.async = !0; n = function(a){f.removeEventListener("load",
        n, !1); f.removeEventListener("error", n, !1); e.body.removeChild(f); f = null; var g = - 1, u = "unknown"; a && ("load" !== a.type || d[b].called || (a = {type:"error"}), u = a.type, g = "error" === a.type?404:200); c && c(g, u)}; f.addEventListener("load", n, !1); f.addEventListener("error", n, !1); e.body.appendChild(f); return n}return function(e, h, l, k, n, q, r, u){function B(){p && p(); A && A.abort()}function K(a, d, e, f, g){H !== t && c.cancel(H); p = A = null; a(d, e, f, g); b.$$completeOutstandingRequest(v)}b.$$incOutstandingRequestCount(); h = h || b.url(); if ("jsonp" ==
        M(e)){var w = "_" + (d.counter++).toString(36); d[w] = function(a){d[w].data = a; d[w].called = !0}; var p = f(h.replace("JSON_CALLBACK", "angular.callbacks." + w), w, function(a, b){K(k, a, d[w].data, "", b); d[w] = v})} else{var A = a(); A.open(e, h, !0); m(n, function(a, b){x(a) && A.setRequestHeader(b, a)}); A.onload = function(){var a = A.statusText || "", b = "response"in A?A.response:A.responseText, c = 1223 === A.status?204:A.status; 0 === c && (c = b?200:"file" == Aa(h).protocol?404:0); K(k, c, b, A.getAllResponseHeaders(), a)}; e = function(){K(k, - 1, null, null,
        "")}; A.onerror = e; A.onabort = e; r && (A.withCredentials = !0); if (u)try{A.responseType = u} catch (s){if ("json" !== u)throw s; }A.send(l)}if (0 < q)var H = c(B, q);  else q && C(q.then) && q.then(B)}}function af(){var b = "{{", a = "}}"; this.startSymbol = function(a){return a?(b = a, this):b}; this.endSymbol = function(b){return b?(a = b, this):a}; this.$get = ["$parse", "$exceptionHandler", "$sce", function(c, d, e){function f(a){return"\\\\\\" + a}function g(c){return c.replace(n, b).replace(q, a)}function h(f, h, n, q){function w(a){try{var b = a; a = n?e.getTrusted(n,
        b):e.valueOf(b); var c; if (q && !x(a))c = a;  else if (null == a)c = "";  else{switch (typeof a){case "string":break; case "number":a = "" + a; break; default:a = db(a)}c = a}return c} catch (g){d(Ka.interr(f, g))}}q = !!q; for (var p, m, s = 0, H = [], N = [], J = f.length, F = [], V = []; s < J; )if ( - 1 != (p = f.indexOf(b, s)) && - 1 != (m = f.indexOf(a, p + l)))s !== p && F.push(g(f.substring(s, p))), s = f.substring(p + l, m), H.push(s), N.push(c(s, w)), s = m + k, V.push(F.length), F.push("");  else{s !== J && F.push(g(f.substring(s))); break}n && 1 < F.length && Ka.throwNoconcat(f); if (!h || H.length){var S =
        function(a){for (var b = 0, c = H.length; b < c; b++){if (q && y(a[b]))return; F[V[b]] = a[b]}return F.join("")}; return Q(function(a){var b = 0, c = H.length, e = Array(c); try{for (; b < c; b++)e[b] = N[b](a); return S(e)} catch (g){d(Ka.interr(f, g))}}, {exp:f, expressions:H, $$watchDelegate:function(a, b){var c; return a.$watchGroup(N, function(d, e){var f = S(d); C(b) && b.call(this, f, d !== e?c:f, a); c = f})}})}}var l = b.length, k = a.length, n = new RegExp(b.replace(/./g, f), "g"), q = new RegExp(a.replace(/./g, f), "g"); h.startSymbol = function(){return b}; h.endSymbol =
        function(){return a}; return h}]}function bf(){this.$get = ["$rootScope", "$window", "$q", "$$q", function(b, a, c, d){function e(e, h, l, k){var n = 4 < arguments.length, q = n?xa.call(arguments, 4):[], r = a.setInterval, u = a.clearInterval, B = 0, K = x(k) && !k, w = (K?d:c).defer(), p = w.promise; l = x(l)?l:0; p.then(null, null, n?function(){e.apply(null, q)}:e); p.$$intervalId = r(function(){w.notify(B++); 0 < l && B >= l && (w.resolve(B), u(p.$$intervalId), delete f[p.$$intervalId]); K || b.$apply()}, h); f[p.$$intervalId] = w; return p}var f = {}; e.cancel = function(b){return b &&
        b.$$intervalId in f?(f[b.$$intervalId].reject("canceled"), a.clearInterval(b.$$intervalId), delete f[b.$$intervalId], !0):!1}; return e}]}function ac(b){b = b.split("/"); for (var a = b.length; a--; )b[a] = nb(b[a]); return b.join("/")}function hd(b, a){var c = Aa(b); a.$$protocol = c.protocol; a.$$host = c.hostname; a.$$port = Y(c.port) || Tf[c.protocol] || null}function id(b, a){var c = "/" !== b.charAt(0); c && (b = "/" + b); var d = Aa(b); a.$$path = decodeURIComponent(c && "/" === d.pathname.charAt(0)?d.pathname.substring(1):d.pathname); a.$$search =
        xc(d.search); a.$$hash = decodeURIComponent(d.hash); a.$$path && "/" != a.$$path.charAt(0) && (a.$$path = "/" + a.$$path)}function ra(b, a){if (0 === a.indexOf(b))return a.substr(b.length)}function Ja(b){var a = b.indexOf("#"); return - 1 == a?b:b.substr(0, a)}function Cb(b){return b.replace(/(#.+)|#$/, "$1")}function bc(b, a, c){this.$$html5 = !0; c = c || ""; hd(b, this); this.$$parse = function(b){var c = ra(a, b); if (!I(c))throw Db("ipthprfx", b, a); id(c, this); this.$$path || (this.$$path = "/"); this.$$compose()}; this.$$compose = function(){var b =
        Pb(this.$$search), c = this.$$hash?"#" + nb(this.$$hash):""; this.$$url = ac(this.$$path) + (b?"?" + b:"") + c; this.$$absUrl = a + this.$$url.substr(1)}; this.$$parseLinkUrl = function(d, e){if (e && "#" === e[0])return this.hash(e.slice(1)), !0; var f, g; (f = ra(b, d)) !== t?(g = f, g = (f = ra(c, f)) !== t?a + (ra("/", f) || f):b + g):(f = ra(a, d)) !== t?g = a + f:a == d + "/" && (g = a); g && this.$$parse(g); return!!g}}function cc(b, a, c){hd(b, this); this.$$parse = function(d){var e = ra(b, d) || ra(a, d), f; y(e) || "#" !== e.charAt(0)?this.$$html5?f = e:(f = "", y(e) && (b = d, this.replace())):
        (f = ra(c, e), y(f) && (f = e)); id(f, this); d = this.$$path; var e = b, g = /^\/[A-Z]:(\/.*)/; 0 === f.indexOf(e) && (f = f.replace(e, "")); g.exec(f) || (d = (f = g.exec(d))?f[1]:d); this.$$path = d; this.$$compose()}; this.$$compose = function(){var a = Pb(this.$$search), e = this.$$hash?"#" + nb(this.$$hash):""; this.$$url = ac(this.$$path) + (a?"?" + a:"") + e; this.$$absUrl = b + (this.$$url?c + this.$$url:"")}; this.$$parseLinkUrl = function(a, c){return Ja(b) == Ja(a)?(this.$$parse(a), !0):!1}}function jd(b, a, c){this.$$html5 = !0; cc.apply(this, arguments); this.$$parseLinkUrl =
        function(d, e){if (e && "#" === e[0])return this.hash(e.slice(1)), !0; var f, g; b == Ja(d)?f = d:(g = ra(a, d))?f = b + c + g:a === d + "/" && (f = a); f && this.$$parse(f); return!!f}; this.$$compose = function(){var a = Pb(this.$$search), e = this.$$hash?"#" + nb(this.$$hash):""; this.$$url = ac(this.$$path) + (a?"?" + a:"") + e; this.$$absUrl = b + c + this.$$url}}function Eb(b){return function(){return this[b]}}function kd(b, a){return function(c){if (y(c))return this[b]; this[b] = a(c); this.$$compose(); return this}}function gf(){var b = "", a = {enabled:!1, requireBase:!0,
        rewriteLinks:!0}; this.hashPrefix = function(a){return x(a)?(b = a, this):b}; this.html5Mode = function(b){return ab(b)?(a.enabled = b, this):D(b)?(ab(b.enabled) && (a.enabled = b.enabled), ab(b.requireBase) && (a.requireBase = b.requireBase), ab(b.rewriteLinks) && (a.rewriteLinks = b.rewriteLinks), this):a}; this.$get = ["$rootScope", "$browser", "$sniffer", "$rootElement", "$window", function(c, d, e, f, g){function h(a, b, c){var e = k.url(), f = k.$$state; try{d.url(a, b, c), k.$$state = d.state()} catch (g){throw k.url(e), k.$$state = f, g; }}function l(a,
        b){c.$broadcast("$locationChangeSuccess", k.absUrl(), a, k.$$state, b)}var k, n; n = d.baseHref(); var q = d.url(), r; if (a.enabled){if (!n && a.requireBase)throw Db("nobase"); r = q.substring(0, q.indexOf("/", q.indexOf("//") + 2)) + (n || "/"); n = e.history?bc:jd} else r = Ja(q), n = cc; var u = r.substr(0, Ja(r).lastIndexOf("/") + 1); k = new n(r, u, "#" + b); k.$$parseLinkUrl(q, q); k.$$state = d.state(); var B = /^\s*(javascript|mailto):/i; f.on("click", function(b){if (a.rewriteLinks && !b.ctrlKey && !b.metaKey && !b.shiftKey && 2 != b.which && 2 != b.button){for (var e =
        z(b.target); "a" !== ta(e[0]); )if (e[0] === f[0] || !(e = e.parent())[0])return; var h = e.prop("href"), l = e.attr("href") || e.attr("xlink:href"); D(h) && "[object SVGAnimatedString]" === h.toString() && (h = Aa(h.animVal).href); B.test(h) || !h || e.attr("target") || b.isDefaultPrevented() || !k.$$parseLinkUrl(h, l) || (b.preventDefault(), k.absUrl() != d.url() && (c.$apply(), g.angular["ff-684208-preventDefault"] = !0))}}); Cb(k.absUrl()) != Cb(q) && d.url(k.absUrl(), !0); var K = !0; d.onUrlChange(function(a, b){y(ra(u, a))?g.location.href = a:(c.$evalAsync(function(){var d =
        k.absUrl(), e = k.$$state, f; k.$$parse(a); k.$$state = b; f = c.$broadcast("$locationChangeStart", a, d, b, e).defaultPrevented; k.absUrl() === a && (f?(k.$$parse(d), k.$$state = e, h(d, !1, e)):(K = !1, l(d, e)))}), c.$$phase || c.$digest())}); c.$watch(function(){var a = Cb(d.url()), b = Cb(k.absUrl()), f = d.state(), g = k.$$replace, n = a !== b || k.$$html5 && e.history && f !== k.$$state; if (K || n)K = !1, c.$evalAsync(function(){var b = k.absUrl(), d = c.$broadcast("$locationChangeStart", b, a, k.$$state, f).defaultPrevented; k.absUrl() === b && (d?(k.$$parse(a), k.$$state =
        f):(n && h(b, g, f === k.$$state?null:k.$$state), l(a, f)))}); k.$$replace = !1}); return k}]}function hf(){var b = !0, a = this; this.debugEnabled = function(a){return x(a)?(b = a, this):b}; this.$get = ["$window", function(c){function d(a){a instanceof Error && (a.stack?a = a.message && - 1 === a.stack.indexOf(a.message)?"Error: " + a.message + "\n" + a.stack:a.stack:a.sourceURL && (a = a.message + "\n" + a.sourceURL + ":" + a.line)); return a}function e(a){var b = c.console || {}, e = b[a] || b.log || v; a = !1; try{a = !!e.apply} catch (l){}return a?function(){var a =
[]; m(arguments, function(b){a.push(d(b))}); return e.apply(b, a)}:function(a, b){e(a, null == b?"":b)}}return{log:e("log"), info:e("info"), warn:e("warn"), error:e("error"), debug:function(){var c = e("debug"); return function(){b && c.apply(a, arguments)}}()}}]}function Wa(b, a){if ("__defineGetter__" === b || "__defineSetter__" === b || "__lookupGetter__" === b || "__lookupSetter__" === b || "__proto__" === b)throw da("isecfld", a); return b}function Ba(b, a){if (b){if (b.constructor === b)throw da("isecfn", a); if (b.window === b)throw da("isecwindow",
        a); if (b.children && (b.nodeName || b.prop && b.attr && b.find))throw da("isecdom", a); if (b === Object)throw da("isecobj", a); }return b}function ld(b, a){if (b){if (b.constructor === b)throw da("isecfn", a); if (b === Uf || b === Vf || b === Wf)throw da("isecff", a); }}function Xf(b, a){return"undefined" !== typeof b?b:a}function md(b, a){return"undefined" === typeof b?a:"undefined" === typeof a?b:b + a}function U(b, a){var c, d; switch (b.type){case s.Program:c = !0; m(b.body, function(b){U(b.expression, a); c = c && b.expression.constant}); b.constant =
        c; break; case s.Literal:b.constant = !0; b.toWatch = []; break; case s.UnaryExpression:U(b.argument, a); b.constant = b.argument.constant; b.toWatch = b.argument.toWatch; break; case s.BinaryExpression:U(b.left, a); U(b.right, a); b.constant = b.left.constant && b.right.constant; b.toWatch = b.left.toWatch.concat(b.right.toWatch); break; case s.LogicalExpression:U(b.left, a); U(b.right, a); b.constant = b.left.constant && b.right.constant; b.toWatch = b.constant?[]:[b]; break; case s.ConditionalExpression:U(b.test, a); U(b.alternate, a); U(b.consequent,
        a); b.constant = b.test.constant && b.alternate.constant && b.consequent.constant; b.toWatch = b.constant?[]:[b]; break; case s.Identifier:b.constant = !1; b.toWatch = [b]; break; case s.MemberExpression:U(b.object, a); b.computed && U(b.property, a); b.constant = b.object.constant && (!b.computed || b.property.constant); b.toWatch = [b]; break; case s.CallExpression:c = b.filter?!a(b.callee.name).$stateful:!1; d = []; m(b.arguments, function(b){U(b, a); c = c && b.constant; b.constant || d.push.apply(d, b.toWatch)}); b.constant = c; b.toWatch = b.filter &&
        !a(b.callee.name).$stateful?d:[b]; break; case s.AssignmentExpression:U(b.left, a); U(b.right, a); b.constant = b.left.constant && b.right.constant; b.toWatch = [b]; break; case s.ArrayExpression:c = !0; d = []; m(b.elements, function(b){U(b, a); c = c && b.constant; b.constant || d.push.apply(d, b.toWatch)}); b.constant = c; b.toWatch = d; break; case s.ObjectExpression:c = !0; d = []; m(b.properties, function(b){U(b.value, a); c = c && b.value.constant; b.value.constant || d.push.apply(d, b.value.toWatch)}); b.constant = c; b.toWatch = d; break; case s.ThisExpression:b.constant =
        !1, b.toWatch = []}}function nd(b){if (1 == b.length){b = b[0].expression; var a = b.toWatch; return 1 !== a.length?a:a[0] !== b?a:t}}function od(b){return b.type === s.Identifier || b.type === s.MemberExpression}function pd(b){if (1 === b.body.length && od(b.body[0].expression))return{type:s.AssignmentExpression, left:b.body[0].expression, right:{type:s.NGValueParameter}, operator:"="}}function qd(b){return 0 === b.body.length || 1 === b.body.length && (b.body[0].expression.type === s.Literal || b.body[0].expression.type === s.ArrayExpression ||
        b.body[0].expression.type === s.ObjectExpression)}function rd(b, a){this.astBuilder = b; this.$filter = a}function sd(b, a){this.astBuilder = b; this.$filter = a}function Fb(b){return"constructor" == b}function dc(b){return C(b.valueOf)?b.valueOf():Yf.call(b)}function jf(){var b = ga(), a = ga(); this.$get = ["$filter", function(c){function d(a, b){return null == a || null == b?a === b:"object" === typeof a && (a = dc(a), "object" === typeof a)?!1:a === b || a !== a && b !== b}function e(a, b, c, e, f){var g = e.inputs, h; if (1 === g.length){var l = d, g = g[0]; return a.$watch(function(a){var b =
        g(a); d(b, l) || (h = e(a, t, t, [b]), l = b && dc(b)); return h}, b, c, f)}for (var k = [], n = [], q = 0, m = g.length; q < m; q++)k[q] = d, n[q] = null; return a.$watch(function(a){for (var b = !1, c = 0, f = g.length; c < f; c++){var l = g[c](a); if (b || (b = !d(l, k[c])))n[c] = l, k[c] = l && dc(l)}b && (h = e(a, t, t, n)); return h}, b, c, f)}function f(a, b, c, d){var e, f; return e = a.$watch(function(a){return d(a)}, function(a, c, d){f = a; C(b) && b.apply(this, arguments); x(a) && d.$$postDigest(function(){x(f) && e()})}, c)}function g(a, b, c, d){function e(a){var b = !0; m(a, function(a){x(a) ||
        (b = !1)}); return b}var f, g; return f = a.$watch(function(a){return d(a)}, function(a, c, d){g = a; C(b) && b.call(this, a, c, d); e(a) && d.$$postDigest(function(){e(g) && f()})}, c)}function h(a, b, c, d){var e; return e = a.$watch(function(a){return d(a)}, function(a, c, d){C(b) && b.apply(this, arguments); e()}, c)}function l(a, b){if (!b)return a; var c = a.$$watchDelegate, c = c !== g && c !== f?function(c, d, e, f){e = a(c, d, e, f); return b(e, c, d)}:function(c, d, e, f){e = a(c, d, e, f); c = b(e, c, d); return x(e)?c:e}; a.$$watchDelegate && a.$$watchDelegate !==
        e?c.$$watchDelegate = a.$$watchDelegate:b.$stateful || (c.$$watchDelegate = e, c.inputs = a.inputs?a.inputs:[a]); return c}var k = Fa().noUnsafeEval, n = {csp:k, expensiveChecks:!1}, q = {csp:k, expensiveChecks:!0}; return function(d, k, B){var m, w, p; switch (typeof d){case "string":p = d = d.trim(); var s = B?a:b; m = s[p]; m || (":" === d.charAt(0) && ":" === d.charAt(1) && (w = !0, d = d.substring(2)), B = B?q:n, m = new ec(B), m = (new fc(m, c, B)).parse(d), m.constant?m.$$watchDelegate = h:w?m.$$watchDelegate = m.literal?g:f:m.inputs && (m.$$watchDelegate = e),
s[p] = m); return l(m, k); case "function":return l(d, k); default:return v}}}]}function lf(){this.$get = ["$rootScope", "$exceptionHandler", function(b, a){return td(function(a){b.$evalAsync(a)}, a)}]}function mf(){this.$get = ["$browser", "$exceptionHandler", function(b, a){return td(function(a){b.defer(a)}, a)}]}function td(b, a){function c(a, b, c){function d(b){return function(c){e || (e = !0, b.call(a, c))}}var e = !1; return[d(b), d(c)]}function d(){this.$$state = {status:0}}function e(a, b){return function(c){b.call(a, c)}}
function f(c){!c.processScheduled && c.pending && (c.processScheduled = !0, b(function(){var b, d, e; e = c.pending; c.processScheduled = !1; c.pending = t; for (var f = 0, g = e.length; f < g; ++f){d = e[f][0]; b = e[f][c.status]; try{C(b)?d.resolve(b(c.value)):1 === c.status?d.resolve(c.value):d.reject(c.value)} catch (h){d.reject(h), a(h)}}}))}function g(){this.promise = new d; this.resolve = e(this, this.resolve); this.reject = e(this, this.reject); this.notify = e(this, this.notify)}var h = L("$q", TypeError); Q(d.prototype, {then:function(a, b, c){if (y(a) &&
        y(b) && y(c))return this; var d = new g; this.$$state.pending = this.$$state.pending || []; this.$$state.pending.push([d, a, b, c]); 0 < this.$$state.status && f(this.$$state); return d.promise}, "catch":function(a){return this.then(null, a)}, "finally":function(a, b){return this.then(function(b){return k(b, !0, a)}, function(b){return k(b, !1, a)}, b)}}); Q(g.prototype, {resolve:function(a){this.promise.$$state.status || (a === this.promise?this.$$reject(h("qcycle", a)):this.$$resolve(a))}, $$resolve:function(b){var d, e; e = c(this, this.$$resolve,
        this.$$reject); try{if (D(b) || C(b))d = b && b.then; C(d)?(this.promise.$$state.status = - 1, d.call(b, e[0], e[1], this.notify)):(this.promise.$$state.value = b, this.promise.$$state.status = 1, f(this.promise.$$state))} catch (g){e[1](g), a(g)}}, reject:function(a){this.promise.$$state.status || this.$$reject(a)}, $$reject:function(a){this.promise.$$state.value = a; this.promise.$$state.status = 2; f(this.promise.$$state)}, notify:function(c){var d = this.promise.$$state.pending; 0 >= this.promise.$$state.status && d && d.length && b(function(){for (var b,
        e, f = 0, g = d.length; f < g; f++){e = d[f][0]; b = d[f][3]; try{e.notify(C(b)?b(c):c)} catch (h){a(h)}}})}}); var l = function(a, b){var c = new g; b?c.resolve(a):c.reject(a); return c.promise}, k = function(a, b, c){var d = null; try{C(c) && (d = c())} catch (e){return l(e, !1)}return d && C(d.then)?d.then(function(){return l(a, b)}, function(a){return l(a, !1)}):l(a, b)}, n = function(a, b, c, d){var e = new g; e.resolve(a); return e.promise.then(b, c, d)}, q = function u(a){if (!C(a))throw h("norslvr", a); if (!(this instanceof u))return new u(a); var b = new g;
        a(function(a){b.resolve(a)}, function(a){b.reject(a)}); return b.promise}; q.defer = function(){return new g}; q.reject = function(a){var b = new g; b.reject(a); return b.promise}; q.when = n; q.resolve = n; q.all = function(a){var b = new g, c = 0, d = G(a)?[]:{}; m(a, function(a, e){c++; n(a).then(function(a){d.hasOwnProperty(e) || (d[e] = a, --c || b.resolve(d))}, function(a){d.hasOwnProperty(e) || b.reject(a)})}); 0 === c && b.resolve(d); return b.promise}; return q}function vf(){this.$get = ["$window", "$timeout", function(b, a){function c(){for (var a =
        0; a < n.length; a++){var b = n[a]; b && (n[a] = null, b())}k = n.length = 0}function d(a){var b = n.length; k++; n.push(a); 0 === b && (l = h(c)); return function(){0 <= b && (b = n[b] = null, 0 === --k && l && (l(), l = null, n.length = 0))}}var e = b.requestAnimationFrame || b.webkitRequestAnimationFrame, f = b.cancelAnimationFrame || b.webkitCancelAnimationFrame || b.webkitCancelRequestAnimationFrame, g = !!e, h = g?function(a){var b = e(a); return function(){f(b)}}:function(b){var c = a(b, 16.66, !1); return function(){a.cancel(c)}}; d.supported = g; var l, k = 0, n = []; return d}]}
function kf(){function b(a){function b(){this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null; this.$$listeners = {}; this.$$listenerCount = {}; this.$$watchersCount = 0; this.$id = ++mb; this.$$ChildScope = null}b.prototype = a; return b}var a = 10, c = L("$rootScope"), d = null, e = null; this.digestTtl = function(b){arguments.length && (a = b); return a}; this.$get = ["$injector", "$exceptionHandler", "$parse", "$browser", function(f, g, h, l){function k(a){a.currentScope.$$destroyed = !0}function n(){this.$id = ++mb; this.$$phase =
        this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null; this.$root = this; this.$$destroyed = !1; this.$$listeners = {}; this.$$listenerCount = {}; this.$$watchersCount = 0; this.$$isolateBindings = null}function q(a){if (p.$$phase)throw c("inprog", p.$$phase); p.$$phase = a}function r(a, b){do a.$$watchersCount += b; while (a = a.$parent)}function u(a, b, c){do a.$$listenerCount[c] -= b, 0 === a.$$listenerCount[c] && delete a.$$listenerCount[c]; while (a = a.$parent)}function s(){}function K(){for (; H.length; )try{H.shift()()} catch (a){g(a)}e =
null}function w(){null === e && (e = l.defer(function(){p.$apply(K)}))}n.prototype = {constructor:n, $new:function(a, c){var d; c = c || this; a?(d = new n, d.$root = this.$root):(this.$$ChildScope || (this.$$ChildScope = b(this)), d = new this.$$ChildScope); d.$parent = c; d.$$prevSibling = c.$$childTail; c.$$childHead?(c.$$childTail.$$nextSibling = d, c.$$childTail = d):c.$$childHead = c.$$childTail = d; (a || c != this) && d.$on("$destroy", k); return d}, $watch:function(a, b, c, e){var f = h(a); if (f.$$watchDelegate)return f.$$watchDelegate(this, b, c, f,
        a); var g = this, l = g.$$watchers, k = {fn:b, last:s, get:f, exp:e || a, eq:!!c}; d = null; C(b) || (k.fn = v); l || (l = g.$$watchers = []); l.unshift(k); r(this, 1); return function(){0 <= bb(l, k) && r(g, - 1); d = null}}, $watchGroup:function(a, b){function c(){h = !1; l?(l = !1, b(e, e, g)):b(e, d, g)}var d = Array(a.length), e = Array(a.length), f = [], g = this, h = !1, l = !0; if (!a.length){var k = !0; g.$evalAsync(function(){k && b(e, e, g)}); return function(){k = !1}}if (1 === a.length)return this.$watch(a[0], function(a, c, f){e[0] = a; d[0] = c; b(e, a === c?e:d, f)}); m(a, function(a,
        b){var l = g.$watch(a, function(a, f){e[b] = a; d[b] = f; h || (h = !0, g.$evalAsync(c))}); f.push(l)}); return function(){for (; f.length; )f.shift()()}}, $watchCollection:function(a, b){function c(a){e = a; var b, d, g, h; if (!y(e)){if (D(e))if (Da(e))for (f !== q && (f = q, u = f.length = 0, k++), a = e.length, u !== a && (k++, f.length = u = a), b = 0; b < a; b++)h = f[b], g = e[b], d = h !== h && g !== g, d || h === g || (k++, f[b] = g);  else{f !== r && (f = r = {}, u = 0, k++); a = 0; for (b in e)e.hasOwnProperty(b) && (a++, g = e[b], h = f[b], b in f?(d = h !== h && g !== g, d || h === g || (k++, f[b] = g)):(u++, f[b] = g,
        k++)); if (u > a)for (b in k++, f)e.hasOwnProperty(b) || (u--, delete f[b])} else f !== e && (f = e, k++); return k}}c.$stateful = !0; var d = this, e, f, g, l = 1 < b.length, k = 0, n = h(a, c), q = [], r = {}, p = !0, u = 0; return this.$watch(n, function(){p?(p = !1, b(e, e, d)):b(e, g, d); if (l)if (D(e))if (Da(e)){g = Array(e.length); for (var a = 0; a < e.length; a++)g[a] = e[a]} else for (a in g = {}, e)Na.call(e, a) && (g[a] = e[a]);  else g = e})}, $digest:function(){var b, f, h, k, n, r, u = a, m, w = [], E, H; q("$digest"); l.$$checkUrlChange(); this === p && null !== e && (l.defer.cancel(e), K()); d =
        null; do{r = !1; for (m = this; t.length; ){try{H = t.shift(), H.scope.$eval(H.expression, H.locals)} catch (v){g(v)}d = null}a:do{if (k = m.$$watchers)for (n = k.length; n--; )try{if (b = k[n])if ((f = b.get(m)) !== (h = b.last) && !(b.eq?ka(f, h):"number" === typeof f && "number" === typeof h && isNaN(f) && isNaN(h)))r = !0, d = b, b.last = b.eq?fa(f, null):f, b.fn(f, h === s?f:h, m), 5 > u && (E = 4 - u, w[E] || (w[E] = []), w[E].push({msg:C(b.exp)?"fn: " + (b.exp.name || b.exp.toString()):b.exp, newVal:f, oldVal:h}));  else if (b === d){r = !1; break a}} catch (y){g(y)}if (!(k = m.$$watchersCount &&
                m.$$childHead || m !== this && m.$$nextSibling))for (; m !== this && !(k = m.$$nextSibling); )m = m.$parent}while (m = k); if ((r || t.length) && !u--)throw p.$$phase = null, c("infdig", a, w); }while (r || t.length); for (p.$$phase = null; x.length; )try{x.shift()()} catch (z){g(z)}}, $destroy:function(){if (!this.$$destroyed){var a = this.$parent; this.$broadcast("$destroy"); this.$$destroyed = !0; this === p && l.$$applicationDestroyed(); r(this, - this.$$watchersCount); for (var b in this.$$listenerCount)u(this, this.$$listenerCount[b], b); a && a.$$childHead ==
        this && (a.$$childHead = this.$$nextSibling); a && a.$$childTail == this && (a.$$childTail = this.$$prevSibling); this.$$prevSibling && (this.$$prevSibling.$$nextSibling = this.$$nextSibling); this.$$nextSibling && (this.$$nextSibling.$$prevSibling = this.$$prevSibling); this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = v; this.$on = this.$watch = this.$watchGroup = function(){return v}; this.$$listeners = {}; this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = this.$root = this.$$watchers =
null}}, $eval:function(a, b){return h(a)(this, b)}, $evalAsync:function(a, b){p.$$phase || t.length || l.defer(function(){t.length && p.$digest()}); t.push({scope:this, expression:a, locals:b})}, $$postDigest:function(a){x.push(a)}, $apply:function(a){try{q("$apply"); try{return this.$eval(a)} finally{p.$$phase = null}} catch (b){g(b)} finally{try{p.$digest()} catch (c){throw g(c), c; }}}, $applyAsync:function(a){function b(){c.$eval(a)}var c = this; a && H.push(b); w()}, $on:function(a, b){var c = this.$$listeners[a]; c || (this.$$listeners[a] =
        c = []); c.push(b); var d = this; do d.$$listenerCount[a] || (d.$$listenerCount[a] = 0), d.$$listenerCount[a]++; while (d = d.$parent); var e = this; return function(){var d = c.indexOf(b); - 1 !== d && (c[d] = null, u(e, 1, a))}}, $emit:function(a, b){var c = [], d, e = this, f = !1, h = {name:a, targetScope:e, stopPropagation:function(){f = !0}, preventDefault:function(){h.defaultPrevented = !0}, defaultPrevented:!1}, l = cb([h], arguments, 1), k, n; do{d = e.$$listeners[a] || c; h.currentScope = e; k = 0; for (n = d.length; k < n; k++)if (d[k])try{d[k].apply(null, l)} catch (q){g(q)} else d.splice(k,
        1), k--, n--; if (f)return h.currentScope = null, h; e = e.$parent}while (e); h.currentScope = null; return h}, $broadcast:function(a, b){var c = this, d = this, e = {name:a, targetScope:this, preventDefault:function(){e.defaultPrevented = !0}, defaultPrevented:!1}; if (!this.$$listenerCount[a])return e; for (var f = cb([e], arguments, 1), h, l; c = d; ){e.currentScope = c; d = c.$$listeners[a] || []; h = 0; for (l = d.length; h < l; h++)if (d[h])try{d[h].apply(null, f)} catch (k){g(k)} else d.splice(h, 1), h--, l--; if (!(d = c.$$listenerCount[a] && c.$$childHead || c !== this &&
        c.$$nextSibling))for (; c !== this && !(d = c.$$nextSibling); )c = c.$parent}e.currentScope = null; return e}}; var p = new n, t = p.$$asyncQueue = [], x = p.$$postDigestQueue = [], H = p.$$applyAsyncQueue = []; return p}]}function ge(){var b = /^\s*(https?|ftp|mailto|tel|file):/, a = /^\s*((https?|ftp|file|blob):|data:image\/)/; this.aHrefSanitizationWhitelist = function(a){return x(a)?(b = a, this):b}; this.imgSrcSanitizationWhitelist = function(b){return x(b)?(a = b, this):a}; this.$get = function(){return function(c, d){var e = d?a:b, f; f = Aa(c).href;
        return"" === f || f.match(e)?c:"unsafe:" + f}}}function Zf(b){if ("self" === b)return b; if (I(b)){if ( - 1 < b.indexOf("***"))throw Ca("iwcard", b); b = ud(b).replace("\\*\\*", ".*").replace("\\*", "[^:/.?&;]*"); return new RegExp("^" + b + "$")}if (Oa(b))return new RegExp("^" + b.source + "$"); throw Ca("imatcher"); }function vd(b){var a = []; x(b) && m(b, function(b){a.push(Zf(b))}); return a}function of(){this.SCE_CONTEXTS = oa; var b = ["self"], a = []; this.resourceUrlWhitelist = function(a){arguments.length && (b = vd(a)); return b}; this.resourceUrlBlacklist =
        function(b){arguments.length && (a = vd(b)); return a}; this.$get = ["$injector", function(c){function d(a, b){return"self" === a?gd(b):!!a.exec(b.href)}function e(a){var b = function(a){this.$$unwrapTrustedValue = function(){return a}}; a && (b.prototype = new a); b.prototype.valueOf = function(){return this.$$unwrapTrustedValue()}; b.prototype.toString = function(){return this.$$unwrapTrustedValue().toString()}; return b}var f = function(a){throw Ca("unsafe"); }; c.has("$sanitize") && (f = c.get("$sanitize")); var g = e(), h = {}; h[oa.HTML] =
        e(g); h[oa.CSS] = e(g); h[oa.URL] = e(g); h[oa.JS] = e(g); h[oa.RESOURCE_URL] = e(h[oa.URL]); return{trustAs:function(a, b){var c = h.hasOwnProperty(a)?h[a]:null; if (!c)throw Ca("icontext", a, b); if (null === b || b === t || "" === b)return b; if ("string" !== typeof b)throw Ca("itype", a); return new c(b)}, getTrusted:function(c, e){if (null === e || e === t || "" === e)return e; var g = h.hasOwnProperty(c)?h[c]:null; if (g && e instanceof g)return e.$$unwrapTrustedValue(); if (c === oa.RESOURCE_URL){var g = Aa(e.toString()), q, r, u = !1; q = 0; for (r = b.length; q < r; q++)if (d(b[q],
        g)){u = !0; break}if (u)for (q = 0, r = a.length; q < r; q++)if (d(a[q], g)){u = !1; break}if (u)return e; throw Ca("insecurl", e.toString()); }if (c === oa.HTML)return f(e); throw Ca("unsafe"); }, valueOf:function(a){return a instanceof g?a.$$unwrapTrustedValue():a}}}]}function nf(){var b = !0; this.enabled = function(a){arguments.length && (b = !!a); return b}; this.$get = ["$parse", "$sceDelegate", function(a, c){if (b && 8 > Va)throw Ca("iequirks"); var d = ia(oa); d.isEnabled = function(){return b}; d.trustAs = c.trustAs; d.getTrusted = c.getTrusted; d.valueOf =
        c.valueOf; b || (d.trustAs = d.getTrusted = function(a, b){return b}, d.valueOf = Za); d.parseAs = function(b, c){var e = a(c); return e.literal && e.constant?e:a(c, function(a){return d.getTrusted(b, a)})}; var e = d.parseAs, f = d.getTrusted, g = d.trustAs; m(oa, function(a, b){var c = M(b); d[fb("parse_as_" + c)] = function(b){return e(a, b)}; d[fb("get_trusted_" + c)] = function(b){return f(a, b)}; d[fb("trust_as_" + c)] = function(b){return g(a, b)}}); return d}]}function pf(){this.$get = ["$window", "$document", function(b, a){var c = {}, d = Y((/android (\d+)/.exec(M((b.navigator ||
{}).userAgent)) || [])[1]), e = /Boxee/i.test((b.navigator || {}).userAgent), f = a[0] || {}, g, h = /^(Moz|webkit|ms)(?=[A-Z])/, l = f.body && f.body.style, k = !1, n = !1; if (l){for (var q in l)if (k = h.exec(q)){g = k[0]; g = g.substr(0, 1).toUpperCase() + g.substr(1); break}g || (g = "WebkitOpacity"in l && "webkit"); k = !!("transition"in l || g + "Transition"in l); n = !!("animation"in l || g + "Animation"in l); !d || k && n || (k = I(l.webkitTransition), n = I(l.webkitAnimation))}return{history:!(!b.history || !b.history.pushState || 4 > d || e), hasEvent:function(a){if ("input" ===
        a && 11 >= Va)return!1; if (y(c[a])){var b = f.createElement("div"); c[a] = "on" + a in b}return c[a]}, csp:Fa(), vendorPrefix:g, transitions:k, animations:n, android:d}}]}function rf(){this.$get = ["$templateCache", "$http", "$q", "$sce", function(b, a, c, d){function e(f, g){e.totalPendingRequests++; I(f) && b.get(f) || (f = d.getTrustedResourceUrl(f)); var h = a.defaults && a.defaults.transformResponse; G(h)?h = h.filter(function(a){return a !== Zb}):h === Zb && (h = null); return a.get(f, {cache:b, transformResponse:h})["finally"](function(){e.totalPendingRequests--}).then(function(a){b.put(f,
        a.data); return a.data}, function(a){if (!g)throw ea("tpload", f, a.status, a.statusText); return c.reject(a)})}e.totalPendingRequests = 0; return e}]}function sf(){this.$get = ["$rootScope", "$browser", "$location", function(b, a, c){return{findBindings:function(a, b, c){a = a.getElementsByClassName("ng-binding"); var g = []; m(a, function(a){var d = aa.element(a).data("$binding"); d && m(d, function(d){c?(new RegExp("(^|\\s)" + ud(b) + "(\\s|\\||$)")).test(d) && g.push(a): - 1 != d.indexOf(b) && g.push(a)})}); return g}, findModels:function(a,
        b, c){for (var g = ["ng-", "data-ng-", "ng\\:"], h = 0; h < g.length; ++h){var l = a.querySelectorAll("[" + g[h] + "model" + (c?"=":"*=") + '"' + b + '"]'); if (l.length)return l}}, getLocation:function(){return c.url()}, setLocation:function(a){a !== c.url() && (c.url(a), b.$digest())}, whenStable:function(b){a.notifyWhenNoOutstandingRequests(b)}}}]}function tf(){this.$get = ["$rootScope", "$browser", "$q", "$$q", "$exceptionHandler", function(b, a, c, d, e){function f(f, l, k){C(f) || (k = l, l = f, f = v); var n = xa.call(arguments, 3), q = x(k) && !k, r = (q?d:c).defer(),
        u = r.promise, m; m = a.defer(function(){try{r.resolve(f.apply(null, n))} catch (a){r.reject(a), e(a)} finally{delete g[u.$$timeoutId]}q || b.$apply()}, l); u.$$timeoutId = m; g[m] = r; return u}var g = {}; f.cancel = function(b){return b && b.$$timeoutId in g?(g[b.$$timeoutId].reject("canceled"), delete g[b.$$timeoutId], a.defer.cancel(b.$$timeoutId)):!1}; return f}]}function Aa(b){Va && (Z.setAttribute("href", b), b = Z.href); Z.setAttribute("href", b); return{href:Z.href, protocol:Z.protocol?Z.protocol.replace(/:$/, ""):"", host:Z.host,
        search:Z.search?Z.search.replace(/^\?/, ""):"", hash:Z.hash?Z.hash.replace(/^#/, ""):"", hostname:Z.hostname, port:Z.port, pathname:"/" === Z.pathname.charAt(0)?Z.pathname:"/" + Z.pathname}}function gd(b){b = I(b)?Aa(b):b; return b.protocol === wd.protocol && b.host === wd.host}function uf(){this.$get = qa(O)}function xd(b){function a(a){try{return decodeURIComponent(a)} catch (b){return a}}var c = b[0] || {}, d = {}, e = ""; return function(){var b, g, h, l, k; b = c.cookie || ""; if (b !== e)for (e = b, b = e.split("; "), d = {}, h = 0; h < b.length; h++)g =
b[h], l = g.indexOf("="), 0 < l && (k = a(g.substring(0, l)), d[k] === t && (d[k] = a(g.substring(l + 1)))); return d}}function yf(){this.$get = xd}function Jc(b){function a(c, d){if (D(c)){var e = {}; m(c, function(b, c){e[c] = a(c, b)}); return e}return b.factory(c + "Filter", d)}this.register = a; this.$get = ["$injector", function(a){return function(b){return a.get(b + "Filter")}}]; a("currency", yd); a("date", zd); a("filter", $f); a("json", ag); a("limitTo", bg); a("lowercase", cg); a("number", Ad); a("orderBy", Bd); a("uppercase", dg)}function $f(){return function(b,
        a, c){if (!Da(b)){if (null == b)return b; throw L("filter")("notarray", b); }var d; switch (gc(a)){case "function":break; case "boolean":case "null":case "number":case "string":d = !0; case "object":a = eg(a, c, d); break; default:return b}return Array.prototype.filter.call(b, a)}}function eg(b, a, c){var d = D(b) && "$"in b; !0 === a?a = ka:C(a) || (a = function(a, b){if (y(a))return!1; if (null === a || null === b)return a === b; if (D(b) || D(a) && !pc(a))return!1; a = M("" + a); b = M("" + b); return - 1 !== a.indexOf(b)}); return function(e){return d && !D(e)?La(e,
        b.$, a, !1):La(e, b, a, c)}}function La(b, a, c, d, e){var f = gc(b), g = gc(a); if ("string" === g && "!" === a.charAt(0))return!La(b, a.substring(1), c, d); if (G(b))return b.some(function(b){return La(b, a, c, d)}); switch (f){case "object":var h; if (d){for (h in b)if ("$" !== h.charAt(0) && La(b[h], a, c, !0))return!0; return e?!1:La(b, a, c, !1)}if ("object" === g){for (h in a)if (e = a[h], !C(e) && !y(e) && (f = "$" === h, !La(f?b:b[h], e, c, f, f)))return!1; return!0}return c(b, a); case "function":return!1; default:return c(b, a)}}function gc(b){return null ===
        b?"null":typeof b}function yd(b){var a = b.NUMBER_FORMATS; return function(b, d, e){y(d) && (d = a.CURRENCY_SYM); y(e) && (e = a.PATTERNS[1].maxFrac); return null == b?b:Cd(b, a.PATTERNS[1], a.GROUP_SEP, a.DECIMAL_SEP, e).replace(/\u00A4/g, d)}}function Ad(b){var a = b.NUMBER_FORMATS; return function(b, d){return null == b?b:Cd(b, a.PATTERNS[0], a.GROUP_SEP, a.DECIMAL_SEP, d)}}function Cd(b, a, c, d, e){if (D(b))return""; var f = 0 > b; b = Math.abs(b); var g = Infinity === b; if (!g && !isFinite(b))return""; var h = b + "", l = "", k = !1, n = []; g && (l = "\u221e");
        if (!g && - 1 !== h.indexOf("e")){var q = h.match(/([\d\.]+)e(-?)(\d+)/); q && "-" == q[2] && q[3] > e + 1?b = 0:(l = h, k = !0)}if (g || k)0 < e && 1 > b && (l = b.toFixed(e), b = parseFloat(l));  else{g = (h.split(Dd)[1] || "").length; y(e) && (e = Math.min(Math.max(a.minFrac, g), a.maxFrac)); b = + (Math.round( + (b.toString() + "e" + e)).toString() + "e" + - e); var g = ("" + b).split(Dd), h = g[0], g = g[1] || "", q = 0, r = a.lgSize, u = a.gSize; if (h.length >= r + u)for (q = h.length - r, k = 0; k < q; k++)0 === (q - k) % u && 0 !== k && (l += c), l += h.charAt(k); for (k = q; k < h.length; k++)0 === (h.length - k) % r && 0 !== k &&
        (l += c), l += h.charAt(k); for (; g.length < e; )g += "0"; e && "0" !== e && (l += d + g.substr(0, e))}0 === b && (f = !1); n.push(f?a.negPre:a.posPre, l, f?a.negSuf:a.posSuf); return n.join("")}function Gb(b, a, c){var d = ""; 0 > b && (d = "-", b = - b); for (b = "" + b; b.length < a; )b = "0" + b; c && (b = b.substr(b.length - a)); return d + b}function $(b, a, c, d){c = c || 0; return function(e){e = e["get" + b](); if (0 < c || e > - c)e += c; 0 === e && - 12 == c && (e = 12); return Gb(e, a, d)}}function Hb(b, a){return function(c, d){var e = c["get" + b](), f = rb(a?"SHORT" + b:b); return d[f][e]}}function Ed(b){var a =
        (new Date(b, 0, 1)).getDay(); return new Date(b, 0, (4 >= a?5:12) - a)}function Fd(b){return function(a){var c = Ed(a.getFullYear()); a = + new Date(a.getFullYear(), a.getMonth(), a.getDate() + (4 - a.getDay())) - + c; a = 1 + Math.round(a / 6048E5); return Gb(a, b)}}function hc(b, a){return 0 >= b.getFullYear()?a.ERAS[0]:a.ERAS[1]}function zd(b){function a(a){var b; if (b = a.match(c)){a = new Date(0); var f = 0, g = 0, h = b[8]?a.setUTCFullYear:a.setFullYear, l = b[8]?a.setUTCHours:a.setHours; b[9] && (f = Y(b[9] + b[10]), g = Y(b[9] + b[11])); h.call(a, Y(b[1]),
        Y(b[2]) - 1, Y(b[3])); f = Y(b[4] || 0) - f; g = Y(b[5] || 0) - g; h = Y(b[6] || 0); b = Math.round(1E3 * parseFloat("0." + (b[7] || 0))); l.call(a, f, g, h, b)}return a}var c = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/; return function(c, e, f){var g = "", h = [], l, k; e = e || "mediumDate"; e = b.DATETIME_FORMATS[e] || e; I(c) && (c = fg.test(c)?Y(c):a(c)); X(c) && (c = new Date(c)); if (!ca(c) || !isFinite(c.getTime()))return c; for (; e; )(k = gg.exec(e))?(h = cb(h, k, 1), e = h.pop()):(h.push(e), e = null); var n = c.getTimezoneOffset();
        f && (n = vc(f, c.getTimezoneOffset()), c = Ob(c, f, !0)); m(h, function(a){l = hg[a]; g += l?l(c, b.DATETIME_FORMATS, n):a.replace(/(^'|'$)/g, "").replace(/''/g, "'")}); return g}}function ag(){return function(b, a){y(a) && (a = 2); return db(b, a)}}function bg(){return function(b, a, c){a = Infinity === Math.abs(Number(a))?Number(a):Y(a); if (isNaN(a))return b; X(b) && (b = b.toString()); if (!G(b) && !I(b))return b; c = !c || isNaN(c)?0:Y(c); c = 0 > c && c >= - b.length?b.length + c:c; return 0 <= a?b.slice(c, c + a):0 === c?b.slice(a, b.length):b.slice(Math.max(0,
        c + a), c)}}function Bd(b){function a(a, c){c = c? - 1:1; return a.map(function(a){var d = 1, h = Za; if (C(a))h = a;  else if (I(a)){if ("+" == a.charAt(0) || "-" == a.charAt(0))d = "-" == a.charAt(0)? - 1:1, a = a.substring(1); if ("" !== a && (h = b(a), h.constant))var l = h(), h = function(a){return a[l]}}return{get:h, descending:d * c}})}function c(a){switch (typeof a){case "number":case "boolean":case "string":return!0; default:return!1}}return function(b, e, f){if (!Da(b))return b; G(e) || (e = [e]); 0 === e.length && (e = ["+"]); var g = a(e, f); g.push({get:function(){return{}},
        descending:f? - 1:1}); b = Array.prototype.map.call(b, function(a, b){return{value:a, predicateValues:g.map(function(d){var e = d.get(a); d = typeof e; if (null === e)d = "string", e = "null";  else if ("string" === d)e = e.toLowerCase();  else if ("object" === d)a:{if ("function" === typeof e.valueOf && (e = e.valueOf(), c(e)))break a; if (pc(e) && (e = e.toString(), c(e)))break a; e = b}return{value:e, type:d}})}}); b.sort(function(a, b){for (var c = 0, d = 0, e = g.length; d < e; ++d){var c = a.predicateValues[d], f = b.predicateValues[d], u = 0; c.type === f.type?c.value !==
        f.value && (u = c.value < f.value? - 1:1):u = c.type < f.type? - 1:1; if (c = u * g[d].descending)break}return c}); return b = b.map(function(a){return a.value})}}function Ma(b){C(b) && (b = {link:b}); b.restrict = b.restrict || "AC"; return qa(b)}function Gd(b, a, c, d, e){var f = this, g = [], h = f.$$parentForm = b.parent().controller("form") || Ib; f.$error = {}; f.$$success = {}; f.$pending = t; f.$name = e(a.name || a.ngForm || "")(c); f.$dirty = !1; f.$pristine = !0; f.$valid = !0; f.$invalid = !1; f.$submitted = !1; h.$addControl(f); f.$rollbackViewValue = function(){m(g,
        function(a){a.$rollbackViewValue()})}; f.$commitViewValue = function(){m(g, function(a){a.$commitViewValue()})}; f.$addControl = function(a){Ta(a.$name, "input"); g.push(a); a.$name && (f[a.$name] = a)}; f.$$renameControl = function(a, b){var c = a.$name; f[c] === a && delete f[c]; f[b] = a; a.$name = b}; f.$removeControl = function(a){a.$name && f[a.$name] === a && delete f[a.$name]; m(f.$pending, function(b, c){f.$setValidity(c, null, a)}); m(f.$error, function(b, c){f.$setValidity(c, null, a)}); m(f.$$success, function(b, c){f.$setValidity(c, null,
        a)}); bb(g, a)}; Hd({ctrl:this, $element:b, set:function(a, b, c){var d = a[b]; d? - 1 === d.indexOf(c) && d.push(c):a[b] = [c]}, unset:function(a, b, c){var d = a[b]; d && (bb(d, c), 0 === d.length && delete a[b])}, parentForm:h, $animate:d}); f.$setDirty = function(){d.removeClass(b, Xa); d.addClass(b, Jb); f.$dirty = !0; f.$pristine = !1; h.$setDirty()}; f.$setPristine = function(){d.setClass(b, Xa, Jb + " ng-submitted"); f.$dirty = !1; f.$pristine = !0; f.$submitted = !1; m(g, function(a){a.$setPristine()})}; f.$setUntouched = function(){m(g, function(a){a.$setUntouched()})};
        f.$setSubmitted = function(){d.addClass(b, "ng-submitted"); f.$submitted = !0; h.$setSubmitted()}}function ic(b){b.$formatters.push(function(a){return b.$isEmpty(a)?a:a.toString()})}function ib(b, a, c, d, e, f){var g = M(a[0].type); if (!e.android){var h = !1; a.on("compositionstart", function(a){h = !0}); a.on("compositionend", function(){h = !1; l()})}var l = function(b){k && (f.defer.cancel(k), k = null); if (!h){var e = a.val(); b = b && b.type; "password" === g || c.ngTrim && "false" === c.ngTrim || (e = T(e)); (d.$viewValue !== e || "" === e && d.$$hasNativeValidators) &&
        d.$setViewValue(e, b)}}; if (e.hasEvent("input"))a.on("input", l);  else{var k, n = function(a, b, c){k || (k = f.defer(function(){k = null; b && b.value === c || l(a)}))}; a.on("keydown", function(a){var b = a.keyCode; 91 === b || 15 < b && 19 > b || 37 <= b && 40 >= b || n(a, this, this.value)}); if (e.hasEvent("paste"))a.on("paste cut", n)}a.on("change", l); d.$render = function(){var b = d.$isEmpty(d.$viewValue)?"":d.$viewValue; a.val() !== b && a.val(b)}}function Kb(b, a){return function(c, d){var e, f; if (ca(c))return c; if (I(c)){'"' == c.charAt(0) && '"' == c.charAt(c.length -
        1) && (c = c.substring(1, c.length - 1)); if (ig.test(c))return new Date(c); b.lastIndex = 0; if (e = b.exec(c))return e.shift(), f = d?{yyyy:d.getFullYear(), MM:d.getMonth() + 1, dd:d.getDate(), HH:d.getHours(), mm:d.getMinutes(), ss:d.getSeconds(), sss:d.getMilliseconds() / 1E3}:{yyyy:1970, MM:1, dd:1, HH:0, mm:0, ss:0, sss:0}, m(e, function(b, c){c < a.length && (f[a[c]] = + b)}), new Date(f.yyyy, f.MM - 1, f.dd, f.HH, f.mm, f.ss || 0, 1E3 * f.sss || 0)}return NaN}}function jb(b, a, c, d){return function(e, f, g, h, l, k, n){function q(a){return a && !(a.getTime &&
        a.getTime() !== a.getTime())}function r(a){return x(a)?ca(a)?a:c(a):t}Id(e, f, g, h); ib(e, f, g, h, l, k); var u = h && h.$options && h.$options.timezone, m; h.$$parserName = b; h.$parsers.push(function(b){return h.$isEmpty(b)?null:a.test(b)?(b = c(b, m), u && (b = Ob(b, u)), b):t}); h.$formatters.push(function(a){if (a && !ca(a))throw kb("datefmt", a); if (q(a))return(m = a) && u && (m = Ob(m, u, !0)), n("date")(a, d, u); m = null; return""}); if (x(g.min) || g.ngMin){var s; h.$validators.min = function(a){return!q(a) || y(s) || c(a) >= s}; g.$observe("min", function(a){s =
        r(a); h.$validate()})}if (x(g.max) || g.ngMax){var w; h.$validators.max = function(a){return!q(a) || y(w) || c(a) <= w}; g.$observe("max", function(a){w = r(a); h.$validate()})}}}function Id(b, a, c, d){(d.$$hasNativeValidators = D(a[0].validity)) && d.$parsers.push(function(b){var c = a.prop("validity") || {}; return c.badInput && !c.typeMismatch?t:b})}function Jd(b, a, c, d, e){if (x(d)){b = b(d); if (!b.constant)throw kb("constexpr", c, d); return b(a)}return e}function jc(b, a){b = "ngClass" + b; return["$animate", function(c){function d(a, b){var c =
[], d = 0; a:for (; d < a.length; d++){for (var e = a[d], n = 0; n < b.length; n++)if (e == b[n])continue a; c.push(e)}return c}function e(a){var b = []; return G(a)?(m(a, function(a){b = b.concat(e(a))}), b):I(a)?a.split(" "):D(a)?(m(a, function(a, c){a && (b = b.concat(c.split(" ")))}), b):a}return{restrict:"AC", link:function(f, g, h){function l(a, b){var c = g.data("$classCounts") || ga(), d = []; m(a, function(a){if (0 < b || c[a])c[a] = (c[a] || 0) + b, c[a] === + (0 < b) && d.push(a)}); g.data("$classCounts", c); return d.join(" ")}function k(b){if (!0 === a || f.$index %
        2 === a){var k = e(b || []); if (!n){var m = l(k, 1); h.$addClass(m)} else if (!ka(b, n)){var s = e(n), m = d(k, s), k = d(s, k), m = l(m, 1), k = l(k, - 1); m && m.length && c.addClass(g, m); k && k.length && c.removeClass(g, k)}}n = ia(b)}var n; f.$watch(h[b], k, !0); h.$observe("class", function(a){k(f.$eval(h[b]))}); "ngClass" !== b && f.$watch("$index", function(c, d){var g = c & 1; if (g !== (d & 1)){var k = e(f.$eval(h[b])); g === a?(g = l(k, 1), h.$addClass(g)):(g = l(k, - 1), h.$removeClass(g))}})}}}]}function Hd(b){function a(a, b){b && !f[a]?(k.addClass(e, a), f[a] = !0):!b &&
f[a] && (k.removeClass(e, a), f[a] = !1)}function c(b, c){b = b?"-" + zc(b, "-"):""; a(lb + b, !0 === c); a(Kd + b, !1 === c)}var d = b.ctrl, e = b.$element, f = {}, g = b.set, h = b.unset, l = b.parentForm, k = b.$animate; f[Kd] = !(f[lb] = e.hasClass(lb)); d.$setValidity = function(b, e, f){e === t?(d.$pending || (d.$pending = {}), g(d.$pending, b, f)):(d.$pending && h(d.$pending, b, f), Ld(d.$pending) && (d.$pending = t)); ab(e)?e?(h(d.$error, b, f), g(d.$$success, b, f)):(g(d.$error, b, f), h(d.$$success, b, f)):(h(d.$error, b, f), h(d.$$success, b, f)); d.$pending?(a(Md, !0), d.$valid =
        d.$invalid = t, c("", null)):(a(Md, !1), d.$valid = Ld(d.$error), d.$invalid = !d.$valid, c("", d.$valid)); e = d.$pending && d.$pending[b]?t:d.$error[b]?!1:d.$$success[b]?!0:null; c(b, e); l.$setValidity(b, e, d)}}function Ld(b){if (b)for (var a in b)if (b.hasOwnProperty(a))return!1; return!0}var jg = /^\/(.+)\/([a-z]*)$/, M = function(b){return I(b)?b.toLowerCase():b}, Na = Object.prototype.hasOwnProperty, rb = function(b){return I(b)?b.toUpperCase():b}, Va, z, la, xa = [].slice, Mf = [].splice, kg = [].push, sa = Object.prototype.toString, qc = Object.getPrototypeOf,
        Ea = L("ng"), aa = O.angular || (O.angular = {}), Rb, mb = 0; Va = W.documentMode; v.$inject = []; Za.$inject = []; var G = Array.isArray, sc = /^\[object (Uint8(Clamped)?)|(Uint16)|(Uint32)|(Int8)|(Int16)|(Int32)|(Float(32)|(64))Array\]$/, T = function(b){return I(b)?b.trim():b}, ud = function(b){return b.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08")}, Fa = function(){if (!x(Fa.rules)){var b = W.querySelector("[ng-csp]") || W.querySelector("[data-ng-csp]"); if (b){var a = b.getAttribute("ng-csp") || b.getAttribute("data-ng-csp");
        Fa.rules = {noUnsafeEval:!a || - 1 !== a.indexOf("no-unsafe-eval"), noInlineStyle:!a || - 1 !== a.indexOf("no-inline-style")}} else{b = Fa; try{new Function(""), a = !1} catch (c){a = !0}b.rules = {noUnsafeEval:a, noInlineStyle:!1}}}return Fa.rules}, ob = function(){if (x(ob.name_))return ob.name_; var b, a, c = Qa.length, d, e; for (a = 0; a < c; ++a)if (d = Qa[a], b = W.querySelector("[" + d.replace(":", "\\:") + "jq]")){e = b.getAttribute(d + "jq"); break}return ob.name_ = e}, Qa = ["ng-", "data-ng-", "ng:", "x-ng-"], be = /[A-Z]/g, Ac = !1, Qb, pa = 1, Pa = 3, fe = {full:"1.4.4",
        major:1, minor:4, dot:4, codeName:"pylon-requirement"}; R.expando = "ng339"; var gb = R.cache = {}, Ef = 1; R._data = function(b){return this.cache[b[this.expando]] || {}}; var zf = /([\:\-\_]+(.))/g, Af = /^moz([A-Z])/, lg = {mouseleave:"mouseout", mouseenter:"mouseover"}, Tb = L("jqLite"), Df = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, Sb = /<|&#?\w+;/, Bf = /<([\w:]+)/, Cf = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, na = {option:[1, '<select multiple="multiple">', "</select>"], thead:[1, "<table>", "</table>"], col:[2, "<table><colgroup>",
        "</colgroup></table>"], tr:[2, "<table><tbody>", "</tbody></table>"], td:[3, "<table><tbody><tr>", "</tr></tbody></table>"], _default:[0, "", ""]}; na.optgroup = na.option; na.tbody = na.tfoot = na.colgroup = na.caption = na.thead; na.th = na.td; var Ra = R.prototype = {ready:function(b){function a(){c || (c = !0, b())}var c = !1; "complete" === W.readyState?setTimeout(a):(this.on("DOMContentLoaded", a), R(O).on("load", a))}, toString:function(){var b = []; m(this, function(a){b.push("" + a)}); return"[" + b.join(", ") + "]"}, eq:function(b){return 0 <=
        b?z(this[b]):z(this[this.length + b])}, length:0, push:kg, sort:[].sort, splice:[].splice}, Ab = {}; m("multiple selected checked disabled readOnly required open".split(" "), function(b){Ab[M(b)] = b}); var Rc = {}; m("input select option textarea button form details".split(" "), function(b){Rc[b] = !0}); var Sc = {ngMinlength:"minlength", ngMaxlength:"maxlength", ngMin:"min", ngMax:"max", ngPattern:"pattern"}; m({data:Vb, removeData:ub, hasData:function(b){for (var a in gb[b.ng339])return!0; return!1}}, function(b, a){R[a] = b}); m({data:Vb,
        inheritedData:zb, scope:function(b){return z.data(b, "$scope") || zb(b.parentNode || b, ["$isolateScope", "$scope"])}, isolateScope:function(b){return z.data(b, "$isolateScope") || z.data(b, "$isolateScopeNoTemplate")}, controller:Oc, injector:function(b){return zb(b, "$injector")}, removeAttr:function(b, a){b.removeAttribute(a)}, hasClass:wb, css:function(b, a, c){a = fb(a); if (x(c))b.style[a] = c;  else return b.style[a]}, attr:function(b, a, c){var d = b.nodeType; if (d !== Pa && 2 !== d && 8 !== d)if (d = M(a), Ab[d])if (x(c))c?(b[a] = !0, b.setAttribute(a,
        d)):(b[a] = !1, b.removeAttribute(d));  else return b[a] || (b.attributes.getNamedItem(a) || v).specified?d:t;  else if (x(c))b.setAttribute(a, c);  else if (b.getAttribute)return b = b.getAttribute(a, 2), null === b?t:b}, prop:function(b, a, c){if (x(c))b[a] = c;  else return b[a]}, text:function(){function b(a, b){if (y(b)){var d = a.nodeType; return d === pa || d === Pa?a.textContent:""}a.textContent = b}b.$dv = ""; return b}(), val:function(b, a){if (y(a)){if (b.multiple && "select" === ta(b)){var c = []; m(b.options, function(a){a.selected && c.push(a.value ||
        a.text)}); return 0 === c.length?null:c}return b.value}b.value = a}, html:function(b, a){if (y(a))return b.innerHTML; tb(b, !0); b.innerHTML = a}, empty:Pc}, function(b, a){R.prototype[a] = function(a, d){var e, f, g = this.length; if (b !== Pc && (2 == b.length && b !== wb && b !== Oc?a:d) === t){if (D(a)){for (e = 0; e < g; e++)if (b === Vb)b(this[e], a);  else for (f in a)b(this[e], f, a[f]); return this}e = b.$dv; g = e === t?Math.min(g, 1):g; for (f = 0; f < g; f++){var h = b(this[f], a, d); e = e?e + h:h}return e}for (e = 0; e < g; e++)b(this[e], a, d); return this}}); m({removeData:ub,
        on:function a(c, d, e, f){if (x(f))throw Tb("onargs"); if (Kc(c)){var g = vb(c, !0); f = g.events; var h = g.handle; h || (h = g.handle = Hf(c, f)); for (var g = 0 <= d.indexOf(" ")?d.split(" "):[d], l = g.length; l--; ){d = g[l]; var k = f[d]; k || (f[d] = [], "mouseenter" === d || "mouseleave" === d?a(c, lg[d], function(a){var c = a.relatedTarget; c && (c === this || this.contains(c)) || h(a, d)}):"$destroy" !== d && c.addEventListener(d, h, !1), k = f[d]); k.push(e)}}}, off:Nc, one:function(a, c, d){a = z(a); a.on(c, function f(){a.off(c, d); a.off(c, f)}); a.on(c, d)}, replaceWith:function(a,
        c){var d, e = a.parentNode; tb(a); m(new R(c), function(c){d?e.insertBefore(c, d.nextSibling):e.replaceChild(c, a); d = c})}, children:function(a){var c = []; m(a.childNodes, function(a){a.nodeType === pa && c.push(a)}); return c}, contents:function(a){return a.contentDocument || a.childNodes || []}, append:function(a, c){var d = a.nodeType; if (d === pa || 11 === d){c = new R(c); for (var d = 0, e = c.length; d < e; d++)a.appendChild(c[d])}}, prepend:function(a, c){if (a.nodeType === pa){var d = a.firstChild; m(new R(c), function(c){a.insertBefore(c, d)})}},
        wrap:function(a, c){c = z(c).eq(0).clone()[0]; var d = a.parentNode; d && d.replaceChild(c, a); c.appendChild(a)}, remove:Wb, detach:function(a){Wb(a, !0)}, after:function(a, c){var d = a, e = a.parentNode; c = new R(c); for (var f = 0, g = c.length; f < g; f++){var h = c[f]; e.insertBefore(h, d.nextSibling); d = h}}, addClass:yb, removeClass:xb, toggleClass:function(a, c, d){c && m(c.split(" "), function(c){var f = d; y(f) && (f = !wb(a, c)); (f?yb:xb)(a, c)})}, parent:function(a){return(a = a.parentNode) && 11 !== a.nodeType?a:null}, next:function(a){return a.nextElementSibling},
        find:function(a, c){return a.getElementsByTagName?a.getElementsByTagName(c):[]}, clone:Ub, triggerHandler:function(a, c, d){var e, f, g = c.type || c, h = vb(a); if (h = (h = h && h.events) && h[g])e = {preventDefault:function(){this.defaultPrevented = !0}, isDefaultPrevented:function(){return!0 === this.defaultPrevented}, stopImmediatePropagation:function(){this.immediatePropagationStopped = !0}, isImmediatePropagationStopped:function(){return!0 === this.immediatePropagationStopped}, stopPropagation:v, type:g, target:a}, c.type && (e = Q(e,
        c)), c = ia(h), f = d?[e].concat(d):[e], m(c, function(c){e.isImmediatePropagationStopped() || c.apply(a, f)})}}, function(a, c){R.prototype[c] = function(c, e, f){for (var g, h = 0, l = this.length; h < l; h++)y(g)?(g = a(this[h], c, e, f), x(g) && (g = z(g))):Mc(g, a(this[h], c, e, f)); return x(g)?g:this}; R.prototype.bind = R.prototype.on; R.prototype.unbind = R.prototype.off}); Ua.prototype = {put:function(a, c){this[Ga(a, this.nextUid)] = c}, get:function(a){return this[Ga(a, this.nextUid)]}, remove:function(a){var c = this[a = Ga(a, this.nextUid)]; delete this[a];
        return c}}; var xf = [function(){this.$get = [function(){return Ua}]}], Uc = /^[^\(]*\(\s*([^\)]*)\)/m, mg = /,/, ng = /^\s*(_?)(\S+?)\1\s*$/, Tc = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg, Ha = L("$injector"); eb.$$annotate = function(a, c, d){var e; if ("function" === typeof a){if (!(e = a.$inject)){e = []; if (a.length){if (c)throw I(d) && d || (d = a.name || If(a)), Ha("strictdi", d); c = a.toString().replace(Tc, ""); c = c.match(Uc); m(c[1].split(mg), function(a){a.replace(ng, function(a, c, d){e.push(d)})})}a.$inject = e}} else G(a)?(c = a.length - 1, Sa(a[c], "fn"),
        e = a.slice(0, c)):Sa(a, "fn", !0); return e}; var Nd = L("$animate"), Ue = function(){this.$get = ["$q", "$$rAF", function(a, c){function d(){}d.all = v; d.chain = v; d.prototype = {end:v, cancel:v, resume:v, pause:v, complete:v, then:function(d, f){return a(function(a){c(function(){a()})}).then(d, f)}}; return d}]}, Te = function(){var a = new Ua, c = []; this.$get = ["$$AnimateRunner", "$rootScope", function(d, e){function f(d, f, l){var k = a.get(d); k || (a.put(d, k = {}), c.push(d)); d = function(a, c){var d = !1; a && (a = I(a)?a.split(" "):G(a)?a:[], m(a, function(a){a &&
        (d = !0, k[a] = c)})); return d}; f = d(f, !0); l = d(l, !1); !f && !l || 1 < c.length || e.$$postDigest(function(){m(c, function(c){var d = a.get(c); if (d){var e = Jf(c.attr("class")), f = "", g = ""; m(d, function(a, c){a !== !!e[c] && (a?f += (f.length?" ":"") + c:g += (g.length?" ":"") + c)}); m(c, function(a){f && yb(a, f); g && xb(a, g)}); a.remove(c)}}); c.length = 0})}return{enabled:v, on:v, off:v, pin:v, push:function(a, c, e, k){k && k(); e = e || {}; e.from && a.css(e.from); e.to && a.css(e.to); (e.addClass || e.removeClass) && f(a, e.addClass, e.removeClass); return new d}}}]},
        Re = ["$provide", function(a){var c = this; this.$$registeredAnimations = Object.create(null); this.register = function(d, e){if (d && "." !== d.charAt(0))throw Nd("notcsel", d); var f = d + "-animation"; c.$$registeredAnimations[d.substr(1)] = f; a.factory(f, e)}; this.classNameFilter = function(a){if (1 === arguments.length && (this.$$classNameFilter = a instanceof RegExp?a:null) && /(\s+|\/)ng-animate(\s+|\/)/.test(this.$$classNameFilter.toString()))throw Nd("nongcls", "ng-animate"); return this.$$classNameFilter}; this.$get = ["$$animateQueue",
                function(a){function c(a, d, e){if (e){var l; a:{for (l = 0; l < e.length; l++){var k = e[l]; if (1 === k.nodeType){l = k; break a}}l = void 0}!l || l.parentNode || l.previousElementSibling || (e = null)}e?e.after(a):d.prepend(a)}return{on:a.on, off:a.off, pin:a.pin, enabled:a.enabled, cancel:function(a){a.end && a.end()}, enter:function(f, g, h, l){g = g && z(g); h = h && z(h); g = g || h.parent(); c(f, g, h); return a.push(f, "enter", Ia(l))}, move:function(f, g, h, l){g = g && z(g); h = h && z(h); g = g || h.parent(); c(f, g, h); return a.push(f, "move", Ia(l))}, leave:function(c,
                        e){return a.push(c, "leave", Ia(e), function(){c.remove()})}, addClass:function(c, e, h){h = Ia(h); h.addClass = hb(h.addclass, e); return a.push(c, "addClass", h)}, removeClass:function(c, e, h){h = Ia(h); h.removeClass = hb(h.removeClass, e); return a.push(c, "removeClass", h)}, setClass:function(c, e, h, l){l = Ia(l); l.addClass = hb(l.addClass, e); l.removeClass = hb(l.removeClass, h); return a.push(c, "setClass", l)}, animate:function(c, e, h, l, k){k = Ia(k); k.from = k.from?Q(k.from, e):e; k.to = k.to?Q(k.to, h):h; k.tempClasses = hb(k.tempClasses, l ||
                        "ng-inline-animate"); return a.push(c, "animate", k)}}}]}], Se = function(){this.$get = ["$$rAF", "$q", function(a, c){var d = function(){}; d.prototype = {done:function(a){this.defer && this.defer[!0 === a?"reject":"resolve"]()}, end:function(){this.done()}, cancel:function(){this.done(!0)}, getPromise:function(){this.defer || (this.defer = c.defer()); return this.defer.promise}, then:function(a, c){return this.getPromise().then(a, c)}, "catch":function(a){return this.getPromise().catch(a)}, "finally":function(a){return this.getPromise().finally(a)}};
        return function(c, f){function g(){a(function(){f.addClass && (c.addClass(f.addClass), f.addClass = null); f.removeClass && (c.removeClass(f.removeClass), f.removeClass = null); f.to && (c.css(f.to), f.to = null); h || l.done(); h = !0}); return l}f.from && (c.css(f.from), f.from = null); var h, l = new d; return{start:g, end:g}}}]}, ea = L("$compile"); Cc.$inject = ["$provide", "$$sanitizeUriProvider"]; var Xc = /^((?:x|data)[\:\-_])/i, Nf = L("$controller"), Vc = /^(\S+)(\s+as\s+(\w+))?$/, $e = function(){this.$get = ["$document", function(a){return function(c){c?
        !c.nodeType && c instanceof z && (c = c[0]):c = a[0].body; return c.offsetWidth + 1}}]}, bd = "application/json", $b = {"Content-Type":bd + ";charset=utf-8"}, Pf = /^\[|^\{(?!\{)/, Qf = {"[":/]$/, "{":/}$/}, Of = /^\)\]\}',?\n/, og = L("$http"), fd = function(a){return function(){throw og("legacy", a); }}, Ka = aa.$interpolateMinErr = L("$interpolate"); Ka.throwNoconcat = function(a){throw Ka("noconcat", a); }; Ka.interr = function(a, c){return Ka("interr", a, c.toString())}; var pg = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/, Tf = {http:80, https:443, ftp:21}, Db =
        L("$location"), qg = {$$html5:!1, $$replace:!1, absUrl:Eb("$$absUrl"), url:function(a){if (y(a))return this.$$url; var c = pg.exec(a); (c[1] || "" === a) && this.path(decodeURIComponent(c[1])); (c[2] || c[1] || "" === a) && this.search(c[3] || ""); this.hash(c[5] || ""); return this}, protocol:Eb("$$protocol"), host:Eb("$$host"), port:Eb("$$port"), path:kd("$$path", function(a){a = null !== a?a.toString():""; return"/" == a.charAt(0)?a:"/" + a}), search:function(a, c){switch (arguments.length){case 0:return this.$$search; case 1:if (I(a) || X(a))a =
        a.toString(), this.$$search = xc(a);  else if (D(a))a = fa(a, {}), m(a, function(c, e){null == c && delete a[e]}), this.$$search = a;  else throw Db("isrcharg"); break; default:y(c) || null === c?delete this.$$search[a]:this.$$search[a] = c}this.$$compose(); return this}, hash:kd("$$hash", function(a){return null !== a?a.toString():""}), replace:function(){this.$$replace = !0; return this}}; m([jd, cc, bc], function(a){a.prototype = Object.create(qg); a.prototype.state = function(c){if (!arguments.length)return this.$$state; if (a !== bc || !this.$$html5)throw Db("nostate");
        this.$$state = y(c)?null:c; return this}}); var da = L("$parse"), Uf = Function.prototype.call, Vf = Function.prototype.apply, Wf = Function.prototype.bind, Lb = ga(); m("+ - * / % === !== == != < > <= >= && || ! = |".split(" "), function(a){Lb[a] = !0}); var rg = {n:"\n", f:"\f", r:"\r", t:"\t", v:"\v", "'":"'", '"':'"'}, ec = function(a){this.options = a}; ec.prototype = {constructor:ec, lex:function(a){this.text = a; this.index = 0; for (this.tokens = []; this.index < this.text.length; )if (a = this.text.charAt(this.index), '"' === a || "'" === a)this.readString(a);
        else if (this.isNumber(a) || "." === a && this.isNumber(this.peek()))this.readNumber();  else if (this.isIdent(a))this.readIdent();  else if (this.is(a, "(){}[].,;:?"))this.tokens.push({index:this.index, text:a}), this.index++;  else if (this.isWhitespace(a))this.index++;  else{var c = a + this.peek(), d = c + this.peek(2), e = Lb[c], f = Lb[d]; Lb[a] || e || f?(a = f?d:e?c:a, this.tokens.push({index:this.index, text:a, operator:!0}), this.index += a.length):this.throwError("Unexpected next character ", this.index, this.index + 1)}return this.tokens},
        is:function(a, c){return - 1 !== c.indexOf(a)}, peek:function(a){a = a || 1; return this.index + a < this.text.length?this.text.charAt(this.index + a):!1}, isNumber:function(a){return"0" <= a && "9" >= a && "string" === typeof a}, isWhitespace:function(a){return" " === a || "\r" === a || "\t" === a || "\n" === a || "\v" === a || "\u00a0" === a}, isIdent:function(a){return"a" <= a && "z" >= a || "A" <= a && "Z" >= a || "_" === a || "$" === a}, isExpOperator:function(a){return"-" === a || "+" === a || this.isNumber(a)}, throwError:function(a, c, d){d = d || this.index; c = x(c)?"s " + c + "-" +
        this.index + " [" + this.text.substring(c, d) + "]":" " + d; throw da("lexerr", a, c, this.text); }, readNumber:function(){for (var a = "", c = this.index; this.index < this.text.length; ){var d = M(this.text.charAt(this.index)); if ("." == d || this.isNumber(d))a += d;  else{var e = this.peek(); if ("e" == d && this.isExpOperator(e))a += d;  else if (this.isExpOperator(d) && e && this.isNumber(e) && "e" == a.charAt(a.length - 1))a += d;  else if (!this.isExpOperator(d) || e && this.isNumber(e) || "e" != a.charAt(a.length - 1))break;  else this.throwError("Invalid exponent")}this.index++}this.tokens.push({index:c,
        text:a, constant:!0, value:Number(a)})}, readIdent:function(){for (var a = this.index; this.index < this.text.length; ){var c = this.text.charAt(this.index); if (!this.isIdent(c) && !this.isNumber(c))break; this.index++}this.tokens.push({index:a, text:this.text.slice(a, this.index), identifier:!0})}, readString:function(a){var c = this.index; this.index++; for (var d = "", e = a, f = !1; this.index < this.text.length; ){var g = this.text.charAt(this.index), e = e + g; if (f)"u" === g?(f = this.text.substring(this.index + 1, this.index + 5), f.match(/[\da-f]{4}/i) ||
        this.throwError("Invalid unicode escape [\\u" + f + "]"), this.index += 4, d += String.fromCharCode(parseInt(f, 16))):d += rg[g] || g, f = !1;  else if ("\\" === g)f = !0;  else{if (g === a){this.index++; this.tokens.push({index:c, text:e, constant:!0, value:d}); return}d += g}this.index++}this.throwError("Unterminated quote", c)}}; var s = function(a, c){this.lexer = a; this.options = c}; s.Program = "Program"; s.ExpressionStatement = "ExpressionStatement"; s.AssignmentExpression = "AssignmentExpression"; s.ConditionalExpression = "ConditionalExpression";
        s.LogicalExpression = "LogicalExpression"; s.BinaryExpression = "BinaryExpression"; s.UnaryExpression = "UnaryExpression"; s.CallExpression = "CallExpression"; s.MemberExpression = "MemberExpression"; s.Identifier = "Identifier"; s.Literal = "Literal"; s.ArrayExpression = "ArrayExpression"; s.Property = "Property"; s.ObjectExpression = "ObjectExpression"; s.ThisExpression = "ThisExpression"; s.NGValueParameter = "NGValueParameter"; s.prototype = {ast:function(a){this.text = a; this.tokens = this.lexer.lex(a); a = this.program(); 0 !== this.tokens.length &&
                this.throwError("is an unexpected token", this.tokens[0]); return a}, program:function(){for (var a = []; ; )if (0 < this.tokens.length && !this.peek("}", ")", ";", "]") && a.push(this.expressionStatement()), !this.expect(";"))return{type:s.Program, body:a}}, expressionStatement:function(){return{type:s.ExpressionStatement, expression:this.filterChain()}}, filterChain:function(){for (var a = this.expression(); this.expect("|"); )a = this.filter(a); return a}, expression:function(){return this.assignment()}, assignment:function(){var a =
                this.ternary(); this.expect("=") && (a = {type:s.AssignmentExpression, left:a, right:this.assignment(), operator:"="}); return a}, ternary:function(){var a = this.logicalOR(), c, d; return this.expect("?") && (c = this.expression(), this.consume(":"))?(d = this.expression(), {type:s.ConditionalExpression, test:a, alternate:c, consequent:d}):a}, logicalOR:function(){for (var a = this.logicalAND(); this.expect("||"); )a = {type:s.LogicalExpression, operator:"||", left:a, right:this.logicalAND()}; return a}, logicalAND:function(){for (var a =
                this.equality(); this.expect("&&"); )a = {type:s.LogicalExpression, operator:"&&", left:a, right:this.equality()}; return a}, equality:function(){for (var a = this.relational(), c; c = this.expect("==", "!=", "===", "!=="); )a = {type:s.BinaryExpression, operator:c.text, left:a, right:this.relational()}; return a}, relational:function(){for (var a = this.additive(), c; c = this.expect("<", ">", "<=", ">="); )a = {type:s.BinaryExpression, operator:c.text, left:a, right:this.additive()}; return a}, additive:function(){for (var a = this.multiplicative(),
                c; c = this.expect("+", "-"); )a = {type:s.BinaryExpression, operator:c.text, left:a, right:this.multiplicative()}; return a}, multiplicative:function(){for (var a = this.unary(), c; c = this.expect("*", "/", "%"); )a = {type:s.BinaryExpression, operator:c.text, left:a, right:this.unary()}; return a}, unary:function(){var a; return(a = this.expect("+", "-", "!"))?{type:s.UnaryExpression, operator:a.text, prefix:!0, argument:this.unary()}:this.primary()}, primary:function(){var a; this.expect("(")?(a = this.filterChain(), this.consume(")")):
                this.expect("[")?a = this.arrayDeclaration():this.expect("{")?a = this.object():this.constants.hasOwnProperty(this.peek().text)?a = fa(this.constants[this.consume().text]):this.peek().identifier?a = this.identifier():this.peek().constant?a = this.constant():this.throwError("not a primary expression", this.peek()); for (var c; c = this.expect("(", "[", "."); )"(" === c.text?(a = {type:s.CallExpression, callee:a, arguments:this.parseArguments()}, this.consume(")")):"[" === c.text?(a = {type:s.MemberExpression, object:a, property:this.expression(),
                computed:!0}, this.consume("]")):"." === c.text?a = {type:s.MemberExpression, object:a, property:this.identifier(), computed:!1}:this.throwError("IMPOSSIBLE"); return a}, filter:function(a){a = [a]; for (var c = {type:s.CallExpression, callee:this.identifier(), arguments:a, filter:!0}; this.expect(":"); )a.push(this.expression()); return c}, parseArguments:function(){var a = []; if (")" !== this.peekToken().text){do a.push(this.expression()); while (this.expect(","))}return a}, identifier:function(){var a = this.consume(); a.identifier ||
                this.throwError("is not a valid identifier", a); return{type:s.Identifier, name:a.text}}, constant:function(){return{type:s.Literal, value:this.consume().value}}, arrayDeclaration:function(){var a = []; if ("]" !== this.peekToken().text){do{if (this.peek("]"))break; a.push(this.expression())}while (this.expect(","))}this.consume("]"); return{type:s.ArrayExpression, elements:a}}, object:function(){var a = [], c; if ("}" !== this.peekToken().text){do{if (this.peek("}"))break; c = {type:s.Property, kind:"init"}; this.peek().constant?
                c.key = this.constant():this.peek().identifier?c.key = this.identifier():this.throwError("invalid key", this.peek()); this.consume(":"); c.value = this.expression(); a.push(c)}while (this.expect(","))}this.consume("}"); return{type:s.ObjectExpression, properties:a}}, throwError:function(a, c){throw da("syntax", c.text, a, c.index + 1, this.text, this.text.substring(c.index)); }, consume:function(a){if (0 === this.tokens.length)throw da("ueoe", this.text); var c = this.expect(a); c || this.throwError("is unexpected, expecting [" + a +
                "]", this.peek()); return c}, peekToken:function(){if (0 === this.tokens.length)throw da("ueoe", this.text); return this.tokens[0]}, peek:function(a, c, d, e){return this.peekAhead(0, a, c, d, e)}, peekAhead:function(a, c, d, e, f){if (this.tokens.length > a){a = this.tokens[a]; var g = a.text; if (g === c || g === d || g === e || g === f || !(c || d || e || f))return a}return!1}, expect:function(a, c, d, e){return(a = this.peek(a, c, d, e))?(this.tokens.shift(), a):!1}, constants:{"true":{type:s.Literal, value:!0}, "false":{type:s.Literal, value:!1}, "null":{type:s.Literal,
                value:null}, undefined:{type:s.Literal, value:t}, "this":{type:s.ThisExpression}}}; rd.prototype = {compile:function(a, c){var d = this, e = this.astBuilder.ast(a); this.state = {nextId:0, filters:{}, expensiveChecks:c, fn:{vars:[], body:[], own:{}}, assign:{vars:[], body:[], own:{}}, inputs:[]}; U(e, d.$filter); var f = "", g; this.stage = "assign"; if (g = pd(e))this.state.computing = "assign", f = this.nextId(), this.recurse(g, f), f = "fn.assign=" + this.generateFunction("assign", "s,v,l"); g = nd(e.body); d.stage = "inputs"; m(g, function(a, c){var e =
        "fn" + c; d.state[e] = {vars:[], body:[], own:{}}; d.state.computing = e; var f = d.nextId(); d.recurse(a, f); d.return_(f); d.state.inputs.push(e); a.watchId = c}); this.state.computing = "fn"; this.stage = "main"; this.recurse(e); f = '"' + this.USE + " " + this.STRICT + '";\n' + this.filterPrefix() + "var fn=" + this.generateFunction("fn", "s,l,a,i") + f + this.watchFns() + "return fn;"; f = (new Function("$filter", "ensureSafeMemberName", "ensureSafeObject", "ensureSafeFunction", "ifDefined", "plus", "text", f))(this.$filter, Wa, Ba, ld, Xf, md, a); this.state =
        this.stage = t; f.literal = qd(e); f.constant = e.constant; return f}, USE:"use", STRICT:"strict", watchFns:function(){var a = [], c = this.state.inputs, d = this; m(c, function(c){a.push("var " + c + "=" + d.generateFunction(c, "s"))}); c.length && a.push("fn.inputs=[" + c.join(",") + "];"); return a.join("")}, generateFunction:function(a, c){return"function(" + c + "){" + this.varsPrefix(a) + this.body(a) + "};"}, filterPrefix:function(){var a = [], c = this; m(this.state.filters, function(d, e){a.push(d + "=$filter(" + c.escape(e) + ")")}); return a.length?
        "var " + a.join(",") + ";":""}, varsPrefix:function(a){return this.state[a].vars.length?"var " + this.state[a].vars.join(",") + ";":""}, body:function(a){return this.state[a].body.join("")}, recurse:function(a, c, d, e, f, g){var h, l, k = this, n, q; e = e || v; if (!g && x(a.watchId))c = c || this.nextId(), this.if_("i", this.lazyAssign(c, this.computedMember("i", a.watchId)), this.lazyRecurse(a, c, d, e, f, !0));  else switch (a.type){case s.Program:m(a.body, function(c, d){k.recurse(c.expression, t, t, function(a){l = a}); d !== a.body.length - 1?k.current().body.push(l,
        ";"):k.return_(l)}); break; case s.Literal:q = this.escape(a.value); this.assign(c, q); e(q); break; case s.UnaryExpression:this.recurse(a.argument, t, t, function(a){l = a}); q = a.operator + "(" + this.ifDefined(l, 0) + ")"; this.assign(c, q); e(q); break; case s.BinaryExpression:this.recurse(a.left, t, t, function(a){h = a}); this.recurse(a.right, t, t, function(a){l = a}); q = "+" === a.operator?this.plus(h, l):"-" === a.operator?this.ifDefined(h, 0) + a.operator + this.ifDefined(l, 0):"(" + h + ")" + a.operator + "(" + l + ")"; this.assign(c, q); e(q); break; case s.LogicalExpression:c =
        c || this.nextId(); k.recurse(a.left, c); k.if_("&&" === a.operator?c:k.not(c), k.lazyRecurse(a.right, c)); e(c); break; case s.ConditionalExpression:c = c || this.nextId(); k.recurse(a.test, c); k.if_(c, k.lazyRecurse(a.alternate, c), k.lazyRecurse(a.consequent, c)); e(c); break; case s.Identifier:c = c || this.nextId(); d && (d.context = "inputs" === k.stage?"s":this.assign(this.nextId(), this.getHasOwnProperty("l", a.name) + "?l:s"), d.computed = !1, d.name = a.name); Wa(a.name); k.if_("inputs" === k.stage || k.not(k.getHasOwnProperty("l", a.name)),
        function(){k.if_("inputs" === k.stage || "s", function(){f && 1 !== f && k.if_(k.not(k.nonComputedMember("s", a.name)), k.lazyAssign(k.nonComputedMember("s", a.name), "{}")); k.assign(c, k.nonComputedMember("s", a.name))})}, c && k.lazyAssign(c, k.nonComputedMember("l", a.name))); (k.state.expensiveChecks || Fb(a.name)) && k.addEnsureSafeObject(c); e(c); break; case s.MemberExpression:h = d && (d.context = this.nextId()) || this.nextId(); c = c || this.nextId(); k.recurse(a.object, h, t, function(){k.if_(k.notNull(h), function(){if (a.computed)l =
        k.nextId(), k.recurse(a.property, l), k.addEnsureSafeMemberName(l), f && 1 !== f && k.if_(k.not(k.computedMember(h, l)), k.lazyAssign(k.computedMember(h, l), "{}")), q = k.ensureSafeObject(k.computedMember(h, l)), k.assign(c, q), d && (d.computed = !0, d.name = l);  else{Wa(a.property.name); f && 1 !== f && k.if_(k.not(k.nonComputedMember(h, a.property.name)), k.lazyAssign(k.nonComputedMember(h, a.property.name), "{}")); q = k.nonComputedMember(h, a.property.name); if (k.state.expensiveChecks || Fb(a.property.name))q = k.ensureSafeObject(q); k.assign(c,
        q); d && (d.computed = !1, d.name = a.property.name)}}, function(){k.assign(c, "undefined")}); e(c)}, !!f); break; case s.CallExpression:c = c || this.nextId(); a.filter?(l = k.filter(a.callee.name), n = [], m(a.arguments, function(a){var c = k.nextId(); k.recurse(a, c); n.push(c)}), q = l + "(" + n.join(",") + ")", k.assign(c, q), e(c)):(l = k.nextId(), h = {}, n = [], k.recurse(a.callee, l, h, function(){k.if_(k.notNull(l), function(){k.addEnsureSafeFunction(l); m(a.arguments, function(a){k.recurse(a, k.nextId(), t, function(a){n.push(k.ensureSafeObject(a))})});
        h.name?(k.state.expensiveChecks || k.addEnsureSafeObject(h.context), q = k.member(h.context, h.name, h.computed) + "(" + n.join(",") + ")"):q = l + "(" + n.join(",") + ")"; q = k.ensureSafeObject(q); k.assign(c, q)}, function(){k.assign(c, "undefined")}); e(c)})); break; case s.AssignmentExpression:l = this.nextId(); h = {}; if (!od(a.left))throw da("lval"); this.recurse(a.left, t, h, function(){k.if_(k.notNull(h.context), function(){k.recurse(a.right, l); k.addEnsureSafeObject(k.member(h.context, h.name, h.computed)); q = k.member(h.context, h.name,
        h.computed) + a.operator + l; k.assign(c, q); e(c || q)})}, 1); break; case s.ArrayExpression:n = []; m(a.elements, function(a){k.recurse(a, k.nextId(), t, function(a){n.push(a)})}); q = "[" + n.join(",") + "]"; this.assign(c, q); e(q); break; case s.ObjectExpression:n = []; m(a.properties, function(a){k.recurse(a.value, k.nextId(), t, function(c){n.push(k.escape(a.key.type === s.Identifier?a.key.name:"" + a.key.value) + ":" + c)})}); q = "{" + n.join(",") + "}"; this.assign(c, q); e(q); break; case s.ThisExpression:this.assign(c, "s"); e("s"); break; case s.NGValueParameter:this.assign(c,
        "v"), e("v")}}, getHasOwnProperty:function(a, c){var d = a + "." + c, e = this.current().own; e.hasOwnProperty(d) || (e[d] = this.nextId(!1, a + "&&(" + this.escape(c) + " in " + a + ")")); return e[d]}, assign:function(a, c){if (a)return this.current().body.push(a, "=", c, ";"), a}, filter:function(a){this.state.filters.hasOwnProperty(a) || (this.state.filters[a] = this.nextId(!0)); return this.state.filters[a]}, ifDefined:function(a, c){return"ifDefined(" + a + "," + this.escape(c) + ")"}, plus:function(a, c){return"plus(" + a + "," + c + ")"}, return_:function(a){this.current().body.push("return ",
        a, ";")}, if_:function(a, c, d){if (!0 === a)c();  else{var e = this.current().body; e.push("if(", a, "){"); c(); e.push("}"); d && (e.push("else{"), d(), e.push("}"))}}, not:function(a){return"!(" + a + ")"}, notNull:function(a){return a + "!=null"}, nonComputedMember:function(a, c){return a + "." + c}, computedMember:function(a, c){return a + "[" + c + "]"}, member:function(a, c, d){return d?this.computedMember(a, c):this.nonComputedMember(a, c)}, addEnsureSafeObject:function(a){this.current().body.push(this.ensureSafeObject(a), ";")}, addEnsureSafeMemberName:function(a){this.current().body.push(this.ensureSafeMemberName(a),
        ";")}, addEnsureSafeFunction:function(a){this.current().body.push(this.ensureSafeFunction(a), ";")}, ensureSafeObject:function(a){return"ensureSafeObject(" + a + ",text)"}, ensureSafeMemberName:function(a){return"ensureSafeMemberName(" + a + ",text)"}, ensureSafeFunction:function(a){return"ensureSafeFunction(" + a + ",text)"}, lazyRecurse:function(a, c, d, e, f, g){var h = this; return function(){h.recurse(a, c, d, e, f, g)}}, lazyAssign:function(a, c){var d = this; return function(){d.assign(a, c)}}, stringEscapeRegex:/[^ a-zA-Z0-9]/g,
        stringEscapeFn:function(a){return"\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice( - 4)}, escape:function(a){if (I(a))return"'" + a.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'"; if (X(a))return a.toString(); if (!0 === a)return"true"; if (!1 === a)return"false"; if (null === a)return"null"; if ("undefined" === typeof a)return"undefined"; throw da("esc"); }, nextId:function(a, c){var d = "v" + this.state.nextId++; a || this.current().vars.push(d + (c?"=" + c:"")); return d}, current:function(){return this.state[this.state.computing]}};
        sd.prototype = {compile:function(a, c){var d = this, e = this.astBuilder.ast(a); this.expression = a; this.expensiveChecks = c; U(e, d.$filter); var f, g; if (f = pd(e))g = this.recurse(f); f = nd(e.body); var h; f && (h = [], m(f, function(a, c){var e = d.recurse(a); a.input = e; h.push(e); a.watchId = c})); var l = []; m(e.body, function(a){l.push(d.recurse(a.expression))}); f = 0 === e.body.length?function(){}:1 === e.body.length?l[0]:function(a, c){var d; m(l, function(e){d = e(a, c)}); return d}; g && (f.assign = function(a, c, d){return g(a, d, c)}); h && (f.inputs =
                h); f.literal = qd(e); f.constant = e.constant; return f}, recurse:function(a, c, d){var e, f, g = this, h; if (a.input)return this.inputs(a.input, a.watchId); switch (a.type){case s.Literal:return this.value(a.value, c); case s.UnaryExpression:return f = this.recurse(a.argument), this["unary" + a.operator](f, c); case s.BinaryExpression:return e = this.recurse(a.left), f = this.recurse(a.right), this["binary" + a.operator](e, f, c); case s.LogicalExpression:return e = this.recurse(a.left), f = this.recurse(a.right), this["binary" + a.operator](e,
                f, c); case s.ConditionalExpression:return this["ternary?:"](this.recurse(a.test), this.recurse(a.alternate), this.recurse(a.consequent), c); case s.Identifier:return Wa(a.name, g.expression), g.identifier(a.name, g.expensiveChecks || Fb(a.name), c, d, g.expression); case s.MemberExpression:return e = this.recurse(a.object, !1, !!d), a.computed || (Wa(a.property.name, g.expression), f = a.property.name), a.computed && (f = this.recurse(a.property)), a.computed?this.computedMember(e, f, c, d, g.expression):this.nonComputedMember(e, f,
                g.expensiveChecks, c, d, g.expression); case s.CallExpression:return h = [], m(a.arguments, function(a){h.push(g.recurse(a))}), a.filter && (f = this.$filter(a.callee.name)), a.filter || (f = this.recurse(a.callee, !0)), a.filter?function(a, d, e, g){for (var r = [], m = 0; m < h.length; ++m)r.push(h[m](a, d, e, g)); a = f.apply(t, r, g); return c?{context:t, name:t, value:a}:a}:function(a, d, e, q){var r = f(a, d, e, q), m; if (null != r.value){Ba(r.context, g.expression); ld(r.value, g.expression); m = []; for (var s = 0; s < h.length; ++s)m.push(Ba(h[s](a, d, e, q),
                g.expression)); m = Ba(r.value.apply(r.context, m), g.expression)}return c?{value:m}:m}; case s.AssignmentExpression:return e = this.recurse(a.left, !0, 1), f = this.recurse(a.right), function(a, d, h, q){var m = e(a, d, h, q); a = f(a, d, h, q); Ba(m.value, g.expression); m.context[m.name] = a; return c?{value:a}:a}; case s.ArrayExpression:return h = [], m(a.elements, function(a){h.push(g.recurse(a))}), function(a, d, e, f){for (var g = [], m = 0; m < h.length; ++m)g.push(h[m](a, d, e, f)); return c?{value:g}:g}; case s.ObjectExpression:return h = [], m(a.properties,
                function(a){h.push({key:a.key.type === s.Identifier?a.key.name:"" + a.key.value, value:g.recurse(a.value)})}), function(a, d, e, f){for (var g = {}, m = 0; m < h.length; ++m)g[h[m].key] = h[m].value(a, d, e, f); return c?{value:g}:g}; case s.ThisExpression:return function(a){return c?{value:a}:a}; case s.NGValueParameter:return function(a, d, e, f){return c?{value:e}:e}}}, "unary+":function(a, c){return function(d, e, f, g){d = a(d, e, f, g); d = x(d)? + d:0; return c?{value:d}:d}}, "unary-":function(a, c){return function(d, e, f, g){d = a(d, e, f, g);
                d = x(d)? - d:0; return c?{value:d}:d}}, "unary!":function(a, c){return function(d, e, f, g){d = !a(d, e, f, g); return c?{value:d}:d}}, "binary+":function(a, c, d){return function(e, f, g, h){var l = a(e, f, g, h); e = c(e, f, g, h); l = md(l, e); return d?{value:l}:l}}, "binary-":function(a, c, d){return function(e, f, g, h){var l = a(e, f, g, h); e = c(e, f, g, h); l = (x(l)?l:0) - (x(e)?e:0); return d?{value:l}:l}}, "binary*":function(a, c, d){return function(e, f, g, h){e = a(e, f, g, h) * c(e, f, g, h); return d?{value:e}:e}}, "binary/":function(a, c, d){return function(e,
                f, g, h){e = a(e, f, g, h) / c(e, f, g, h); return d?{value:e}:e}}, "binary%":function(a, c, d){return function(e, f, g, h){e = a(e, f, g, h) % c(e, f, g, h); return d?{value:e}:e}}, "binary===":function(a, c, d){return function(e, f, g, h){e = a(e, f, g, h) === c(e, f, g, h); return d?{value:e}:e}}, "binary!==":function(a, c, d){return function(e, f, g, h){e = a(e, f, g, h) !== c(e, f, g, h); return d?{value:e}:e}}, "binary==":function(a, c, d){return function(e, f, g, h){e = a(e, f, g, h) == c(e, f, g, h); return d?{value:e}:e}}, "binary!=":function(a, c, d){return function(e,
                f, g, h){e = a(e, f, g, h) != c(e, f, g, h); return d?{value:e}:e}}, "binary<":function(a, c, d){return function(e, f, g, h){e = a(e, f, g, h) < c(e, f, g, h); return d?{value:e}:e}}, "binary>":function(a, c, d){return function(e, f, g, h){e = a(e, f, g, h) > c(e, f, g, h); return d?{value:e}:e}}, "binary<=":function(a, c, d){return function(e, f, g, h){e = a(e, f, g, h) <= c(e, f, g, h); return d?{value:e}:e}}, "binary>=":function(a, c, d){return function(e, f, g, h){e = a(e, f, g, h) >= c(e, f, g, h); return d?{value:e}:e}}, "binary&&":function(a, c, d){return function(e, f, g, h){e =
                a(e, f, g, h) && c(e, f, g, h); return d?{value:e}:e}}, "binary||":function(a, c, d){return function(e, f, g, h){e = a(e, f, g, h) || c(e, f, g, h); return d?{value:e}:e}}, "ternary?:":function(a, c, d, e){return function(f, g, h, l){f = a(f, g, h, l)?c(f, g, h, l):d(f, g, h, l); return e?{value:f}:f}}, value:function(a, c){return function(){return c?{context:t, name:t, value:a}:a}}, identifier:function(a, c, d, e, f){return function(g, h, l, k){g = h && a in h?h:g; e && 1 !== e && g && !g[a] && (g[a] = {}); h = g?g[a]:t; c && Ba(h, f); return d?{context:g, name:a, value:h}:h}},
                computedMember:function(a, c, d, e, f){return function(g, h, l, k){var n = a(g, h, l, k), q, m; null != n && (q = c(g, h, l, k), Wa(q, f), e && 1 !== e && n && !n[q] && (n[q] = {}), m = n[q], Ba(m, f)); return d?{context:n, name:q, value:m}:m}}, nonComputedMember:function(a, c, d, e, f, g){return function(h, l, k, n){h = a(h, l, k, n); f && 1 !== f && h && !h[c] && (h[c] = {}); l = null != h?h[c]:t; (d || Fb(c)) && Ba(l, g); return e?{context:h, name:c, value:l}:l}}, inputs:function(a, c){return function(d, e, f, g){return g?g[c]:a(d, e, f)}}}; var fc = function(a, c, d){this.lexer = a; this.$filter =
        c; this.options = d; this.ast = new s(this.lexer); this.astCompiler = d.csp?new sd(this.ast, c):new rd(this.ast, c)}; fc.prototype = {constructor:fc, parse:function(a){return this.astCompiler.compile(a, this.options.expensiveChecks)}}; ga(); ga(); var Yf = Object.prototype.valueOf, Ca = L("$sce"), oa = {HTML:"html", CSS:"css", URL:"url", RESOURCE_URL:"resourceUrl", JS:"js"}, ea = L("$compile"), Z = W.createElement("a"), wd = Aa(O.location.href); xd.$inject = ["$document"]; Jc.$inject = ["$provide"]; yd.$inject = ["$locale"]; Ad.$inject = ["$locale"];
        var Dd = ".", hg = {yyyy:$("FullYear", 4), yy:$("FullYear", 2, 0, !0), y:$("FullYear", 1), MMMM:Hb("Month"), MMM:Hb("Month", !0), MM:$("Month", 2, 1), M:$("Month", 1, 1), dd:$("Date", 2), d:$("Date", 1), HH:$("Hours", 2), H:$("Hours", 1), hh:$("Hours", 2, - 12), h:$("Hours", 1, - 12), mm:$("Minutes", 2), m:$("Minutes", 1), ss:$("Seconds", 2), s:$("Seconds", 1), sss:$("Milliseconds", 3), EEEE:Hb("Day"), EEE:Hb("Day", !0), a:function(a, c){return 12 > a.getHours()?c.AMPMS[0]:c.AMPMS[1]}, Z:function(a, c, d){a = - 1 * d; return a = (0 <= a?"+":"") + (Gb(Math[0 < a?"floor":
                "ceil"](a / 60), 2) + Gb(Math.abs(a % 60), 2))}, ww:Fd(2), w:Fd(1), G:hc, GG:hc, GGG:hc, GGGG:function(a, c){return 0 >= a.getFullYear()?c.ERANAMES[0]:c.ERANAMES[1]}}, gg = /((?:[^yMdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/, fg = /^\-?\d+$/; zd.$inject = ["$locale"]; var cg = qa(M), dg = qa(rb); Bd.$inject = ["$parse"]; var he = qa({restrict:"E", compile:function(a, c){if (!c.href && !c.xlinkHref)return function(a, c){if ("a" === c[0].nodeName.toLowerCase()){var f = "[object SVGAnimatedString]" === sa.call(c.prop("href"))?
        "xlink:href":"href"; c.on("click", function(a){c.attr(f) || a.preventDefault()})}}}}), sb = {}; m(Ab, function(a, c){function d(a, d, f){a.$watch(f[e], function(a){f.$set(c, !!a)})}if ("multiple" != a){var e = va("ng-" + c), f = d; "checked" === a && (f = function(a, c, f){f.ngModel !== f[e] && d(a, c, f)}); sb[e] = function(){return{restrict:"A", priority:100, link:f}}}}); m(Sc, function(a, c){sb[c] = function(){return{priority:100, link:function(a, e, f){if ("ngPattern" === c && "/" == f.ngPattern.charAt(0) && (e = f.ngPattern.match(jg))){f.$set("ngPattern",
        new RegExp(e[1], e[2])); return}a.$watch(f[c], function(a){f.$set(c, a)})}}}}); m(["src", "srcset", "href"], function(a){var c = va("ng-" + a); sb[c] = function(){return{priority:99, link:function(d, e, f){var g = a, h = a; "href" === a && "[object SVGAnimatedString]" === sa.call(e.prop("href")) && (h = "xlinkHref", f.$attr[h] = "xlink:href", g = null); f.$observe(c, function(c){c?(f.$set(h, c), Va && g && e.prop(g, f[h])):"href" === a && f.$set(h, null)})}}}}); var Ib = {$addControl:v, $$renameControl:function(a, c){a.$name = c}, $removeControl:v, $setValidity:v,
        $setDirty:v, $setPristine:v, $setSubmitted:v}; Gd.$inject = ["$element", "$attrs", "$scope", "$animate", "$interpolate"]; var Od = function(a){return["$timeout", "$parse", function(c, d){function e(a){return"" === a?d('this[""]').assign:d(a).assign || v}return{name:"form", restrict:a?"EAC":"E", controller:Gd, compile:function(d, g){d.addClass(Xa).addClass(lb); var h = g.name?"name":a && g.ngForm?"ngForm":!1; return{pre:function(a, d, f, g){if (!("action"in f)){var m = function(c){a.$apply(function(){g.$commitViewValue(); g.$setSubmitted()});
        c.preventDefault()}; d[0].addEventListener("submit", m, !1); d.on("$destroy", function(){c(function(){d[0].removeEventListener("submit", m, !1)}, 0, !1)})}var s = g.$$parentForm, B = h?e(g.$name):v; h && (B(a, g), f.$observe(h, function(c){g.$name !== c && (B(a, t), s.$$renameControl(g, c), B = e(g.$name), B(a, g))})); d.on("$destroy", function(){s.$removeControl(g); B(a, t); Q(g, Ib)})}}}}}]}, ie = Od(), ve = Od(!0), ig = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/, sg = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/,
        tg = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i, ug = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/, Pd = /^(\d{4})-(\d{2})-(\d{2})$/, Qd = /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, kc = /^(\d{4})-W(\d\d)$/, Rd = /^(\d{4})-(\d\d)$/, Sd = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, Td = {text:function(a, c, d, e, f, g){ib(a, c, d, e, f, g); ic(e)}, date:jb("date", Pd, Kb(Pd, ["yyyy", "MM", "dd"]), "yyyy-MM-dd"), "datetime-local":jb("datetimelocal", Qd, Kb(Qd,
                "yyyy MM dd HH mm ss sss".split(" ")), "yyyy-MM-ddTHH:mm:ss.sss"), time:jb("time", Sd, Kb(Sd, ["HH", "mm", "ss", "sss"]), "HH:mm:ss.sss"), week:jb("week", kc, function(a, c){if (ca(a))return a; if (I(a)){kc.lastIndex = 0; var d = kc.exec(a); if (d){var e = + d[1], f = + d[2], g = d = 0, h = 0, l = 0, k = Ed(e), f = 7 * (f - 1); c && (d = c.getHours(), g = c.getMinutes(), h = c.getSeconds(), l = c.getMilliseconds()); return new Date(e, 0, k.getDate() + f, d, g, h, l)}}return NaN}, "yyyy-Www"), month:jb("month", Rd, Kb(Rd, ["yyyy", "MM"]), "yyyy-MM"), number:function(a, c, d, e, f, g){Id(a,
                c, d, e); ib(a, c, d, e, f, g); e.$$parserName = "number"; e.$parsers.push(function(a){return e.$isEmpty(a)?null:ug.test(a)?parseFloat(a):t}); e.$formatters.push(function(a){if (!e.$isEmpty(a)){if (!X(a))throw kb("numfmt", a); a = a.toString()}return a}); if (x(d.min) || d.ngMin){var h; e.$validators.min = function(a){return e.$isEmpty(a) || y(h) || a >= h}; d.$observe("min", function(a){x(a) && !X(a) && (a = parseFloat(a, 10)); h = X(a) && !isNaN(a)?a:t; e.$validate()})}if (x(d.max) || d.ngMax){var l; e.$validators.max = function(a){return e.$isEmpty(a) ||
                y(l) || a <= l}; d.$observe("max", function(a){x(a) && !X(a) && (a = parseFloat(a, 10)); l = X(a) && !isNaN(a)?a:t; e.$validate()})}}, url:function(a, c, d, e, f, g){ib(a, c, d, e, f, g); ic(e); e.$$parserName = "url"; e.$validators.url = function(a, c){var d = a || c; return e.$isEmpty(d) || sg.test(d)}}, email:function(a, c, d, e, f, g){ib(a, c, d, e, f, g); ic(e); e.$$parserName = "email"; e.$validators.email = function(a, c){var d = a || c; return e.$isEmpty(d) || tg.test(d)}}, radio:function(a, c, d, e){y(d.name) && c.attr("name", ++mb); c.on("click", function(a){c[0].checked &&
                e.$setViewValue(d.value, a && a.type)}); e.$render = function(){c[0].checked = d.value == e.$viewValue}; d.$observe("value", e.$render)}, checkbox:function(a, c, d, e, f, g, h, l){var k = Jd(l, a, "ngTrueValue", d.ngTrueValue, !0), n = Jd(l, a, "ngFalseValue", d.ngFalseValue, !1); c.on("click", function(a){e.$setViewValue(c[0].checked, a && a.type)}); e.$render = function(){c[0].checked = e.$viewValue}; e.$isEmpty = function(a){return!1 === a}; e.$formatters.push(function(a){return ka(a, k)}); e.$parsers.push(function(a){return a?k:n})}, hidden:v,
                button:v, submit:v, reset:v, file:v}, Dc = ["$browser", "$sniffer", "$filter", "$parse", function(a, c, d, e){return{restrict:"E", require:["?ngModel"], link:{pre:function(f, g, h, l){l[0] && (Td[M(h.type)] || Td.text)(f, g, h, l[0], c, a, d, e)}}}}], vg = /^(true|false|\d+)$/, Ne = function(){return{restrict:"A", priority:100, compile:function(a, c){return vg.test(c.ngValue)?function(a, c, f){f.$set("value", a.$eval(f.ngValue))}:function(a, c, f){a.$watch(f.ngValue, function(a){f.$set("value", a)})}}}}, ne = ["$compile", function(a){return{restrict:"AC",
        compile:function(c){a.$$addBindingClass(c); return function(c, e, f){a.$$addBindingInfo(e, f.ngBind); e = e[0]; c.$watch(f.ngBind, function(a){e.textContent = a === t?"":a})}}}}], pe = ["$interpolate", "$compile", function(a, c){return{compile:function(d){c.$$addBindingClass(d); return function(d, f, g){d = a(f.attr(g.$attr.ngBindTemplate)); c.$$addBindingInfo(f, d.expressions); f = f[0]; g.$observe("ngBindTemplate", function(a){f.textContent = a === t?"":a})}}}}], oe = ["$sce", "$parse", "$compile", function(a, c, d){return{restrict:"A",
        compile:function(e, f){var g = c(f.ngBindHtml), h = c(f.ngBindHtml, function(a){return(a || "").toString()}); d.$$addBindingClass(e); return function(c, e, f){d.$$addBindingInfo(e, f.ngBindHtml); c.$watch(h, function(){e.html(a.getTrustedHtml(g(c)) || "")})}}}}], Me = qa({restrict:"A", require:"ngModel", link:function(a, c, d, e){e.$viewChangeListeners.push(function(){a.$eval(d.ngChange)})}}), qe = jc("", !0), se = jc("Odd", 0), re = jc("Even", 1), te = Ma({compile:function(a, c){c.$set("ngCloak", t); a.removeClass("ng-cloak")}}), ue = [function(){return{restrict:"A",
        scope:!0, controller:"@", priority:500}}], Ic = {}, wg = {blur:!0, focus:!0}; m("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function(a){var c = va("ng-" + a); Ic[c] = ["$parse", "$rootScope", function(d, e){return{restrict:"A", compile:function(f, g){var h = d(g[c], null, !0); return function(c, d){d.on(a, function(d){var f = function(){h(c, {$event:d})}; wg[a] && e.$$phase?c.$evalAsync(f):c.$apply(f)})}}}}]}); var xe = ["$animate",
        function(a){return{multiElement:!0, transclude:"element", priority:600, terminal:!0, restrict:"A", $$tlb:!0, link:function(c, d, e, f, g){var h, l, k; c.$watch(e.ngIf, function(c){c?l || g(function(c, f){l = f; c[c.length++] = W.createComment(" end ngIf: " + e.ngIf + " "); h = {clone:c}; a.enter(c, d.parent(), d)}):(k && (k.remove(), k = null), l && (l.$destroy(), l = null), h && (k = qb(h.clone), a.leave(k).then(function(){k = null}), h = null))})}}}], ye = ["$templateRequest", "$anchorScroll", "$animate", function(a, c, d){return{restrict:"ECA", priority:400,
        terminal:!0, transclude:"element", controller:aa.noop, compile:function(e, f){var g = f.ngInclude || f.src, h = f.onload || "", l = f.autoscroll; return function(e, f, m, r, s){var t = 0, v, w, p, A = function(){w && (w.remove(), w = null); v && (v.$destroy(), v = null); p && (d.leave(p).then(function(){w = null}), w = p, p = null)}; e.$watch(g, function(g){var m = function(){!x(l) || l && !e.$eval(l) || c()}, q = ++t; g?(a(g, !0).then(function(a){if (q === t){var c = e.$new(); r.template = a; a = s(c, function(a){A(); d.enter(a, null, f).then(m)}); v = c; p = a; v.$emit("$includeContentLoaded",
                g); e.$eval(h)}}, function(){q === t && (A(), e.$emit("$includeContentError", g))}), e.$emit("$includeContentRequested", g)):(A(), r.template = null)})}}}}], Pe = ["$compile", function(a){return{restrict:"ECA", priority: - 400, require:"ngInclude", link:function(c, d, e, f){/SVG/.test(d[0].toString())?(d.empty(), a(Lc(f.template, W).childNodes)(c, function(a){d.append(a)}, {futureParentElement:d})):(d.html(f.template), a(d.contents())(c))}}}], ze = Ma({priority:450, compile:function(){return{pre:function(a, c, d){a.$eval(d.ngInit)}}}}),
        Le = function(){return{restrict:"A", priority:100, require:"ngModel", link:function(a, c, d, e){var f = c.attr(d.$attr.ngList) || ", ", g = "false" !== d.ngTrim, h = g?T(f):f; e.$parsers.push(function(a){if (!y(a)){var c = []; a && m(a.split(h), function(a){a && c.push(g?T(a):a)}); return c}}); e.$formatters.push(function(a){return G(a)?a.join(f):t}); e.$isEmpty = function(a){return!a || !a.length}}}}, lb = "ng-valid", Kd = "ng-invalid", Xa = "ng-pristine", Jb = "ng-dirty", Md = "ng-pending", kb = L("ngModel"), xg = ["$scope", "$exceptionHandler", "$attrs",
        "$element", "$parse", "$animate", "$timeout", "$rootScope", "$q", "$interpolate", function(a, c, d, e, f, g, h, l, k, n){this.$modelValue = this.$viewValue = Number.NaN; this.$$rawModelValue = t; this.$validators = {}; this.$asyncValidators = {}; this.$parsers = []; this.$formatters = []; this.$viewChangeListeners = []; this.$untouched = !0; this.$touched = !1; this.$pristine = !0; this.$dirty = !1; this.$valid = !0; this.$invalid = !1; this.$error = {}; this.$$success = {}; this.$pending = t; this.$name = n(d.name || "", !1)(a); var q = f(d.ngModel), r = q.assign, s = q, B = r,
                K = null, w, p = this; this.$$setOptions = function(a){if ((p.$options = a) && a.getterSetter){var c = f(d.ngModel + "()"), g = f(d.ngModel + "($$$p)"); s = function(a){var d = q(a); C(d) && (d = c(a)); return d}; B = function(a, c){C(q(a))?g(a, {$$$p:p.$modelValue}):r(a, p.$modelValue)}} else if (!q.assign)throw kb("nonassign", d.ngModel, ua(e)); }; this.$render = v; this.$isEmpty = function(a){return y(a) || "" === a || null === a || a !== a}; var A = e.inheritedData("$formController") || Ib, z = 0; Hd({ctrl:this, $element:e, set:function(a, c){a[c] = !0}, unset:function(a,
                c){delete a[c]}, parentForm:A, $animate:g}); this.$setPristine = function(){p.$dirty = !1; p.$pristine = !0; g.removeClass(e, Jb); g.addClass(e, Xa)}; this.$setDirty = function(){p.$dirty = !0; p.$pristine = !1; g.removeClass(e, Xa); g.addClass(e, Jb); A.$setDirty()}; this.$setUntouched = function(){p.$touched = !1; p.$untouched = !0; g.setClass(e, "ng-untouched", "ng-touched")}; this.$setTouched = function(){p.$touched = !0; p.$untouched = !1; g.setClass(e, "ng-touched", "ng-untouched")}; this.$rollbackViewValue = function(){h.cancel(K); p.$viewValue =
                p.$$lastCommittedViewValue; p.$render()}; this.$validate = function(){if (!X(p.$modelValue) || !isNaN(p.$modelValue)){var a = p.$$rawModelValue, c = p.$valid, d = p.$modelValue, e = p.$options && p.$options.allowInvalid; p.$$runValidators(a, p.$$lastCommittedViewValue, function(f){e || c === f || (p.$modelValue = f?a:t, p.$modelValue !== d && p.$$writeModelToScope())})}}; this.$$runValidators = function(a, c, d){function e(){var d = !0; m(p.$validators, function(e, f){var h = e(a, c); d = d && h; g(f, h)}); return d?!0:(m(p.$asyncValidators, function(a,
                c){g(c, null)}), !1)}function f(){var d = [], e = !0; m(p.$asyncValidators, function(f, h){var k = f(a, c); if (!k || !C(k.then))throw kb("$asyncValidators", k); g(h, t); d.push(k.then(function(){g(h, !0)}, function(a){e = !1; g(h, !1)}))}); d.length?k.all(d).then(function(){h(e)}, v):h(!0)}function g(a, c){l === z && p.$setValidity(a, c)}function h(a){l === z && d(a)}z++; var l = z; (function(){var a = p.$$parserName || "parse"; if (w === t)g(a, null);  else return w || (m(p.$validators, function(a, c){g(c, null)}), m(p.$asyncValidators, function(a, c){g(c,
                null)})), g(a, w), w; return!0})()?e()?f():h(!1):h(!1)}; this.$commitViewValue = function(){var a = p.$viewValue; h.cancel(K); if (p.$$lastCommittedViewValue !== a || "" === a && p.$$hasNativeValidators)p.$$lastCommittedViewValue = a, p.$pristine && this.$setDirty(), this.$$parseAndValidate()}; this.$$parseAndValidate = function(){var c = p.$$lastCommittedViewValue; if (w = y(c)?t:!0)for (var d = 0; d < p.$parsers.length; d++)if (c = p.$parsers[d](c), y(c)){w = !1; break}X(p.$modelValue) && isNaN(p.$modelValue) && (p.$modelValue = s(a)); var e = p.$modelValue,
                f = p.$options && p.$options.allowInvalid; p.$$rawModelValue = c; f && (p.$modelValue = c, p.$modelValue !== e && p.$$writeModelToScope()); p.$$runValidators(c, p.$$lastCommittedViewValue, function(a){f || (p.$modelValue = a?c:t, p.$modelValue !== e && p.$$writeModelToScope())})}; this.$$writeModelToScope = function(){B(a, p.$modelValue); m(p.$viewChangeListeners, function(a){try{a()} catch (d){c(d)}})}; this.$setViewValue = function(a, c){p.$viewValue = a; p.$options && !p.$options.updateOnDefault || p.$$debounceViewValueCommit(c)}; this.$$debounceViewValueCommit =
                function(c){var d = 0, e = p.$options; e && x(e.debounce) && (e = e.debounce, X(e)?d = e:X(e[c])?d = e[c]:X(e["default"]) && (d = e["default"])); h.cancel(K); d?K = h(function(){p.$commitViewValue()}, d):l.$$phase?p.$commitViewValue():a.$apply(function(){p.$commitViewValue()})}; a.$watch(function(){var c = s(a); if (c !== p.$modelValue && (p.$modelValue === p.$modelValue || c === c)){p.$modelValue = p.$$rawModelValue = c; w = t; for (var d = p.$formatters, e = d.length, f = c; e--; )f = d[e](f); p.$viewValue !== f && (p.$viewValue = p.$$lastCommittedViewValue = f, p.$render(),
                p.$$runValidators(c, f, v))}return c})}], Ke = ["$rootScope", function(a){return{restrict:"A", require:["ngModel", "^?form", "^?ngModelOptions"], controller:xg, priority:1, compile:function(c){c.addClass(Xa).addClass("ng-untouched").addClass(lb); return{pre:function(a, c, f, g){var h = g[0], l = g[1] || Ib; h.$$setOptions(g[2] && g[2].$options); l.$addControl(h); f.$observe("name", function(a){h.$name !== a && l.$$renameControl(h, a)}); a.$on("$destroy", function(){l.$removeControl(h)})}, post:function(c, e, f, g){var h = g[0]; if (h.$options &&
        h.$options.updateOn)e.on(h.$options.updateOn, function(a){h.$$debounceViewValueCommit(a && a.type)}); e.on("blur", function(e){h.$touched || (a.$$phase?c.$evalAsync(h.$setTouched):c.$apply(h.$setTouched))})}}}}}], yg = /(\s+|^)default(\s+|$)/, Oe = function(){return{restrict:"A", controller:["$scope", "$attrs", function(a, c){var d = this; this.$options = fa(a.$eval(c.ngModelOptions)); this.$options.updateOn !== t?(this.$options.updateOnDefault = !1, this.$options.updateOn = T(this.$options.updateOn.replace(yg, function(){d.$options.updateOnDefault =
        !0; return" "}))):this.$options.updateOnDefault = !0}]}}, Ae = Ma({terminal:!0, priority:1E3}), zg = L("ngOptions"), Ag = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/, Ie = ["$compile", "$parse", function(a, c){function d(a, d, e){function f(a, c, d, e, g){this.selectValue = a; this.viewValue = c; this.label = d; this.group = e; this.disabled = g}
function n(a){var c; if (!s && Da(a))c = a;  else{c = []; for (var d in a)a.hasOwnProperty(d) && "$" !== d.charAt(0) && c.push(d)}return c}var m = a.match(Ag); if (!m)throw zg("iexp", a, ua(d)); var r = m[5] || m[7], s = m[6]; a = / as /.test(m[0]) && m[1]; var t = m[9]; d = c(m[2]?m[1]:r); var v = a && c(a) || d, w = t && c(t), p = t?function(a, c){return w(e, c)}:function(a){return Ga(a)}, A = function(a, c){return p(a, C(a, c))}, x = c(m[2] || m[1]), z = c(m[3] || ""), y = c(m[4] || ""), J = c(m[8]), F = {}, C = s?function(a, c){F[s] = c; F[r] = a; return F}:function(a){F[r] = a; return F}; return{trackBy:t,
        getTrackByValue:A, getWatchables:c(J, function(a){var c = []; a = a || []; for (var d = n(a), f = d.length, g = 0; g < f; g++){var h = a === d?g:d[g], k = C(a[h], h), h = p(a[h], k); c.push(h); if (m[2] || m[1])h = x(e, k), c.push(h); m[4] && (k = y(e, k), c.push(k))}return c}), getOptions:function(){for (var a = [], c = {}, d = J(e) || [], g = n(d), h = g.length, m = 0; m < h; m++){var q = d === g?m:g[m], r = C(d[q], q), s = v(e, r), q = p(s, r), u = x(e, r), w = z(e, r), r = y(e, r), s = new f(q, s, u, w, r); a.push(s); c[q] = s}return{items:a, selectValueMap:c, getOptionFromViewValue:function(a){return c[A(a)]},
        getViewValueFromOption:function(a){return t?aa.copy(a.viewValue):a.viewValue}}}}}var e = W.createElement("option"), f = W.createElement("optgroup"); return{restrict:"A", terminal:!0, require:["select", "?ngModel"], link:function(c, h, l, k){function n(a, c){a.element = c; c.disabled = a.disabled; a.value !== c.value && (c.value = a.selectValue); a.label !== c.label && (c.label = a.label, c.textContent = a.label)}function q(a, c, d, e){c && M(c.nodeName) === d?d = c:(d = e.cloneNode(!1), c?a.insertBefore(d, c):a.appendChild(d)); return d}function r(a){for (var c; a; )c =
        a.nextSibling, Wb(a), a = c}function s(a){var c = p && p[0], d = J && J[0]; if (c || d)for (; a && (a === c || a === d); )a = a.nextSibling; return a}function t(){var a = F && w.readValue(); F = D.getOptions(); var c = {}, d = h[0].firstChild; N && h.prepend(p); d = s(d); F.items.forEach(function(a){var g, k; a.group?(g = c[a.group], g || (g = q(h[0], d, "optgroup", f), d = g.nextSibling, g.label = a.group, g = c[a.group] = {groupElement:g, currentOptionElement:g.firstChild}), k = q(g.groupElement, g.currentOptionElement, "option", e), n(a, k), g.currentOptionElement = k.nextSibling):
        (k = q(h[0], d, "option", e), n(a, k), d = k.nextSibling)}); Object.keys(c).forEach(function(a){r(c[a].currentOptionElement)}); r(d); v.$render(); if (!v.$isEmpty(a)){var g = w.readValue(); (D.trackBy?ka(a, g):a === g) || (v.$setViewValue(g), v.$render())}}var v = k[1]; if (v){var w = k[0]; k = l.multiple; for (var p, x = 0, y = h.children(), C = y.length; x < C; x++)if ("" === y[x].value){p = y.eq(x); break}var N = !!p, J = z(e.cloneNode(!1)); J.val("?"); var F, D = d(l.ngOptions, h, c); k?(v.$isEmpty = function(a){return!a || 0 === a.length}, w.writeValue = function(a){F.items.forEach(function(a){a.element.selected =
        !1}); a && a.forEach(function(a){(a = F.getOptionFromViewValue(a)) && !a.disabled && (a.element.selected = !0)})}, w.readValue = function(){var a = h.val() || [], c = []; m(a, function(a){(a = F.selectValueMap[a]) && !a.disabled && c.push(F.getViewValueFromOption(a))}); return c}, D.trackBy && c.$watchCollection(function(){if (G(v.$viewValue))return v.$viewValue.map(function(a){return D.getTrackByValue(a)})}, function(){v.$render()})):(w.writeValue = function(a){var c = F.getOptionFromViewValue(a); c && !c.disabled?h[0].value !== c.selectValue &&
        (J.remove(), N || p.remove(), h[0].value = c.selectValue, c.element.selected = !0, c.element.setAttribute("selected", "selected")):null === a || N?(J.remove(), N || h.prepend(p), h.val(""), p.prop("selected", !0), p.attr("selected", !0)):(N || p.remove(), h.prepend(J), h.val("?"), J.prop("selected", !0), J.attr("selected", !0))}, w.readValue = function(){var a = F.selectValueMap[h.val()]; return a && !a.disabled?(N || p.remove(), J.remove(), F.getViewValueFromOption(a)):null}, D.trackBy && c.$watch(function(){return D.getTrackByValue(v.$viewValue)},
        function(){v.$render()})); N?(p.remove(), a(p)(c), p.removeClass("ng-scope")):p = z(e.cloneNode(!1)); t(); c.$watchCollection(D.getWatchables, t)}}}}], Be = ["$locale", "$interpolate", "$log", function(a, c, d){var e = /{}/g, f = /^when(Minus)?(.+)$/; return{link:function(g, h, l){function k(a){h.text(a || "")}var n = l.count, q = l.$attr.when && h.attr(l.$attr.when), r = l.offset || 0, s = g.$eval(q) || {}, t = {}, x = c.startSymbol(), w = c.endSymbol(), p = x + n + "-" + r + w, A = aa.noop, z; m(l, function(a, c){var d = f.exec(c); d && (d = (d[1]?"-":"") + M(d[2]), s[d] = h.attr(l.$attr[c]))});
        m(s, function(a, d){t[d] = c(a.replace(e, p))}); g.$watch(n, function(c){var e = parseFloat(c), f = isNaN(e); f || e in s || (e = a.pluralCat(e - r)); e === z || f && X(z) && isNaN(z) || (A(), f = t[e], y(f)?(null != c && d.debug("ngPluralize: no rule defined for '" + e + "' in " + q), A = v, k()):A = g.$watch(f, k), z = e)})}}}], Ce = ["$parse", "$animate", function(a, c){var d = L("ngRepeat"), e = function(a, c, d, e, k, n, m){a[d] = e; k && (a[k] = n); a.$index = c; a.$first = 0 === c; a.$last = c === m - 1; a.$middle = !(a.$first || a.$last); a.$odd = !(a.$even = 0 === (c & 1))}; return{restrict:"A",
        multiElement:!0, transclude:"element", priority:1E3, terminal:!0, $$tlb:!0, compile:function(f, g){var h = g.ngRepeat, l = W.createComment(" end ngRepeat: " + h + " "), k = h.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/); if (!k)throw d("iexp", h); var n = k[1], q = k[2], r = k[3], s = k[4], k = n.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/); if (!k)throw d("iidexp", n); var v = k[3] || k[1], x = k[2]; if (r && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(r) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(r)))throw d("badident",
                r); var w, p, A, y, C = {$id:Ga}; s?w = a(s):(A = function(a, c){return Ga(c)}, y = function(a){return a}); return function(a, f, g, k, n){w && (p = function(c, d, e){x && (C[x] = c); C[v] = d; C.$index = e; return w(a, C)}); var s = ga(); a.$watchCollection(q, function(g){var k, q, u = f[0], w, C = ga(), D, F, I, G, L, H, M; r && (a[r] = g); if (Da(g))L = g, q = p || A;  else for (M in q = p || y, L = [], g)g.hasOwnProperty(M) && "$" !== M.charAt(0) && L.push(M); D = L.length; M = Array(D); for (k = 0; k < D; k++)if (F = g === L?k:L[k], I = g[F], G = q(F, I, k), s[G])H = s[G], delete s[G], C[G] = H, M[k] = H;  else{if (C[G])throw m(M,
                function(a){a && a.scope && (s[a.id] = a)}), d("dupes", h, G, I); M[k] = {id:G, scope:t, clone:t}; C[G] = !0}for (w in s){H = s[w]; G = qb(H.clone); c.leave(G); if (G[0].parentNode)for (k = 0, q = G.length; k < q; k++)G[k].$$NG_REMOVED = !0; H.scope.$destroy()}for (k = 0; k < D; k++)if (F = g === L?k:L[k], I = g[F], H = M[k], H.scope){w = u; do w = w.nextSibling; while (w && w.$$NG_REMOVED); H.clone[0] != w && c.move(qb(H.clone), null, z(u)); u = H.clone[H.clone.length - 1]; e(H.scope, k, v, I, x, F, D)} else n(function(a, d){H.scope = d; var f = l.cloneNode(!1); a[a.length++] = f; c.enter(a,
                null, z(u)); u = f; H.clone = a; C[H.id] = H; e(H.scope, k, v, I, x, F, D)}); s = C})}}}}], De = ["$animate", function(a){return{restrict:"A", multiElement:!0, link:function(c, d, e){c.$watch(e.ngShow, function(c){a[c?"removeClass":"addClass"](d, "ng-hide", {tempClasses:"ng-hide-animate"})})}}}], we = ["$animate", function(a){return{restrict:"A", multiElement:!0, link:function(c, d, e){c.$watch(e.ngHide, function(c){a[c?"addClass":"removeClass"](d, "ng-hide", {tempClasses:"ng-hide-animate"})})}}}], Ee = Ma(function(a, c, d){a.$watch(d.ngStyle,
        function(a, d){d && a !== d && m(d, function(a, d){c.css(d, "")}); a && c.css(a)}, !0)}), Fe = ["$animate", function(a){return{require:"ngSwitch", controller:["$scope", function(){this.cases = {}}], link:function(c, d, e, f){var g = [], h = [], l = [], k = [], n = function(a, c){return function(){a.splice(c, 1)}}; c.$watch(e.ngSwitch || e.on, function(c){var d, e; d = 0; for (e = l.length; d < e; ++d)a.cancel(l[d]); d = l.length = 0; for (e = k.length; d < e; ++d){var s = qb(h[d].clone); k[d].$destroy(); (l[d] = a.leave(s)).then(n(l, d))}h.length = 0; k.length = 0; (g = f.cases["!" +
c] || f.cases["?"]) && m(g, function(c){c.transclude(function(d, e){k.push(e); var f = c.element; d[d.length++] = W.createComment(" end ngSwitchWhen: "); h.push({clone:d}); a.enter(d, f.parent(), f)})})})}}}], Ge = Ma({transclude:"element", priority:1200, require:"^ngSwitch", multiElement:!0, link:function(a, c, d, e, f){e.cases["!" + d.ngSwitchWhen] = e.cases["!" + d.ngSwitchWhen] || []; e.cases["!" + d.ngSwitchWhen].push({transclude:f, element:c})}}), He = Ma({transclude:"element", priority:1200, require:"^ngSwitch", multiElement:!0, link:function(a,
        c, d, e, f){e.cases["?"] = e.cases["?"] || []; e.cases["?"].push({transclude:f, element:c})}}), Je = Ma({restrict:"EAC", link:function(a, c, d, e, f){if (!f)throw L("ngTransclude")("orphan", ua(c)); f(function(a){c.empty(); c.append(a)})}}), je = ["$templateCache", function(a){return{restrict:"E", terminal:!0, compile:function(c, d){"text/ng-template" == d.type && a.put(d.id, c[0].text)}}}], Bg = {$setViewValue:v, $render:v}, Cg = ["$element", "$scope", "$attrs", function(a, c, d){var e = this, f = new Ua; e.ngModelCtrl = Bg; e.unknownOption = z(W.createElement("option"));
        e.renderUnknownOption = function(c){c = "? " + Ga(c) + " ?"; e.unknownOption.val(c); a.prepend(e.unknownOption); a.val(c)}; c.$on("$destroy", function(){e.renderUnknownOption = v}); e.removeUnknownOption = function(){e.unknownOption.parent() && e.unknownOption.remove()}; e.readValue = function(){e.removeUnknownOption(); return a.val()}; e.writeValue = function(c){e.hasOption(c)?(e.removeUnknownOption(), a.val(c), "" === c && e.emptyOption.prop("selected", !0)):null == c && e.emptyOption?(e.removeUnknownOption(), a.val("")):e.renderUnknownOption(c)};
        e.addOption = function(a, c){Ta(a, '"option value"'); "" === a && (e.emptyOption = c); var d = f.get(a) || 0; f.put(a, d + 1)}; e.removeOption = function(a){var c = f.get(a); c && (1 === c?(f.remove(a), "" === a && (e.emptyOption = t)):f.put(a, c - 1))}; e.hasOption = function(a){return!!f.get(a)}}], ke = function(){return{restrict:"E", require:["select", "?ngModel"], controller:Cg, link:function(a, c, d, e){var f = e[1]; if (f){var g = e[0]; g.ngModelCtrl = f; f.$render = function(){g.writeValue(f.$viewValue)}; c.on("change", function(){a.$apply(function(){f.$setViewValue(g.readValue())})});
        if (d.multiple){g.readValue = function(){var a = []; m(c.find("option"), function(c){c.selected && a.push(c.value)}); return a}; g.writeValue = function(a){var d = new Ua(a); m(c.find("option"), function(a){a.selected = x(d.get(a.value))})}; var h, l = NaN; a.$watch(function(){l !== f.$viewValue || ka(h, f.$viewValue) || (h = ia(f.$viewValue), f.$render()); l = f.$viewValue}); f.$isEmpty = function(a){return!a || 0 === a.length}}}}}}, me = ["$interpolate", function(a){function c(a){a[0].hasAttribute("selected") && (a[0].selected = !0)}return{restrict:"E",
        priority:100, compile:function(d, e){if (y(e.value)){var f = a(d.text(), !0); f || e.$set("value", d.text())}return function(a, d, e){var k = d.parent(), m = k.data("$selectController") || k.parent().data("$selectController"); m && m.ngModelCtrl && (f?a.$watch(f, function(a, f){e.$set("value", a); f !== a && m.removeOption(f); m.addOption(a, d); m.ngModelCtrl.$render(); c(d)}):(m.addOption(e.value, d), m.ngModelCtrl.$render(), c(d)), d.on("$destroy", function(){m.removeOption(e.value); m.ngModelCtrl.$render()}))}}}}], le = qa({restrict:"E",
        terminal:!1}), Fc = function(){return{restrict:"A", require:"?ngModel", link:function(a, c, d, e){e && (d.required = !0, e.$validators.required = function(a, c){return!d.required || !e.$isEmpty(c)}, d.$observe("required", function(){e.$validate()}))}}}, Ec = function(){return{restrict:"A", require:"?ngModel", link:function(a, c, d, e){if (e){var f, g = d.ngPattern || d.pattern; d.$observe("pattern", function(a){I(a) && 0 < a.length && (a = new RegExp("^" + a + "$")); if (a && !a.test)throw L("ngPattern")("noregexp", g, a, ua(c)); f = a || t; e.$validate()});
        e.$validators.pattern = function(a){return e.$isEmpty(a) || y(f) || f.test(a)}}}}}, Hc = function(){return{restrict:"A", require:"?ngModel", link:function(a, c, d, e){if (e){var f = - 1; d.$observe("maxlength", function(a){a = Y(a); f = isNaN(a)? - 1:a; e.$validate()}); e.$validators.maxlength = function(a, c){return 0 > f || e.$isEmpty(c) || c.length <= f}}}}}, Gc = function(){return{restrict:"A", require:"?ngModel", link:function(a, c, d, e){if (e){var f = 0; d.$observe("minlength", function(a){f = Y(a) || 0; e.$validate()}); e.$validators.minlength = function(a,
        c){return e.$isEmpty(c) || c.length >= f}}}}}; O.angular.bootstrap?console.log("WARNING: Tried to load angular more than once."):(ce(), ee(aa), aa.module("ngLocale", [], ["$provide", function(a){function c(a){a += ""; var c = a.indexOf("."); return - 1 == c?0:a.length - c - 1}a.value("$locale", {DATETIME_FORMATS:{AMPMS:["AM", "PM"], DAY:"Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), ERANAMES:["Before Christ", "Anno Domini"], ERAS:["BC", "AD"], FIRSTDAYOFWEEK:6, MONTH:"January February March April May June July August September October November December".split(" "),
        SHORTDAY:"Sun Mon Tue Wed Thu Fri Sat".split(" "), SHORTMONTH:"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "), WEEKENDRANGE:[5, 6], fullDate:"EEEE, MMMM d, y", longDate:"MMMM d, y", medium:"MMM d, y h:mm:ss a", mediumDate:"MMM d, y", mediumTime:"h:mm:ss a", "short":"M/d/yy h:mm a", shortDate:"M/d/yy", shortTime:"h:mm a"}, NUMBER_FORMATS:{CURRENCY_SYM:"$", DECIMAL_SEP:".", GROUP_SEP:",", PATTERNS:[{gSize:3, lgSize:3, maxFrac:3, minFrac:0, minInt:1, negPre:"-", negSuf:"", posPre:"", posSuf:""}, {gSize:3, lgSize:3,
        maxFrac:2, minFrac:2, minInt:1, negPre:"-\u00a4", negSuf:"", posPre:"\u00a4", posSuf:""}]}, id:"en-us", pluralCat:function(a, e){var f = a | 0, g = e; t === g && (g = Math.min(c(a), 3)); Math.pow(10, g); return 1 == f && 0 == g?"one":"other"}})}]), z(W).ready(function(){Zd(W, yc)}))})(window, document); !window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');
//# sourceMappingURL=angular.min.js.map
/*
 AngularJS v1.5.0
 (c) 2010-2016 Google, Inc. http://angularjs.org
 License: MIT
*/
(function(r,d,C){'use strict';function x(s,h,g){return{restrict:"ECA",terminal:!0,priority:400,transclude:"element",link:function(a,c,b,f,y){function k(){n&&(g.cancel(n),n=null);l&&(l.$destroy(),l=null);m&&(n=g.leave(m),n.then(function(){n=null}),m=null)}function z(){var b=s.current&&s.current.locals;if(d.isDefined(b&&b.$template)){var b=a.$new(),f=s.current;m=y(b,function(b){g.enter(b,null,m||c).then(function(){!d.isDefined(u)||u&&!a.$eval(u)||h()});k()});l=f.scope=b;l.$emit("$viewContentLoaded");
l.$eval(v)}else k()}var l,m,n,u=b.autoscroll,v=b.onload||"";a.$on("$routeChangeSuccess",z);z()}}}function A(d,h,g){return{restrict:"ECA",priority:-400,link:function(a,c){var b=g.current,f=b.locals;c.html(f.$template);var y=d(c.contents());if(b.controller){f.$scope=a;var k=h(b.controller,f);b.controllerAs&&(a[b.controllerAs]=k);c.data("$ngControllerController",k);c.children().data("$ngControllerController",k)}a[b.resolveAs||"$resolve"]=f;y(a)}}}r=d.module("ngRoute",["ng"]).provider("$route",function(){function s(a,
c){return d.extend(Object.create(a),c)}function h(a,d){var b=d.caseInsensitiveMatch,f={originalPath:a,regexp:a},g=f.keys=[];a=a.replace(/([().])/g,"\\$1").replace(/(\/)?:(\w+)([\?\*])?/g,function(a,d,b,c){a="?"===c?c:null;c="*"===c?c:null;g.push({name:b,optional:!!a});d=d||"";return""+(a?"":d)+"(?:"+(a?d:"")+(c&&"(.+?)"||"([^/]+)")+(a||"")+")"+(a||"")}).replace(/([\/$\*])/g,"\\$1");f.regexp=new RegExp("^"+a+"$",b?"i":"");return f}var g={};this.when=function(a,c){var b=d.copy(c);d.isUndefined(b.reloadOnSearch)&&
(b.reloadOnSearch=!0);d.isUndefined(b.caseInsensitiveMatch)&&(b.caseInsensitiveMatch=this.caseInsensitiveMatch);g[a]=d.extend(b,a&&h(a,b));if(a){var f="/"==a[a.length-1]?a.substr(0,a.length-1):a+"/";g[f]=d.extend({redirectTo:a},h(f,b))}return this};this.caseInsensitiveMatch=!1;this.otherwise=function(a){"string"===typeof a&&(a={redirectTo:a});this.when(null,a);return this};this.$get=["$rootScope","$location","$routeParams","$q","$injector","$templateRequest","$sce",function(a,c,b,f,h,k,r){function l(b){var e=
t.current;(x=(p=n())&&e&&p.$$route===e.$$route&&d.equals(p.pathParams,e.pathParams)&&!p.reloadOnSearch&&!v)||!e&&!p||a.$broadcast("$routeChangeStart",p,e).defaultPrevented&&b&&b.preventDefault()}function m(){var w=t.current,e=p;if(x)w.params=e.params,d.copy(w.params,b),a.$broadcast("$routeUpdate",w);else if(e||w)v=!1,(t.current=e)&&e.redirectTo&&(d.isString(e.redirectTo)?c.path(u(e.redirectTo,e.params)).search(e.params).replace():c.url(e.redirectTo(e.pathParams,c.path(),c.search())).replace()),f.when(e).then(function(){if(e){var a=
d.extend({},e.resolve),b,c;d.forEach(a,function(b,e){a[e]=d.isString(b)?h.get(b):h.invoke(b,null,null,e)});d.isDefined(b=e.template)?d.isFunction(b)&&(b=b(e.params)):d.isDefined(c=e.templateUrl)&&(d.isFunction(c)&&(c=c(e.params)),d.isDefined(c)&&(e.loadedTemplateUrl=r.valueOf(c),b=k(c)));d.isDefined(b)&&(a.$template=b);return f.all(a)}}).then(function(c){e==t.current&&(e&&(e.locals=c,d.copy(e.params,b)),a.$broadcast("$routeChangeSuccess",e,w))},function(b){e==t.current&&a.$broadcast("$routeChangeError",
e,w,b)})}function n(){var a,b;d.forEach(g,function(f,g){var q;if(q=!b){var h=c.path();q=f.keys;var l={};if(f.regexp)if(h=f.regexp.exec(h)){for(var k=1,n=h.length;k<n;++k){var m=q[k-1],p=h[k];m&&p&&(l[m.name]=p)}q=l}else q=null;else q=null;q=a=q}q&&(b=s(f,{params:d.extend({},c.search(),a),pathParams:a}),b.$$route=f)});return b||g[null]&&s(g[null],{params:{},pathParams:{}})}function u(a,b){var c=[];d.forEach((a||"").split(":"),function(a,d){if(0===d)c.push(a);else{var f=a.match(/(\w+)(?:[?*])?(.*)/),
g=f[1];c.push(b[g]);c.push(f[2]||"");delete b[g]}});return c.join("")}var v=!1,p,x,t={routes:g,reload:function(){v=!0;var b={defaultPrevented:!1,preventDefault:function(){this.defaultPrevented=!0;v=!1}};a.$evalAsync(function(){l(b);b.defaultPrevented||m()})},updateParams:function(a){if(this.current&&this.current.$$route)a=d.extend({},this.current.params,a),c.path(u(this.current.$$route.originalPath,a)),c.search(a);else throw B("norout");}};a.$on("$locationChangeStart",l);a.$on("$locationChangeSuccess",
m);return t}]});var B=d.$$minErr("ngRoute");r.provider("$routeParams",function(){this.$get=function(){return{}}});r.directive("ngView",x);r.directive("ngView",A);x.$inject=["$route","$anchorScroll","$animate"];A.$inject=["$compile","$controller","$route"]})(window,window.angular);
//# sourceMappingURL=angular-route.min.js.map

/**
 * State-based routing for AngularJS
 * @version v0.2.15
 * @link http://angular-ui.github.com/
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */

/* commonjs package manager support (eg componentjs) */
if (typeof module !== "undefined" && typeof exports !== "undefined" && module.exports === exports) {
    module.exports = 'ui.router';
}

(function (window, angular, undefined) {
    /*jshint globalstrict:true*/
    /*global angular:false*/
    'use strict';

    var isDefined = angular.isDefined,
            isFunction = angular.isFunction,
            isString = angular.isString,
            isObject = angular.isObject,
            isArray = angular.isArray,
            forEach = angular.forEach,
            extend = angular.extend,
            copy = angular.copy;

    function inherit(parent, extra) {
        return extend(new (extend(function () {}, {prototype: parent}))(), extra);
    }

    function merge(dst) {
        forEach(arguments, function (obj) {
            if (obj !== dst) {
                forEach(obj, function (value, key) {
                    if (!dst.hasOwnProperty(key))
                        dst[key] = value;
                });
            }
        });
        return dst;
    }

    /**
     * Finds the common ancestor path between two states.
     *
     * @param {Object} first The first state.
     * @param {Object} second The second state.
     * @return {Array} Returns an array of state names in descending order, not including the root.
     */
    function ancestors(first, second) {
        var path = [];

        for (var n in first.path) {
            if (first.path[n] !== second.path[n])
                break;
            path.push(first.path[n]);
        }
        return path;
    }

    /**
     * IE8-safe wrapper for `Object.keys()`.
     *
     * @param {Object} object A JavaScript object.
     * @return {Array} Returns the keys of the object as an array.
     */
    function objectKeys(object) {
        if (Object.keys) {
            return Object.keys(object);
        }
        var result = [];

        forEach(object, function (val, key) {
            result.push(key);
        });
        return result;
    }

    /**
     * IE8-safe wrapper for `Array.prototype.indexOf()`.
     *
     * @param {Array} array A JavaScript array.
     * @param {*} value A value to search the array for.
     * @return {Number} Returns the array index value of `value`, or `-1` if not present.
     */
    function indexOf(array, value) {
        if (Array.prototype.indexOf) {
            return array.indexOf(value, Number(arguments[2]) || 0);
        }
        var len = array.length >>> 0, from = Number(arguments[2]) || 0;
        from = (from < 0) ? Math.ceil(from) : Math.floor(from);

        if (from < 0)
            from += len;

        for (; from < len; from++) {
            if (from in array && array[from] === value)
                return from;
        }
        return -1;
    }

    /**
     * Merges a set of parameters with all parameters inherited between the common parents of the
     * current state and a given destination state.
     *
     * @param {Object} currentParams The value of the current state parameters ($stateParams).
     * @param {Object} newParams The set of parameters which will be composited with inherited params.
     * @param {Object} $current Internal definition of object representing the current state.
     * @param {Object} $to Internal definition of object representing state to transition to.
     */
    function inheritParams(currentParams, newParams, $current, $to) {
        var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];

        for (var i in parents) {
            if (!parents[i].params)
                continue;
            parentParams = objectKeys(parents[i].params);
            if (!parentParams.length)
                continue;

            for (var j in parentParams) {
                if (indexOf(inheritList, parentParams[j]) >= 0)
                    continue;
                inheritList.push(parentParams[j]);
                inherited[parentParams[j]] = currentParams[parentParams[j]];
            }
        }
        return extend({}, inherited, newParams);
    }

    /**
     * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.
     *
     * @param {Object} a The first object.
     * @param {Object} b The second object.
     * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,
     *                     it defaults to the list of keys in `a`.
     * @return {Boolean} Returns `true` if the keys match, otherwise `false`.
     */
    function equalForKeys(a, b, keys) {
        if (!keys) {
            keys = [];
            for (var n in a)
                keys.push(n); // Used instead of Object.keys() for IE8 compatibility
        }

        for (var i = 0; i < keys.length; i++) {
            var k = keys[i];
            if (a[k] != b[k])
                return false; // Not '===', values aren't necessarily normalized
        }
        return true;
    }

    /**
     * Returns the subset of an object, based on a list of keys.
     *
     * @param {Array} keys
     * @param {Object} values
     * @return {Boolean} Returns a subset of `values`.
     */
    function filterByKeys(keys, values) {
        var filtered = {};

        forEach(keys, function (name) {
            filtered[name] = values[name];
        });
        return filtered;
    }

// like _.indexBy
// when you know that your index values will be unique, or you want last-one-in to win
    function indexBy(array, propName) {
        var result = {};
        forEach(array, function (item) {
            result[item[propName]] = item;
        });
        return result;
    }

// extracted from underscore.js
// Return a copy of the object only containing the whitelisted properties.
    function pick(obj) {
        var copy = {};
        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        forEach(keys, function (key) {
            if (key in obj)
                copy[key] = obj[key];
        });
        return copy;
    }

// extracted from underscore.js
// Return a copy of the object omitting the blacklisted properties.
    function omit(obj) {
        var copy = {};
        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        for (var key in obj) {
            if (indexOf(keys, key) == -1)
                copy[key] = obj[key];
        }
        return copy;
    }

    function pluck(collection, key) {
        var result = isArray(collection) ? [] : {};

        forEach(collection, function (val, i) {
            result[i] = isFunction(key) ? key(val) : val[key];
        });
        return result;
    }

    function filter(collection, callback) {
        var array = isArray(collection);
        var result = array ? [] : {};
        forEach(collection, function (val, i) {
            if (callback(val, i)) {
                result[array ? result.length : i] = val;
            }
        });
        return result;
    }

    function map(collection, callback) {
        var result = isArray(collection) ? [] : {};

        forEach(collection, function (val, i) {
            result[i] = callback(val, i);
        });
        return result;
    }

    /**
     * @ngdoc overview
     * @name ui.router.util
     *
     * @description
     * # ui.router.util sub-module
     *
     * This module is a dependency of other sub-modules. Do not include this module as a dependency
     * in your angular app (use {@link ui.router} module instead).
     *
     */
    angular.module('ui.router.util', ['ng']);

    /**
     * @ngdoc overview
     * @name ui.router.router
     *
     * @requires ui.router.util
     *
     * @description
     * # ui.router.router sub-module
     *
     * This module is a dependency of other sub-modules. Do not include this module as a dependency
     * in your angular app (use {@link ui.router} module instead).
     */
    angular.module('ui.router.router', ['ui.router.util']);

    /**
     * @ngdoc overview
     * @name ui.router.state
     *
     * @requires ui.router.router
     * @requires ui.router.util
     *
     * @description
     * # ui.router.state sub-module
     *
     * This module is a dependency of the main ui.router module. Do not include this module as a dependency
     * in your angular app (use {@link ui.router} module instead).
     *
     */
    angular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);

    /**
     * @ngdoc overview
     * @name ui.router
     *
     * @requires ui.router.state
     *
     * @description
     * # ui.router
     *
     * ## The main module for ui.router
     * There are several sub-modules included with the ui.router module, however only this module is needed
     * as a dependency within your angular app. The other modules are for organization purposes.
     *
     * The modules are:
     * * ui.router - the main "umbrella" module
     * * ui.router.router -
     *
     * *You'll need to include **only** this module as the dependency within your angular app.*
     *
     * <pre>
     * <!doctype html>
     * <html ng-app="myApp">
     * <head>
     *   <script src="js/angular.js"></script>
     *   <!-- Include the ui-router script -->
     *   <script src="js/angular-ui-router.min.js"></script>
     *   <script>
     *     // ...and add 'ui.router' as a dependency
     *     var myApp = angular.module('myApp', ['ui.router']);
     *   </script>
     * </head>
     * <body>
     * </body>
     * </html>
     * </pre>
     */
    angular.module('ui.router', ['ui.router.state']);

    angular.module('ui.router.compat', ['ui.router']);

    /**
     * @ngdoc object
     * @name ui.router.util.$resolve
     *
     * @requires $q
     * @requires $injector
     *
     * @description
     * Manages resolution of (acyclic) graphs of promises.
     */
    $Resolve.$inject = ['$q', '$injector'];
    function $Resolve($q, $injector) {

        var VISIT_IN_PROGRESS = 1,
                VISIT_DONE = 2,
                NOTHING = {},
                NO_DEPENDENCIES = [],
                NO_LOCALS = NOTHING,
                NO_PARENT = extend($q.when(NOTHING), {$$promises: NOTHING, $$values: NOTHING});


        /**
         * @ngdoc function
         * @name ui.router.util.$resolve#study
         * @methodOf ui.router.util.$resolve
         *
         * @description
         * Studies a set of invocables that are likely to be used multiple times.
         * <pre>
         * $resolve.study(invocables)(locals, parent, self)
         * </pre>
         * is equivalent to
         * <pre>
         * $resolve.resolve(invocables, locals, parent, self)
         * </pre>
         * but the former is more efficient (in fact `resolve` just calls `study`
         * internally).
         *
         * @param {object} invocables Invocable objects
         * @return {function} a function to pass in locals, parent and self
         */
        this.study = function (invocables) {
            if (!isObject(invocables))
                throw new Error("'invocables' must be an object");
            var invocableKeys = objectKeys(invocables || {});

            // Perform a topological sort of invocables to build an ordered plan
            var plan = [], cycle = [], visited = {};
            function visit(value, key) {
                if (visited[key] === VISIT_DONE)
                    return;

                cycle.push(key);
                if (visited[key] === VISIT_IN_PROGRESS) {
                    cycle.splice(0, indexOf(cycle, key));
                    throw new Error("Cyclic dependency: " + cycle.join(" -> "));
                }
                visited[key] = VISIT_IN_PROGRESS;

                if (isString(value)) {
                    plan.push(key, [function () {
                            return $injector.get(value);
                        }], NO_DEPENDENCIES);
                } else {
                    var params = $injector.annotate(value);
                    forEach(params, function (param) {
                        if (param !== key && invocables.hasOwnProperty(param))
                            visit(invocables[param], param);
                    });
                    plan.push(key, value, params);
                }

                cycle.pop();
                visited[key] = VISIT_DONE;
            }
            forEach(invocables, visit);
            invocables = cycle = visited = null; // plan is all that's required

            function isResolve(value) {
                return isObject(value) && value.then && value.$$promises;
            }

            return function (locals, parent, self) {
                if (isResolve(locals) && self === undefined) {
                    self = parent;
                    parent = locals;
                    locals = null;
                }
                if (!locals)
                    locals = NO_LOCALS;
                else if (!isObject(locals)) {
                    throw new Error("'locals' must be an object");
                }
                if (!parent)
                    parent = NO_PARENT;
                else if (!isResolve(parent)) {
                    throw new Error("'parent' must be a promise returned by $resolve.resolve()");
                }

                // To complete the overall resolution, we have to wait for the parent
                // promise and for the promise for each invokable in our plan.
                var resolution = $q.defer(),
                        result = resolution.promise,
                        promises = result.$$promises = {},
                        values = extend({}, locals),
                        wait = 1 + plan.length / 3,
                        merged = false;

                function done() {
                    // Merge parent values we haven't got yet and publish our own $$values
                    if (!--wait) {
                        if (!merged)
                            merge(values, parent.$$values);
                        result.$$values = values;
                        result.$$promises = result.$$promises || true; // keep for isResolve()
                        delete result.$$inheritedValues;
                        resolution.resolve(values);
                    }
                }

                function fail(reason) {
                    result.$$failure = reason;
                    resolution.reject(reason);
                }

                // Short-circuit if parent has already failed
                if (isDefined(parent.$$failure)) {
                    fail(parent.$$failure);
                    return result;
                }

                if (parent.$$inheritedValues) {
                    merge(values, omit(parent.$$inheritedValues, invocableKeys));
                }

                // Merge parent values if the parent has already resolved, or merge
                // parent promises and wait if the parent resolve is still in progress.
                extend(promises, parent.$$promises);
                if (parent.$$values) {
                    merged = merge(values, omit(parent.$$values, invocableKeys));
                    result.$$inheritedValues = omit(parent.$$values, invocableKeys);
                    done();
                } else {
                    if (parent.$$inheritedValues) {
                        result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);
                    }
                    parent.then(done, fail);
                }

                // Process each invocable in the plan, but ignore any where a local of the same name exists.
                for (var i = 0, ii = plan.length; i < ii; i += 3) {
                    if (locals.hasOwnProperty(plan[i]))
                        done();
                    else
                        invoke(plan[i], plan[i + 1], plan[i + 2]);
                }

                function invoke(key, invocable, params) {
                    // Create a deferred for this invocation. Failures will propagate to the resolution as well.
                    var invocation = $q.defer(), waitParams = 0;
                    function onfailure(reason) {
                        invocation.reject(reason);
                        fail(reason);
                    }
                    // Wait for any parameter that we have a promise for (either from parent or from this
                    // resolve; in that case study() will have made sure it's ordered before us in the plan).
                    forEach(params, function (dep) {
                        if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {
                            waitParams++;
                            promises[dep].then(function (result) {
                                values[dep] = result;
                                if (!(--waitParams))
                                    proceed();
                            }, onfailure);
                        }
                    });
                    if (!waitParams)
                        proceed();
                    function proceed() {
                        if (isDefined(result.$$failure))
                            return;
                        try {
                            invocation.resolve($injector.invoke(invocable, self, values));
                            invocation.promise.then(function (result) {
                                values[key] = result;
                                done();
                            }, onfailure);
                        } catch (e) {
                            onfailure(e);
                        }
                    }
                    // Publish promise synchronously; invocations further down in the plan may depend on it.
                    promises[key] = invocation.promise;
                }

                return result;
            };
        };

        /**
         * @ngdoc function
         * @name ui.router.util.$resolve#resolve
         * @methodOf ui.router.util.$resolve
         *
         * @description
         * Resolves a set of invocables. An invocable is a function to be invoked via
         * `$injector.invoke()`, and can have an arbitrary number of dependencies.
         * An invocable can either return a value directly,
         * or a `$q` promise. If a promise is returned it will be resolved and the
         * resulting value will be used instead. Dependencies of invocables are resolved
         * (in this order of precedence)
         *
         * - from the specified `locals`
         * - from another invocable that is part of this `$resolve` call
         * - from an invocable that is inherited from a `parent` call to `$resolve`
         *   (or recursively
         * - from any ancestor `$resolve` of that parent).
         *
         * The return value of `$resolve` is a promise for an object that contains
         * (in this order of precedence)
         *
         * - any `locals` (if specified)
         * - the resolved return values of all injectables
         * - any values inherited from a `parent` call to `$resolve` (if specified)
         *
         * The promise will resolve after the `parent` promise (if any) and all promises
         * returned by injectables have been resolved. If any invocable
         * (or `$injector.invoke`) throws an exception, or if a promise returned by an
         * invocable is rejected, the `$resolve` promise is immediately rejected with the
         * same error. A rejection of a `parent` promise (if specified) will likewise be
         * propagated immediately. Once the `$resolve` promise has been rejected, no
         * further invocables will be called.
         *
         * Cyclic dependencies between invocables are not permitted and will caues `$resolve`
         * to throw an error. As a special case, an injectable can depend on a parameter
         * with the same name as the injectable, which will be fulfilled from the `parent`
         * injectable of the same name. This allows inherited values to be decorated.
         * Note that in this case any other injectable in the same `$resolve` with the same
         * dependency would see the decorated value, not the inherited value.
         *
         * Note that missing dependencies -- unlike cyclic dependencies -- will cause an
         * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous)
         * exception.
         *
         * Invocables are invoked eagerly as soon as all dependencies are available.
         * This is true even for dependencies inherited from a `parent` call to `$resolve`.
         *
         * As a special case, an invocable can be a string, in which case it is taken to
         * be a service name to be passed to `$injector.get()`. This is supported primarily
         * for backwards-compatibility with the `resolve` property of `$routeProvider`
         * routes.
         *
         * @param {object} invocables functions to invoke or
         * `$injector` services to fetch.
         * @param {object} locals  values to make available to the injectables
         * @param {object} parent  a promise returned by another call to `$resolve`.
         * @param {object} self  the `this` for the invoked methods
         * @return {object} Promise for an object that contains the resolved return value
         * of all invocables, as well as any inherited and local values.
         */
        this.resolve = function (invocables, locals, parent, self) {
            return this.study(invocables)(locals, parent, self);
        };
    }

    angular.module('ui.router.util').service('$resolve', $Resolve);


    /**
     * @ngdoc object
     * @name ui.router.util.$templateFactory
     *
     * @requires $http
     * @requires $templateCache
     * @requires $injector
     *
     * @description
     * Service. Manages loading of templates.
     */
    $TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];
    function $TemplateFactory($http, $templateCache, $injector) {

        /**
         * @ngdoc function
         * @name ui.router.util.$templateFactory#fromConfig
         * @methodOf ui.router.util.$templateFactory
         *
         * @description
         * Creates a template from a configuration object.
         *
         * @param {object} config Configuration object for which to load a template.
         * The following properties are search in the specified order, and the first one
         * that is defined is used to create the template:
         *
         * @param {string|object} config.template html string template or function to
         * load via {@link ui.router.util.$templateFactory#fromString fromString}.
         * @param {string|object} config.templateUrl url to load or a function returning
         * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.
         * @param {Function} config.templateProvider function to invoke via
         * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.
         * @param {object} params  Parameters to pass to the template function.
         * @param {object} locals Locals to pass to `invoke` if the template is loaded
         * via a `templateProvider`. Defaults to `{ params: params }`.
         *
         * @return {string|object}  The template html as a string, or a promise for
         * that string,or `null` if no template is configured.
         */
        this.fromConfig = function (config, params, locals) {
            return (
                    isDefined(config.template) ? this.fromString(config.template, params) :
                    isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :
                    isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :
                    null
                    );
        };

        /**
         * @ngdoc function
         * @name ui.router.util.$templateFactory#fromString
         * @methodOf ui.router.util.$templateFactory
         *
         * @description
         * Creates a template from a string or a function returning a string.
         *
         * @param {string|object} template html template as a string or function that
         * returns an html template as a string.
         * @param {object} params Parameters to pass to the template function.
         *
         * @return {string|object} The template html as a string, or a promise for that
         * string.
         */
        this.fromString = function (template, params) {
            return isFunction(template) ? template(params) : template;
        };

        /**
         * @ngdoc function
         * @name ui.router.util.$templateFactory#fromUrl
         * @methodOf ui.router.util.$templateFactory
         *
         * @description
         * Loads a template from the a URL via `$http` and `$templateCache`.
         *
         * @param {string|Function} url url of the template to load, or a function
         * that returns a url.
         * @param {Object} params Parameters to pass to the url function.
         * @return {string|Promise.<string>} The template html as a string, or a promise
         * for that string.
         */
        this.fromUrl = function (url, params) {
            if (isFunction(url))
                url = url(params);
            if (url == null)
                return null;
            else
                return $http
                        .get(url, {cache: $templateCache, headers: {Accept: 'text/html'}})
                        .then(function (response) {
                            return response.data;
                        });
        };

        /**
         * @ngdoc function
         * @name ui.router.util.$templateFactory#fromProvider
         * @methodOf ui.router.util.$templateFactory
         *
         * @description
         * Creates a template by invoking an injectable provider function.
         *
         * @param {Function} provider Function to invoke via `$injector.invoke`
         * @param {Object} params Parameters for the template.
         * @param {Object} locals Locals to pass to `invoke`. Defaults to
         * `{ params: params }`.
         * @return {string|Promise.<string>} The template html as a string, or a promise
         * for that string.
         */
        this.fromProvider = function (provider, params, locals) {
            return $injector.invoke(provider, null, locals || {params: params});
        };
    }

    angular.module('ui.router.util').service('$templateFactory', $TemplateFactory);

    var $$UMFP; // reference to $UrlMatcherFactoryProvider

    /**
     * @ngdoc object
     * @name ui.router.util.type:UrlMatcher
     *
     * @description
     * Matches URLs against patterns and extracts named parameters from the path or the search
     * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list
     * of search parameters. Multiple search parameter names are separated by '&'. Search parameters
     * do not influence whether or not a URL is matched, but their values are passed through into
     * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.
     *
     * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace
     * syntax, which optionally allows a regular expression for the parameter to be specified:
     *
     * * `':'` name - colon placeholder
     * * `'*'` name - catch-all placeholder
     * * `'{' name '}'` - curly placeholder
     * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the
     *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.
     *
     * Parameter names may contain only word characters (latin letters, digits, and underscore) and
     * must be unique within the pattern (across both path and search parameters). For colon
     * placeholders or curly placeholders without an explicit regexp, a path parameter matches any
     * number of characters other than '/'. For catch-all placeholders the path parameter matches
     * any number of characters.
     *
     * Examples:
     *
     * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for
     *   trailing slashes, and patterns have to match the entire path, not just a prefix.
     * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or
     *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.
     * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.
     * * `'/user/{id:[^/]*}'` - Same as the previous example.
     * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id
     *   parameter consists of 1 to 8 hex digits.
     * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the
     *   path into the parameter 'path'.
     * * `'/files/*path'` - ditto.
     * * `'/calendar/{start:date}'` - Matches "/calendar/2014-11-12" (because the pattern defined
     *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start
     *
     * @param {string} pattern  The pattern to compile into a matcher.
     * @param {Object} config  A configuration object hash:
     * @param {Object=} parentMatcher Used to concatenate the pattern/config onto
     *   an existing UrlMatcher
     *
     * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.
     * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.
     *
     * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any
     *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns
     *   non-null) will start with this prefix.
     *
     * @property {string} source  The pattern that was passed into the constructor
     *
     * @property {string} sourcePath  The path portion of the source property
     *
     * @property {string} sourceSearch  The search portion of the source property
     *
     * @property {string} regex  The constructed regex that will be used to match against the url when
     *   it is time to determine which url will match.
     *
     * @returns {Object}  New `UrlMatcher` object
     */
    function UrlMatcher(pattern, config, parentMatcher) {
        config = extend({params: {}}, isObject(config) ? config : {});

        // Find all placeholders and create a compiled pattern, using either classic or curly syntax:
        //   '*' name
        //   ':' name
        //   '{' name '}'
        //   '{' name ':' regexp '}'
        // The regular expression is somewhat complicated due to the need to allow curly braces
        // inside the regular expression. The placeholder regexp breaks down as follows:
        //    ([:*])([\w\[\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)
        //    \{([\w\[\]]+)(?:\:( ... ))?\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case
        //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either
        //    [^{}\\]+                       - anything other than curly braces or backslash
        //    \\.                            - a backslash escape
        //    \{(?:[^{}\\]+|\\.)*\}          - a matched set of curly braces containing other atoms
        var placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
                searchPlaceholder = /([:]?)([\w\[\]-]+)|\{([\w\[\]-]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
                compiled = '^', last = 0, m,
                segments = this.segments = [],
                parentParams = parentMatcher ? parentMatcher.params : {},
                params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),
                paramNames = [];

        function addParameter(id, type, config, location) {
            paramNames.push(id);
            if (parentParams[id])
                return parentParams[id];
            if (!/^\w+(-+\w+)*(?:\[\])?$/.test(id))
                throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
            if (params[id])
                throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
            params[id] = new $$UMFP.Param(id, type, config, location);
            return params[id];
        }

        function quoteRegExp(string, pattern, squash, optional) {
            var surroundPattern = ['', ''], result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
            if (!pattern)
                return result;
            switch (squash) {
                case false:
                    surroundPattern = ['(', ')' + (optional ? "?" : "")];
                    break;
                case true:
                    surroundPattern = ['?(', ')?'];
                    break;
                default:
                    surroundPattern = ['(' + squash + "|", ')?'];
                    break;
            }
            return result + surroundPattern[0] + pattern + surroundPattern[1];
        }

        this.source = pattern;

        // Split into static segments separated by path parameter placeholders.
        // The number of segments is always 1 more than the number of parameters.
        function matchDetails(m, isSearch) {
            var id, regexp, segment, type, cfg, arrayMode;
            id = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null
            cfg = config.params[id];
            segment = pattern.substring(last, m.index);
            regexp = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);
            type = $$UMFP.type(regexp || "string") || inherit($$UMFP.type("string"), {pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined)});
            return {
                id: id, regexp: regexp, segment: segment, type: type, cfg: cfg
            };
        }

        var p, param, segment;
        while ((m = placeholder.exec(pattern))) {
            p = matchDetails(m, false);
            if (p.segment.indexOf('?') >= 0)
                break; // we're into the search part

            param = addParameter(p.id, p.type, p.cfg, "path");
            compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);
            segments.push(p.segment);
            last = placeholder.lastIndex;
        }
        segment = pattern.substring(last);

        // Find any search parameter names and remove them from the last segment
        var i = segment.indexOf('?');

        if (i >= 0) {
            var search = this.sourceSearch = segment.substring(i);
            segment = segment.substring(0, i);
            this.sourcePath = pattern.substring(0, last + i);

            if (search.length > 0) {
                last = 0;
                while ((m = searchPlaceholder.exec(search))) {
                    p = matchDetails(m, true);
                    param = addParameter(p.id, p.type, p.cfg, "search");
                    last = placeholder.lastIndex;
                    // check if ?&
                }
            }
        } else {
            this.sourcePath = pattern;
            this.sourceSearch = '';
        }

        compiled += quoteRegExp(segment) + (config.strict === false ? '\/?' : '') + '$';
        segments.push(segment);

        this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);
        this.prefix = segments[0];
        this.$$paramNames = paramNames;
    }

    /**
     * @ngdoc function
     * @name ui.router.util.type:UrlMatcher#concat
     * @methodOf ui.router.util.type:UrlMatcher
     *
     * @description
     * Returns a new matcher for a pattern constructed by appending the path part and adding the
     * search parameters of the specified pattern to this pattern. The current pattern is not
     * modified. This can be understood as creating a pattern for URLs that are relative to (or
     * suffixes of) the current pattern.
     *
     * @example
     * The following two matchers are equivalent:
     * <pre>
     * new UrlMatcher('/user/{id}?q').concat('/details?date');
     * new UrlMatcher('/user/{id}/details?q&date');
     * </pre>
     *
     * @param {string} pattern  The pattern to append.
     * @param {Object} config  An object hash of the configuration for the matcher.
     * @returns {UrlMatcher}  A matcher for the concatenated pattern.
     */
    UrlMatcher.prototype.concat = function (pattern, config) {
        // Because order of search parameters is irrelevant, we can add our own search
        // parameters to the end of the new pattern. Parse the new pattern by itself
        // and then join the bits together, but it's much easier to do this on a string level.
        var defaultConfig = {
            caseInsensitive: $$UMFP.caseInsensitive(),
            strict: $$UMFP.strictMode(),
            squash: $$UMFP.defaultSquashPolicy()
        };
        return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);
    };

    UrlMatcher.prototype.toString = function () {
        return this.source;
    };

    /**
     * @ngdoc function
     * @name ui.router.util.type:UrlMatcher#exec
     * @methodOf ui.router.util.type:UrlMatcher
     *
     * @description
     * Tests the specified path against this matcher, and returns an object containing the captured
     * parameter values, or null if the path does not match. The returned object contains the values
     * of any search parameters that are mentioned in the pattern, but their value may be null if
     * they are not present in `searchParams`. This means that search parameters are always treated
     * as optional.
     *
     * @example
     * <pre>
     * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {
     *   x: '1', q: 'hello'
     * });
     * // returns { id: 'bob', q: 'hello', r: null }
     * </pre>
     *
     * @param {string} path  The URL path to match, e.g. `$location.path()`.
     * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.
     * @returns {Object}  The captured parameter values.
     */
    UrlMatcher.prototype.exec = function (path, searchParams) {
        var m = this.regexp.exec(path);
        if (!m)
            return null;
        searchParams = searchParams || {};

        var paramNames = this.parameters(), nTotal = paramNames.length,
                nPath = this.segments.length - 1,
                values = {}, i, j, cfg, paramName;

        if (nPath !== m.length - 1)
            throw new Error("Unbalanced capture group in route '" + this.source + "'");

        function decodePathArray(string) {
            function reverseString(str) {
                return str.split("").reverse().join("");
            }
            function unquoteDashes(str) {
                return str.replace(/\\-/g, "-");
            }

            var split = reverseString(string).split(/-(?!\\)/);
            var allReversed = map(split, reverseString);
            return map(allReversed, unquoteDashes).reverse();
        }

        for (i = 0; i < nPath; i++) {
            paramName = paramNames[i];
            var param = this.params[paramName];
            var paramVal = m[i + 1];
            // if the param value matches a pre-replace pair, replace the value before decoding.
            for (j = 0; j < param.replace; j++) {
                if (param.replace[j].from === paramVal)
                    paramVal = param.replace[j].to;
            }
            if (paramVal && param.array === true)
                paramVal = decodePathArray(paramVal);
            values[paramName] = param.value(paramVal);
        }
        for (/**/; i < nTotal; i++) {
            paramName = paramNames[i];
            values[paramName] = this.params[paramName].value(searchParams[paramName]);
        }

        return values;
    };

    /**
     * @ngdoc function
     * @name ui.router.util.type:UrlMatcher#parameters
     * @methodOf ui.router.util.type:UrlMatcher
     *
     * @description
     * Returns the names of all path and search parameters of this pattern in an unspecified order.
     *
     * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the
     *    pattern has no parameters, an empty array is returned.
     */
    UrlMatcher.prototype.parameters = function (param) {
        if (!isDefined(param))
            return this.$$paramNames;
        return this.params[param] || null;
    };

    /**
     * @ngdoc function
     * @name ui.router.util.type:UrlMatcher#validate
     * @methodOf ui.router.util.type:UrlMatcher
     *
     * @description
     * Checks an object hash of parameters to validate their correctness according to the parameter
     * types of this `UrlMatcher`.
     *
     * @param {Object} params The object hash of parameters to validate.
     * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.
     */
    UrlMatcher.prototype.validates = function (params) {
        return this.params.$$validates(params);
    };

    /**
     * @ngdoc function
     * @name ui.router.util.type:UrlMatcher#format
     * @methodOf ui.router.util.type:UrlMatcher
     *
     * @description
     * Creates a URL that matches this pattern by substituting the specified values
     * for the path and search parameters. Null values for path parameters are
     * treated as empty strings.
     *
     * @example
     * <pre>
     * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });
     * // returns '/user/bob?q=yes'
     * </pre>
     *
     * @param {Object} values  the values to substitute for the parameters in this pattern.
     * @returns {string}  the formatted URL (path and optionally search part).
     */
    UrlMatcher.prototype.format = function (values) {
        values = values || {};
        var segments = this.segments, params = this.parameters(), paramset = this.params;
        if (!this.validates(values))
            return null;

        var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];

        function encodeDashes(str) { // Replace dashes with encoded "\-"
            return encodeURIComponent(str).replace(/-/g, function (c) {
                return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase();
            });
        }

        for (i = 0; i < nTotal; i++) {
            var isPathParam = i < nPath;
            var name = params[i], param = paramset[name], value = param.value(values[name]);
            var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);
            var squash = isDefaultValue ? param.squash : false;
            var encoded = param.type.encode(value);

            if (isPathParam) {
                var nextSegment = segments[i + 1];
                if (squash === false) {
                    if (encoded != null) {
                        if (isArray(encoded)) {
                            result += map(encoded, encodeDashes).join("-");
                        } else {
                            result += encodeURIComponent(encoded);
                        }
                    }
                    result += nextSegment;
                } else if (squash === true) {
                    var capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
                    result += nextSegment.match(capture)[1];
                } else if (isString(squash)) {
                    result += squash + nextSegment;
                }
            } else {
                if (encoded == null || (isDefaultValue && squash !== false))
                    continue;
                if (!isArray(encoded))
                    encoded = [encoded];
                encoded = map(encoded, encodeURIComponent).join('&' + name + '=');
                result += (search ? '&' : '?') + (name + '=' + encoded);
                search = true;
            }
        }

        return result;
    };

    /**
     * @ngdoc object
     * @name ui.router.util.type:Type
     *
     * @description
     * Implements an interface to define custom parameter types that can be decoded from and encoded to
     * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}
     * objects when matching or formatting URLs, or comparing or validating parameter values.
     *
     * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more
     * information on registering custom types.
     *
     * @param {Object} config  A configuration object which contains the custom type definition.  The object's
     *        properties will override the default methods and/or pattern in `Type`'s public interface.
     * @example
     * <pre>
     * {
     *   decode: function(val) { return parseInt(val, 10); },
     *   encode: function(val) { return val && val.toString(); },
     *   equals: function(a, b) { return this.is(a) && a === b; },
     *   is: function(val) { return angular.isNumber(val) isFinite(val) && val % 1 === 0; },
     *   pattern: /\d+/
     * }
     * </pre>
     *
     * @property {RegExp} pattern The regular expression pattern used to match values of this type when
     *           coming from a substring of a URL.
     *
     * @returns {Object}  Returns a new `Type` object.
     */
    function Type(config) {
        extend(this, config);
    }

    /**
     * @ngdoc function
     * @name ui.router.util.type:Type#is
     * @methodOf ui.router.util.type:Type
     *
     * @description
     * Detects whether a value is of a particular type. Accepts a native (decoded) value
     * and determines whether it matches the current `Type` object.
     *
     * @param {*} val  The value to check.
     * @param {string} key  Optional. If the type check is happening in the context of a specific
     *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the
     *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.
     * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.
     */
    Type.prototype.is = function (val, key) {
        return true;
    };

    /**
     * @ngdoc function
     * @name ui.router.util.type:Type#encode
     * @methodOf ui.router.util.type:Type
     *
     * @description
     * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the
     * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it
     * only needs to be a representation of `val` that has been coerced to a string.
     *
     * @param {*} val  The value to encode.
     * @param {string} key  The name of the parameter in which `val` is stored. Can be used for
     *        meta-programming of `Type` objects.
     * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.
     */
    Type.prototype.encode = function (val, key) {
        return val;
    };

    /**
     * @ngdoc function
     * @name ui.router.util.type:Type#decode
     * @methodOf ui.router.util.type:Type
     *
     * @description
     * Converts a parameter value (from URL string or transition param) to a custom/native value.
     *
     * @param {string} val  The URL parameter value to decode.
     * @param {string} key  The name of the parameter in which `val` is stored. Can be used for
     *        meta-programming of `Type` objects.
     * @returns {*}  Returns a custom representation of the URL parameter value.
     */
    Type.prototype.decode = function (val, key) {
        return val;
    };

    /**
     * @ngdoc function
     * @name ui.router.util.type:Type#equals
     * @methodOf ui.router.util.type:Type
     *
     * @description
     * Determines whether two decoded values are equivalent.
     *
     * @param {*} a  A value to compare against.
     * @param {*} b  A value to compare against.
     * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.
     */
    Type.prototype.equals = function (a, b) {
        return a == b;
    };

    Type.prototype.$subPattern = function () {
        var sub = this.pattern.toString();
        return sub.substr(1, sub.length - 2);
    };

    Type.prototype.pattern = /.*/;

    Type.prototype.toString = function () {
        return "{Type:" + this.name + "}";
    };

    /** Given an encoded string, or a decoded object, returns a decoded object */
    Type.prototype.$normalize = function (val) {
        return this.is(val) ? val : this.decode(val);
    };

    /*
     * Wraps an existing custom Type as an array of Type, depending on 'mode'.
     * e.g.:
     * - urlmatcher pattern "/path?{queryParam[]:int}"
     * - url: "/path?queryParam=1&queryParam=2
     * - $stateParams.queryParam will be [1, 2]
     * if `mode` is "auto", then
     * - url: "/path?queryParam=1 will create $stateParams.queryParam: 1
     * - url: "/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]
     */
    Type.prototype.$asArray = function (mode, isSearch) {
        if (!mode)
            return this;
        if (mode === "auto" && !isSearch)
            throw new Error("'auto' array mode is for query parameters only");

        function ArrayType(type, mode) {
            function bindTo(type, callbackName) {
                return function () {
                    return type[callbackName].apply(type, arguments);
                };
            }

            // Wrap non-array value as array
            function arrayWrap(val) {
                return isArray(val) ? val : (isDefined(val) ? [val] : []);
            }
            // Unwrap array value for "auto" mode. Return undefined for empty array.
            function arrayUnwrap(val) {
                switch (val.length) {
                    case 0:
                        return undefined;
                    case 1:
                        return mode === "auto" ? val[0] : val;
                    default:
                        return val;
                }
            }
            function falsey(val) {
                return !val;
            }

            // Wraps type (.is/.encode/.decode) functions to operate on each value of an array
            function arrayHandler(callback, allTruthyMode) {
                return function handleArray(val) {
                    val = arrayWrap(val);
                    var result = map(val, callback);
                    if (allTruthyMode === true)
                        return filter(result, falsey).length === 0;
                    return arrayUnwrap(result);
                };
            }

            // Wraps type (.equals) functions to operate on each value of an array
            function arrayEqualsHandler(callback) {
                return function handleArray(val1, val2) {
                    var left = arrayWrap(val1), right = arrayWrap(val2);
                    if (left.length !== right.length)
                        return false;
                    for (var i = 0; i < left.length; i++) {
                        if (!callback(left[i], right[i]))
                            return false;
                    }
                    return true;
                };
            }

            this.encode = arrayHandler(bindTo(type, 'encode'));
            this.decode = arrayHandler(bindTo(type, 'decode'));
            this.is = arrayHandler(bindTo(type, 'is'), true);
            this.equals = arrayEqualsHandler(bindTo(type, 'equals'));
            this.pattern = type.pattern;
            this.$normalize = arrayHandler(bindTo(type, '$normalize'));
            this.name = type.name;
            this.$arrayMode = mode;
        }

        return new ArrayType(this, mode);
    };



    /**
     * @ngdoc object
     * @name ui.router.util.$urlMatcherFactory
     *
     * @description
     * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory
     * is also available to providers under the name `$urlMatcherFactoryProvider`.
     */
    function $UrlMatcherFactory() {
        $$UMFP = this;

        var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;

        function valToString(val) {
            return val != null ? val.toString().replace(/\//g, "%2F") : val;
        }
        function valFromString(val) {
            return val != null ? val.toString().replace(/%2F/g, "/") : val;
        }

        var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {
            string: {
                encode: valToString,
                decode: valFromString,
                // TODO: in 1.0, make string .is() return false if value is undefined/null by default.
                // In 0.2.x, string params are optional by default for backwards compat
                is: function (val) {
                    return val == null || !isDefined(val) || typeof val === "string";
                },
                pattern: /[^/]*/
            },
            int: {
                encode: valToString,
                decode: function (val) {
                    return parseInt(val, 10);
                },
                is: function (val) {
                    return isDefined(val) && this.decode(val.toString()) === val;
                },
                pattern: /\d+/
            },
            bool: {
                encode: function (val) {
                    return val ? 1 : 0;
                },
                decode: function (val) {
                    return parseInt(val, 10) !== 0;
                },
                is: function (val) {
                    return val === true || val === false;
                },
                pattern: /0|1/
            },
            date: {
                encode: function (val) {
                    if (!this.is(val))
                        return undefined;
                    return [val.getFullYear(),
                        ('0' + (val.getMonth() + 1)).slice(-2),
                        ('0' + val.getDate()).slice(-2)
                    ].join("-");
                },
                decode: function (val) {
                    if (this.is(val))
                        return val;
                    var match = this.capture.exec(val);
                    return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
                },
                is: function (val) {
                    return val instanceof Date && !isNaN(val.valueOf());
                },
                equals: function (a, b) {
                    return this.is(a) && this.is(b) && a.toISOString() === b.toISOString();
                },
                pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
                capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
            },
            json: {
                encode: angular.toJson,
                decode: angular.fromJson,
                is: angular.isObject,
                equals: angular.equals,
                pattern: /[^/]*/
            },
            any: {// does not encode/decode
                encode: angular.identity,
                decode: angular.identity,
                equals: angular.equals,
                pattern: /.*/
            }
        };

        function getDefaultConfig() {
            return {
                strict: isStrictMode,
                caseInsensitive: isCaseInsensitive
            };
        }

        function isInjectable(value) {
            return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));
        }

        /**
         * [Internal] Get the default value of a parameter, which may be an injectable function.
         */
        $UrlMatcherFactory.$$getDefaultValue = function (config) {
            if (!isInjectable(config.value))
                return config.value;
            if (!injector)
                throw new Error("Injectable functions cannot be called at configuration time");
            return injector.invoke(config.value);
        };

        /**
         * @ngdoc function
         * @name ui.router.util.$urlMatcherFactory#caseInsensitive
         * @methodOf ui.router.util.$urlMatcherFactory
         *
         * @description
         * Defines whether URL matching should be case sensitive (the default behavior), or not.
         *
         * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;
         * @returns {boolean} the current value of caseInsensitive
         */
        this.caseInsensitive = function (value) {
            if (isDefined(value))
                isCaseInsensitive = value;
            return isCaseInsensitive;
        };

        /**
         * @ngdoc function
         * @name ui.router.util.$urlMatcherFactory#strictMode
         * @methodOf ui.router.util.$urlMatcherFactory
         *
         * @description
         * Defines whether URLs should match trailing slashes, or not (the default behavior).
         *
         * @param {boolean=} value `false` to match trailing slashes in URLs, otherwise `true`.
         * @returns {boolean} the current value of strictMode
         */
        this.strictMode = function (value) {
            if (isDefined(value))
                isStrictMode = value;
            return isStrictMode;
        };

        /**
         * @ngdoc function
         * @name ui.router.util.$urlMatcherFactory#defaultSquashPolicy
         * @methodOf ui.router.util.$urlMatcherFactory
         *
         * @description
         * Sets the default behavior when generating or matching URLs with default parameter values.
         *
         * @param {string} value A string that defines the default parameter URL squashing behavior.
         *    `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL
         *    `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the
         *             parameter is surrounded by slashes, squash (remove) one slash from the URL
         *    any other string, e.g. "~": When generating an href with a default parameter value, squash (remove)
         *             the parameter value from the URL and replace it with this string.
         */
        this.defaultSquashPolicy = function (value) {
            if (!isDefined(value))
                return defaultSquashPolicy;
            if (value !== true && value !== false && !isString(value))
                throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
            defaultSquashPolicy = value;
            return value;
        };

        /**
         * @ngdoc function
         * @name ui.router.util.$urlMatcherFactory#compile
         * @methodOf ui.router.util.$urlMatcherFactory
         *
         * @description
         * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.
         *
         * @param {string} pattern  The URL pattern.
         * @param {Object} config  The config object hash.
         * @returns {UrlMatcher}  The UrlMatcher.
         */
        this.compile = function (pattern, config) {
            return new UrlMatcher(pattern, extend(getDefaultConfig(), config));
        };

        /**
         * @ngdoc function
         * @name ui.router.util.$urlMatcherFactory#isMatcher
         * @methodOf ui.router.util.$urlMatcherFactory
         *
         * @description
         * Returns true if the specified object is a `UrlMatcher`, or false otherwise.
         *
         * @param {Object} object  The object to perform the type check against.
         * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by
         *          implementing all the same methods.
         */
        this.isMatcher = function (o) {
            if (!isObject(o))
                return false;
            var result = true;

            forEach(UrlMatcher.prototype, function (val, name) {
                if (isFunction(val)) {
                    result = result && (isDefined(o[name]) && isFunction(o[name]));
                }
            });
            return result;
        };

        /**
         * @ngdoc function
         * @name ui.router.util.$urlMatcherFactory#type
         * @methodOf ui.router.util.$urlMatcherFactory
         *
         * @description
         * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to
         * generate URLs with typed parameters.
         *
         * @param {string} name  The type name.
         * @param {Object|Function} definition   The type definition. See
         *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.
         * @param {Object|Function} definitionFn (optional) A function that is injected before the app
         *        runtime starts.  The result of this function is merged into the existing `definition`.
         *        See {@link ui.router.util.type:Type `Type`} for information on the values accepted.
         *
         * @returns {Object}  Returns `$urlMatcherFactoryProvider`.
         *
         * @example
         * This is a simple example of a custom type that encodes and decodes items from an
         * array, using the array index as the URL-encoded value:
         *
         * <pre>
         * var list = ['John', 'Paul', 'George', 'Ringo'];
         *
         * $urlMatcherFactoryProvider.type('listItem', {
         *   encode: function(item) {
         *     // Represent the list item in the URL using its corresponding index
         *     return list.indexOf(item);
         *   },
         *   decode: function(item) {
         *     // Look up the list item by index
         *     return list[parseInt(item, 10)];
         *   },
         *   is: function(item) {
         *     // Ensure the item is valid by checking to see that it appears
         *     // in the list
         *     return list.indexOf(item) > -1;
         *   }
         * });
         *
         * $stateProvider.state('list', {
         *   url: "/list/{item:listItem}",
         *   controller: function($scope, $stateParams) {
         *     console.log($stateParams.item);
         *   }
         * });
         *
         * // ...
         *
         * // Changes URL to '/list/3', logs "Ringo" to the console
         * $state.go('list', { item: "Ringo" });
         * </pre>
         *
         * This is a more complex example of a type that relies on dependency injection to
         * interact with services, and uses the parameter name from the URL to infer how to
         * handle encoding and decoding parameter values:
         *
         * <pre>
         * // Defines a custom type that gets a value from a service,
         * // where each service gets different types of values from
         * // a backend API:
         * $urlMatcherFactoryProvider.type('dbObject', {}, function(Users, Posts) {
         *
         *   // Matches up services to URL parameter names
         *   var services = {
         *     user: Users,
         *     post: Posts
         *   };
         *
         *   return {
         *     encode: function(object) {
         *       // Represent the object in the URL using its unique ID
         *       return object.id;
         *     },
         *     decode: function(value, key) {
         *       // Look up the object by ID, using the parameter
         *       // name (key) to call the correct service
         *       return services[key].findById(value);
         *     },
         *     is: function(object, key) {
         *       // Check that object is a valid dbObject
         *       return angular.isObject(object) && object.id && services[key];
         *     }
         *     equals: function(a, b) {
         *       // Check the equality of decoded objects by comparing
         *       // their unique IDs
         *       return a.id === b.id;
         *     }
         *   };
         * });
         *
         * // In a config() block, you can then attach URLs with
         * // type-annotated parameters:
         * $stateProvider.state('users', {
         *   url: "/users",
         *   // ...
         * }).state('users.item', {
         *   url: "/{user:dbObject}",
         *   controller: function($scope, $stateParams) {
         *     // $stateParams.user will now be an object returned from
         *     // the Users service
         *   },
         *   // ...
         * });
         * </pre>
         */
        this.type = function (name, definition, definitionFn) {
            if (!isDefined(definition))
                return $types[name];
            if ($types.hasOwnProperty(name))
                throw new Error("A type named '" + name + "' has already been defined.");

            $types[name] = new Type(extend({name: name}, definition));
            if (definitionFn) {
                typeQueue.push({name: name, def: definitionFn});
                if (!enqueue)
                    flushTypeQueue();
            }
            return this;
        };

        // `flushTypeQueue()` waits until `$urlMatcherFactory` is injected before invoking the queued `definitionFn`s
        function flushTypeQueue() {
            while (typeQueue.length) {
                var type = typeQueue.shift();
                if (type.pattern)
                    throw new Error("You cannot override a type's .pattern at runtime.");
                angular.extend($types[type.name], injector.invoke(type.def));
            }
        }

        // Register default types. Store them in the prototype of $types.
        forEach(defaultTypes, function (type, name) {
            $types[name] = new Type(extend({name: name}, type));
        });
        $types = inherit($types, {});

        /* No need to document $get, since it returns this */
        this.$get = ['$injector', function ($injector) {
                injector = $injector;
                enqueue = false;
                flushTypeQueue();

                forEach(defaultTypes, function (type, name) {
                    if (!$types[name])
                        $types[name] = new Type(type);
                });
                return this;
            }];

        this.Param = function Param(id, type, config, location) {
            var self = this;
            config = unwrapShorthand(config);
            type = getType(config, type, location);
            var arrayMode = getArrayMode();
            type = arrayMode ? type.$asArray(arrayMode, location === "search") : type;
            if (type.name === "string" && !arrayMode && location === "path" && config.value === undefined)
                config.value = ""; // for 0.2.x; in 0.3.0+ do not automatically default to ""
            var isOptional = config.value !== undefined;
            var squash = getSquashPolicy(config, isOptional);
            var replace = getReplace(config, arrayMode, isOptional, squash);

            function unwrapShorthand(config) {
                var keys = isObject(config) ? objectKeys(config) : [];
                var isShorthand = indexOf(keys, "value") === -1 && indexOf(keys, "type") === -1 &&
                        indexOf(keys, "squash") === -1 && indexOf(keys, "array") === -1;
                if (isShorthand)
                    config = {value: config};
                config.$$fn = isInjectable(config.value) ? config.value : function () {
                    return config.value;
                };
                return config;
            }

            function getType(config, urlType, location) {
                if (config.type && urlType)
                    throw new Error("Param '" + id + "' has two type configurations.");
                if (urlType)
                    return urlType;
                if (!config.type)
                    return (location === "config" ? $types.any : $types.string);
                return config.type instanceof Type ? config.type : new Type(config.type);
            }

            // array config: param name (param[]) overrides default settings.  explicit config overrides param name.
            function getArrayMode() {
                var arrayDefaults = {array: (location === "search" ? "auto" : false)};
                var arrayParamNomenclature = id.match(/\[\]$/) ? {array: true} : {};
                return extend(arrayDefaults, arrayParamNomenclature, config).array;
            }

            /**
             * returns false, true, or the squash value to indicate the "default parameter url squash policy".
             */
            function getSquashPolicy(config, isOptional) {
                var squash = config.squash;
                if (!isOptional || squash === false)
                    return false;
                if (!isDefined(squash) || squash == null)
                    return defaultSquashPolicy;
                if (squash === true || isString(squash))
                    return squash;
                throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
            }

            function getReplace(config, arrayMode, isOptional, squash) {
                var replace, configuredKeys, defaultPolicy = [
                    {from: "", to: (isOptional || arrayMode ? undefined : "")},
                    {from: null, to: (isOptional || arrayMode ? undefined : "")}
                ];
                replace = isArray(config.replace) ? config.replace : [];
                if (isString(squash))
                    replace.push({from: squash, to: undefined});
                configuredKeys = map(replace, function (item) {
                    return item.from;
                });
                return filter(defaultPolicy, function (item) {
                    return indexOf(configuredKeys, item.from) === -1;
                }).concat(replace);
            }

            /**
             * [Internal] Get the default value of a parameter, which may be an injectable function.
             */
            function $$getDefaultValue() {
                if (!injector)
                    throw new Error("Injectable functions cannot be called at configuration time");
                var defaultValue = injector.invoke(config.$$fn);
                if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))
                    throw new Error("Default value (" + defaultValue + ") for parameter '" + self.id + "' is not an instance of Type (" + self.type.name + ")");
                return defaultValue;
            }

            /**
             * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the
             * default value, which may be the result of an injectable function.
             */
            function $value(value) {
                function hasReplaceVal(val) {
                    return function (obj) {
                        return obj.from === val;
                    };
                }
                function $replace(value) {
                    var replacement = map(filter(self.replace, hasReplaceVal(value)), function (obj) {
                        return obj.to;
                    });
                    return replacement.length ? replacement[0] : value;
                }
                value = $replace(value);
                return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);
            }

            function toString() {
                return "{Param:" + id + " " + type + " squash: '" + squash + "' optional: " + isOptional + "}";
            }

            extend(this, {
                id: id,
                type: type,
                location: location,
                array: arrayMode,
                squash: squash,
                replace: replace,
                isOptional: isOptional,
                value: $value,
                dynamic: undefined,
                config: config,
                toString: toString
            });
        };

        function ParamSet(params) {
            extend(this, params || {});
        }

        ParamSet.prototype = {
            $$new: function () {
                return inherit(this, extend(new ParamSet(), {$$parent: this}));
            },
            $$keys: function () {
                var keys = [], chain = [], parent = this,
                        ignore = objectKeys(ParamSet.prototype);
                while (parent) {
                    chain.push(parent);
                    parent = parent.$$parent;
                }
                chain.reverse();
                forEach(chain, function (paramset) {
                    forEach(objectKeys(paramset), function (key) {
                        if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1)
                            keys.push(key);
                    });
                });
                return keys;
            },
            $$values: function (paramValues) {
                var values = {}, self = this;
                forEach(self.$$keys(), function (key) {
                    values[key] = self[key].value(paramValues && paramValues[key]);
                });
                return values;
            },
            $$equals: function (paramValues1, paramValues2) {
                var equal = true, self = this;
                forEach(self.$$keys(), function (key) {
                    var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];
                    if (!self[key].type.equals(left, right))
                        equal = false;
                });
                return equal;
            },
            $$validates: function $$validate(paramValues) {
                var keys = this.$$keys(), i, param, rawVal, normalized, encoded;
                for (i = 0; i < keys.length; i++) {
                    param = this[keys[i]];
                    rawVal = paramValues[keys[i]];
                    if ((rawVal === undefined || rawVal === null) && param.isOptional)
                        break; // There was no parameter value, but the param is optional
                    normalized = param.type.$normalize(rawVal);
                    if (!param.type.is(normalized))
                        return false; // The value was not of the correct Type, and could not be decoded to the correct Type
                    encoded = param.type.encode(normalized);
                    if (angular.isString(encoded) && !param.type.pattern.exec(encoded))
                        return false; // The value was of the correct type, but when encoded, did not match the Type's regexp
                }
                return true;
            },
            $$parent: undefined
        };

        this.ParamSet = ParamSet;
    }

// Register as a provider so it's available to other providers
    angular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);
    angular.module('ui.router.util').run(['$urlMatcherFactory', function ($urlMatcherFactory) { }]);

    /**
     * @ngdoc object
     * @name ui.router.router.$urlRouterProvider
     *
     * @requires ui.router.util.$urlMatcherFactoryProvider
     * @requires $locationProvider
     *
     * @description
     * `$urlRouterProvider` has the responsibility of watching `$location`.
     * When `$location` changes it runs through a list of rules one by one until a
     * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify
     * a url in a state configuration. All urls are compiled into a UrlMatcher object.
     *
     * There are several methods on `$urlRouterProvider` that make it useful to use directly
     * in your module config.
     */
    $UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];
    function $UrlRouterProvider($locationProvider, $urlMatcherFactory) {
        var rules = [], otherwise = null, interceptDeferred = false, listener;

        // Returns a string that is a prefix of all strings matching the RegExp
        function regExpPrefix(re) {
            var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
            return (prefix != null) ? prefix[1].replace(/\\(.)/g, "$1") : '';
        }

        // Interpolates matched values into a String.replace()-style pattern
        function interpolate(pattern, match) {
            return pattern.replace(/\$(\$|\d{1,2})/, function (m, what) {
                return match[what === '$' ? 0 : Number(what)];
            });
        }

        /**
         * @ngdoc function
         * @name ui.router.router.$urlRouterProvider#rule
         * @methodOf ui.router.router.$urlRouterProvider
         *
         * @description
         * Defines rules that are used by `$urlRouterProvider` to find matches for
         * specific URLs.
         *
         * @example
         * <pre>
         * var app = angular.module('app', ['ui.router.router']);
         *
         * app.config(function ($urlRouterProvider) {
         *   // Here's an example of how you might allow case insensitive urls
         *   $urlRouterProvider.rule(function ($injector, $location) {
         *     var path = $location.path(),
         *         normalized = path.toLowerCase();
         *
         *     if (path !== normalized) {
         *       return normalized;
         *     }
         *   });
         * });
         * </pre>
         *
         * @param {object} rule Handler function that takes `$injector` and `$location`
         * services as arguments. You can use them to return a valid path as a string.
         *
         * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance
         */
        this.rule = function (rule) {
            if (!isFunction(rule))
                throw new Error("'rule' must be a function");
            rules.push(rule);
            return this;
        };

        /**
         * @ngdoc object
         * @name ui.router.router.$urlRouterProvider#otherwise
         * @methodOf ui.router.router.$urlRouterProvider
         *
         * @description
         * Defines a path that is used when an invalid route is requested.
         *
         * @example
         * <pre>
         * var app = angular.module('app', ['ui.router.router']);
         *
         * app.config(function ($urlRouterProvider) {
         *   // if the path doesn't match any of the urls you configured
         *   // otherwise will take care of routing the user to the
         *   // specified url
         *   $urlRouterProvider.otherwise('/index');
         *
         *   // Example of using function rule as param
         *   $urlRouterProvider.otherwise(function ($injector, $location) {
         *     return '/a/valid/url';
         *   });
         * });
         * </pre>
         *
         * @param {string|object} rule The url path you want to redirect to or a function
         * rule that returns the url path. The function version is passed two params:
         * `$injector` and `$location` services, and must return a url string.
         *
         * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance
         */
        this.otherwise = function (rule) {
            if (isString(rule)) {
                var redirect = rule;
                rule = function () {
                    return redirect;
                };
            } else if (!isFunction(rule))
                throw new Error("'rule' must be a function");
            otherwise = rule;
            return this;
        };


        function handleIfMatch($injector, handler, match) {
            if (!match)
                return false;
            var result = $injector.invoke(handler, handler, {$match: match});
            return isDefined(result) ? result : true;
        }

        /**
         * @ngdoc function
         * @name ui.router.router.$urlRouterProvider#when
         * @methodOf ui.router.router.$urlRouterProvider
         *
         * @description
         * Registers a handler for a given url matching. if handle is a string, it is
         * treated as a redirect, and is interpolated according to the syntax of match
         * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).
         *
         * If the handler is a function, it is injectable. It gets invoked if `$location`
         * matches. You have the option of inject the match object as `$match`.
         *
         * The handler can return
         *
         * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`
         *   will continue trying to find another one that matches.
         * - **string** which is treated as a redirect and passed to `$location.url()`
         * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.
         *
         * @example
         * <pre>
         * var app = angular.module('app', ['ui.router.router']);
         *
         * app.config(function ($urlRouterProvider) {
         *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {
         *     if ($state.$current.navigable !== state ||
         *         !equalForKeys($match, $stateParams) {
         *      $state.transitionTo(state, $match, false);
         *     }
         *   });
         * });
         * </pre>
         *
         * @param {string|object} what The incoming path that you want to redirect.
         * @param {string|object} handler The path you want to redirect your user to.
         */
        this.when = function (what, handler) {
            var redirect, handlerIsString = isString(handler);
            if (isString(what))
                what = $urlMatcherFactory.compile(what);

            if (!handlerIsString && !isFunction(handler) && !isArray(handler))
                throw new Error("invalid 'handler' in when()");

            var strategies = {
                matcher: function (what, handler) {
                    if (handlerIsString) {
                        redirect = $urlMatcherFactory.compile(handler);
                        handler = ['$match', function ($match) {
                                return redirect.format($match);
                            }];
                    }
                    return extend(function ($injector, $location) {
                        return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
                    }, {
                        prefix: isString(what.prefix) ? what.prefix : ''
                    });
                },
                regex: function (what, handler) {
                    if (what.global || what.sticky)
                        throw new Error("when() RegExp must not be global or sticky");

                    if (handlerIsString) {
                        redirect = handler;
                        handler = ['$match', function ($match) {
                                return interpolate(redirect, $match);
                            }];
                    }
                    return extend(function ($injector, $location) {
                        return handleIfMatch($injector, handler, what.exec($location.path()));
                    }, {
                        prefix: regExpPrefix(what)
                    });
                }
            };

            var check = {matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp};

            for (var n in check) {
                if (check[n])
                    return this.rule(strategies[n](what, handler));
            }

            throw new Error("invalid 'what' in when()");
        };

        /**
         * @ngdoc function
         * @name ui.router.router.$urlRouterProvider#deferIntercept
         * @methodOf ui.router.router.$urlRouterProvider
         *
         * @description
         * Disables (or enables) deferring location change interception.
         *
         * If you wish to customize the behavior of syncing the URL (for example, if you wish to
         * defer a transition but maintain the current URL), call this method at configuration time.
         * Then, at run time, call `$urlRouter.listen()` after you have configured your own
         * `$locationChangeSuccess` event handler.
         *
         * @example
         * <pre>
         * var app = angular.module('app', ['ui.router.router']);
         *
         * app.config(function ($urlRouterProvider) {
         *
         *   // Prevent $urlRouter from automatically intercepting URL changes;
         *   // this allows you to configure custom behavior in between
         *   // location changes and route synchronization:
         *   $urlRouterProvider.deferIntercept();
         *
         * }).run(function ($rootScope, $urlRouter, UserService) {
         *
         *   $rootScope.$on('$locationChangeSuccess', function(e) {
         *     // UserService is an example service for managing user state
         *     if (UserService.isLoggedIn()) return;
         *
         *     // Prevent $urlRouter's default handler from firing
         *     e.preventDefault();
         *
         *     UserService.handleLogin().then(function() {
         *       // Once the user has logged in, sync the current URL
         *       // to the router:
         *       $urlRouter.sync();
         *     });
         *   });
         *
         *   // Configures $urlRouter's listener *after* your custom listener
         *   $urlRouter.listen();
         * });
         * </pre>
         *
         * @param {boolean} defer Indicates whether to defer location change interception. Passing
         no parameter is equivalent to `true`.
         */
        this.deferIntercept = function (defer) {
            if (defer === undefined)
                defer = true;
            interceptDeferred = defer;
        };

        /**
         * @ngdoc object
         * @name ui.router.router.$urlRouter
         *
         * @requires $location
         * @requires $rootScope
         * @requires $injector
         * @requires $browser
         *
         * @description
         *
         */
        this.$get = $get;
        $get.$inject = ['$location', '$rootScope', '$injector', '$browser'];
        function $get($location, $rootScope, $injector, $browser) {

            var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;

            function appendBasePath(url, isHtml5, absolute) {
                if (baseHref === '/')
                    return url;
                if (isHtml5)
                    return baseHref.slice(0, -1) + url;
                if (absolute)
                    return baseHref.slice(1) + url;
                return url;
            }

            // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree
            function update(evt) {
                if (evt && evt.defaultPrevented)
                    return;
                var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;
                lastPushedUrl = undefined;
                // TODO: Re-implement this in 1.0 for https://github.com/angular-ui/ui-router/issues/1573
                //if (ignoreUpdate) return true;

                function check(rule) {
                    var handled = rule($injector, $location);

                    if (!handled)
                        return false;
                    if (isString(handled))
                        $location.replace().url(handled);
                    return true;
                }
                var n = rules.length, i;

                for (i = 0; i < n; i++) {
                    if (check(rules[i]))
                        return;
                }
                // always check otherwise last to allow dynamic updates to the set of rules
                if (otherwise)
                    check(otherwise);
            }

            function listen() {
                listener = listener || $rootScope.$on('$locationChangeSuccess', update);
                return listener;
            }

            if (!interceptDeferred)
                listen();

            return {
                /**
                 * @ngdoc function
                 * @name ui.router.router.$urlRouter#sync
                 * @methodOf ui.router.router.$urlRouter
                 *
                 * @description
                 * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.
                 * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,
                 * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed
                 * with the transition by calling `$urlRouter.sync()`.
                 *
                 * @example
                 * <pre>
                 * angular.module('app', ['ui.router'])
                 *   .run(function($rootScope, $urlRouter) {
                 *     $rootScope.$on('$locationChangeSuccess', function(evt) {
                 *       // Halt state change from even starting
                 *       evt.preventDefault();
                 *       // Perform custom logic
                 *       var meetsRequirement = ...
                 *       // Continue with the update and state transition if logic allows
                 *       if (meetsRequirement) $urlRouter.sync();
                 *     });
                 * });
                 * </pre>
                 */
                sync: function () {
                    update();
                },
                listen: function () {
                    return listen();
                },
                update: function (read) {
                    if (read) {
                        location = $location.url();
                        return;
                    }
                    if ($location.url() === location)
                        return;

                    $location.url(location);
                    $location.replace();
                },
                push: function (urlMatcher, params, options) {
                    var url = urlMatcher.format(params || {});

                    // Handle the special hash param, if needed
                    if (url !== null && params && params['#']) {
                        url += '#' + params['#'];
                    }

                    $location.url(url);
                    lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;
                    if (options && options.replace)
                        $location.replace();
                },
                /**
                 * @ngdoc function
                 * @name ui.router.router.$urlRouter#href
                 * @methodOf ui.router.router.$urlRouter
                 *
                 * @description
                 * A URL generation method that returns the compiled URL for a given
                 * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.
                 *
                 * @example
                 * <pre>
                 * $bob = $urlRouter.href(new UrlMatcher("/about/:person"), {
                 *   person: "bob"
                 * });
                 * // $bob == "/about/bob";
                 * </pre>
                 *
                 * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.
                 * @param {object=} params An object of parameter values to fill the matcher's required parameters.
                 * @param {object=} options Options object. The options are:
                 *
                 * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. "http://www.example.com/fullurl".
                 *
                 * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`
                 */
                href: function (urlMatcher, params, options) {
                    if (!urlMatcher.validates(params))
                        return null;

                    var isHtml5 = $locationProvider.html5Mode();
                    if (angular.isObject(isHtml5)) {
                        isHtml5 = isHtml5.enabled;
                    }

                    var url = urlMatcher.format(params);
                    options = options || {};

                    if (!isHtml5 && url !== null) {
                        url = "#" + $locationProvider.hashPrefix() + url;
                    }

                    // Handle special hash param, if needed
                    if (url !== null && params && params['#']) {
                        url += '#' + params['#'];
                    }

                    url = appendBasePath(url, isHtml5, options.absolute);

                    if (!options.absolute || !url) {
                        return url;
                    }

                    var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();
                    port = (port === 80 || port === 443 ? '' : ':' + port);

                    return [$location.protocol(), '://', $location.host(), port, slash, url].join('');
                }
            };
        }
    }

    angular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);

    /**
     * @ngdoc object
     * @name ui.router.state.$stateProvider
     *
     * @requires ui.router.router.$urlRouterProvider
     * @requires ui.router.util.$urlMatcherFactoryProvider
     *
     * @description
     * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely
     * on state.
     *
     * A state corresponds to a "place" in the application in terms of the overall UI and
     * navigation. A state describes (via the controller / template / view properties) what
     * the UI looks like and does at that place.
     *
     * States often have things in common, and the primary way of factoring out these
     * commonalities in this model is via the state hierarchy, i.e. parent/child states aka
     * nested states.
     *
     * The `$stateProvider` provides interfaces to declare these states for your app.
     */
    $StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];
    function $StateProvider($urlRouterProvider, $urlMatcherFactory) {

        var root, states = {}, $state, queue = {}, abstractKey = 'abstract';

        // Builds state properties from definition passed to registerState()
        var stateBuilder = {
            // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.
            // state.children = [];
            // if (parent) parent.children.push(state);
            parent: function (state) {
                if (isDefined(state.parent) && state.parent)
                    return findState(state.parent);
                // regex matches any valid composite state name
                // would match "contact.list" but not "contacts"
                var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
                return compositeName ? findState(compositeName[1]) : root;
            },
            // inherit 'data' from parent and override by own values (if any)
            data: function (state) {
                if (state.parent && state.parent.data) {
                    state.data = state.self.data = extend({}, state.parent.data, state.data);
                }
                return state.data;
            },
            // Build a URLMatcher if necessary, either via a relative or absolute URL
            url: function (state) {
                var url = state.url, config = {params: state.params || {}};

                if (isString(url)) {
                    if (url.charAt(0) == '^')
                        return $urlMatcherFactory.compile(url.substring(1), config);
                    return (state.parent.navigable || root).url.concat(url, config);
                }

                if (!url || $urlMatcherFactory.isMatcher(url))
                    return url;
                throw new Error("Invalid url '" + url + "' in state '" + state + "'");
            },
            // Keep track of the closest ancestor state that has a URL (i.e. is navigable)
            navigable: function (state) {
                return state.url ? state : (state.parent ? state.parent.navigable : null);
            },
            // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params
            ownParams: function (state) {
                var params = state.url && state.url.params || new $$UMFP.ParamSet();
                forEach(state.params || {}, function (config, id) {
                    if (!params[id])
                        params[id] = new $$UMFP.Param(id, null, config, "config");
                });
                return params;
            },
            // Derive parameters for this state and ensure they're a super-set of parent's parameters
            params: function (state) {
                return state.parent && state.parent.params ? extend(state.parent.params.$$new(), state.ownParams) : new $$UMFP.ParamSet();
            },
            // If there is no explicit multi-view configuration, make one up so we don't have
            // to handle both cases in the view directive later. Note that having an explicit
            // 'views' property will mean the default unnamed view properties are ignored. This
            // is also a good time to resolve view names to absolute names, so everything is a
            // straight lookup at link time.
            views: function (state) {
                var views = {};

                forEach(isDefined(state.views) ? state.views : {'': state}, function (view, name) {
                    if (name.indexOf('@') < 0)
                        name += '@' + state.parent.name;
                    views[name] = view;
                });
                return views;
            },
            // Keep a full path from the root down to this state as this is needed for state activation.
            path: function (state) {
                return state.parent ? state.parent.path.concat(state) : []; // exclude root from path
            },
            // Speed up $state.contains() as it's used a lot
            includes: function (state) {
                var includes = state.parent ? extend({}, state.parent.includes) : {};
                includes[state.name] = true;
                return includes;
            },
            $delegates: {}
        };

        function isRelative(stateName) {
            return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
        }

        function findState(stateOrName, base) {
            if (!stateOrName)
                return undefined;

            var isStr = isString(stateOrName),
                    name = isStr ? stateOrName : stateOrName.name,
                    path = isRelative(name);

            if (path) {
                if (!base)
                    throw new Error("No reference point given for path '" + name + "'");
                base = findState(base);

                var rel = name.split("."), i = 0, pathLength = rel.length, current = base;

                for (; i < pathLength; i++) {
                    if (rel[i] === "" && i === 0) {
                        current = base;
                        continue;
                    }
                    if (rel[i] === "^") {
                        if (!current.parent)
                            throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
                        current = current.parent;
                        continue;
                    }
                    break;
                }
                rel = rel.slice(i).join(".");
                name = current.name + (current.name && rel ? "." : "") + rel;
            }
            var state = states[name];

            if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {
                return state;
            }
            return undefined;
        }

        function queueState(parentName, state) {
            if (!queue[parentName]) {
                queue[parentName] = [];
            }
            queue[parentName].push(state);
        }

        function flushQueuedChildren(parentName) {
            var queued = queue[parentName] || [];
            while (queued.length) {
                registerState(queued.shift());
            }
        }

        function registerState(state) {
            // Wrap a new object around the state so we can store our private details easily.
            state = inherit(state, {
                self: state,
                resolve: state.resolve || {},
                toString: function () {
                    return this.name;
                }
            });

            var name = state.name;
            if (!isString(name) || name.indexOf('@') >= 0)
                throw new Error("State must have a valid name");
            if (states.hasOwnProperty(name))
                throw new Error("State '" + name + "'' is already defined");

            // Get parent name
            var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))
                    : (isString(state.parent)) ? state.parent
                    : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name
                    : '';

            // If parent is not registered yet, add state to queue and register later
            if (parentName && !states[parentName]) {
                return queueState(parentName, state.self);
            }

            for (var key in stateBuilder) {
                if (isFunction(stateBuilder[key]))
                    state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);
            }
            states[name] = state;

            // Register the state in the global state list and with $urlRouter if necessary.
            if (!state[abstractKey] && state.url) {
                $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {
                        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {
                            $state.transitionTo(state, $match, {inherit: true, location: false});
                        }
                    }]);
            }

            // Register any queued children
            flushQueuedChildren(name);

            return state;
        }

        // Checks text to see if it looks like a glob.
        function isGlob(text) {
            return text.indexOf('*') > -1;
        }

        // Returns true if glob matches current $state name.
        function doesStateMatchGlob(glob) {
            var globSegments = glob.split('.'),
                    segments = $state.$current.name.split('.');

            //match single stars
            for (var i = 0, l = globSegments.length; i < l; i++) {
                if (globSegments[i] === '*') {
                    segments[i] = '*';
                }
            }

            //match greedy starts
            if (globSegments[0] === '**') {
                segments = segments.slice(indexOf(segments, globSegments[1]));
                segments.unshift('**');
            }
            //match greedy ends
            if (globSegments[globSegments.length - 1] === '**') {
                segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);
                segments.push('**');
            }

            if (globSegments.length != segments.length) {
                return false;
            }

            return segments.join('') === globSegments.join('');
        }


        // Implicit root state that is always active
        root = registerState({
            name: '',
            url: '^',
            views: null,
            'abstract': true
        });
        root.navigable = null;


        /**
         * @ngdoc function
         * @name ui.router.state.$stateProvider#decorator
         * @methodOf ui.router.state.$stateProvider
         *
         * @description
         * Allows you to extend (carefully) or override (at your own peril) the
         * `stateBuilder` object used internally by `$stateProvider`. This can be used
         * to add custom functionality to ui-router, for example inferring templateUrl
         * based on the state name.
         *
         * When passing only a name, it returns the current (original or decorated) builder
         * function that matches `name`.
         *
         * The builder functions that can be decorated are listed below. Though not all
         * necessarily have a good use case for decoration, that is up to you to decide.
         *
         * In addition, users can attach custom decorators, which will generate new
         * properties within the state's internal definition. There is currently no clear
         * use-case for this beyond accessing internal states (i.e. $state.$current),
         * however, expect this to become increasingly relevant as we introduce additional
         * meta-programming features.
         *
         * **Warning**: Decorators should not be interdependent because the order of
         * execution of the builder functions in non-deterministic. Builder functions
         * should only be dependent on the state definition object and super function.
         *
         *
         * Existing builder functions and current return values:
         *
         * - **parent** `{object}` - returns the parent state object.
         * - **data** `{object}` - returns state data, including any inherited data that is not
         *   overridden by own values (if any).
         * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}
         *   or `null`.
         * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is
         *   navigable).
         * - **params** `{object}` - returns an array of state params that are ensured to
         *   be a super-set of parent's params.
         * - **views** `{object}` - returns a views object where each key is an absolute view
         *   name (i.e. "viewName@stateName") and each value is the config object
         *   (template, controller) for the view. Even when you don't use the views object
         *   explicitly on a state config, one is still created for you internally.
         *   So by decorating this builder function you have access to decorating template
         *   and controller properties.
         * - **ownParams** `{object}` - returns an array of params that belong to the state,
         *   not including any params defined by ancestor states.
         * - **path** `{string}` - returns the full path from the root down to this state.
         *   Needed for state activation.
         * - **includes** `{object}` - returns an object that includes every state that
         *   would pass a `$state.includes()` test.
         *
         * @example
         * <pre>
         * // Override the internal 'views' builder with a function that takes the state
         * // definition, and a reference to the internal function being overridden:
         * $stateProvider.decorator('views', function (state, parent) {
         *   var result = {},
         *       views = parent(state);
         *
         *   angular.forEach(views, function (config, name) {
         *     var autoName = (state.name + '.' + name).replace('.', '/');
         *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';
         *     result[name] = config;
         *   });
         *   return result;
         * });
         *
         * $stateProvider.state('home', {
         *   views: {
         *     'contact.list': { controller: 'ListController' },
         *     'contact.item': { controller: 'ItemController' }
         *   }
         * });
         *
         * // ...
         *
         * $state.go('home');
         * // Auto-populates list and item views with /partials/home/contact/list.html,
         * // and /partials/home/contact/item.html, respectively.
         * </pre>
         *
         * @param {string} name The name of the builder function to decorate.
         * @param {object} func A function that is responsible for decorating the original
         * builder function. The function receives two parameters:
         *
         *   - `{object}` - state - The state config object.
         *   - `{object}` - super - The original builder function.
         *
         * @return {object} $stateProvider - $stateProvider instance
         */
        this.decorator = decorator;
        function decorator(name, func) {
            /*jshint validthis: true */
            if (isString(name) && !isDefined(func)) {
                return stateBuilder[name];
            }
            if (!isFunction(func) || !isString(name)) {
                return this;
            }
            if (stateBuilder[name] && !stateBuilder.$delegates[name]) {
                stateBuilder.$delegates[name] = stateBuilder[name];
            }
            stateBuilder[name] = func;
            return this;
        }

        /**
         * @ngdoc function
         * @name ui.router.state.$stateProvider#state
         * @methodOf ui.router.state.$stateProvider
         *
         * @description
         * Registers a state configuration under a given state name. The stateConfig object
         * has the following acceptable properties.
         *
         * @param {string} name A unique state name, e.g. "home", "about", "contacts".
         * To create a parent/child state use a dot, e.g. "about.sales", "home.newest".
         * @param {object} stateConfig State configuration object.
         * @param {string|function=} stateConfig.template
         * <a id='template'></a>
         *   html template as a string or a function that returns
         *   an html template as a string which should be used by the uiView directives. This property
         *   takes precedence over templateUrl.
         *
         *   If `template` is a function, it will be called with the following parameters:
         *
         *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by
         *     applying the current state
         *
         * <pre>template:
         *   "<h1>inline template definition</h1>" +
         *   "<div ui-view></div>"</pre>
         * <pre>template: function(params) {
         *       return "<h1>generated template</h1>"; }</pre>
         * </div>
         *
         * @param {string|function=} stateConfig.templateUrl
         * <a id='templateUrl'></a>
         *
         *   path or function that returns a path to an html
         *   template that should be used by uiView.
         *
         *   If `templateUrl` is a function, it will be called with the following parameters:
         *
         *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by
         *     applying the current state
         *
         * <pre>templateUrl: "home.html"</pre>
         * <pre>templateUrl: function(params) {
         *     return myTemplates[params.pageId]; }</pre>
         *
         * @param {function=} stateConfig.templateProvider
         * <a id='templateProvider'></a>
         *    Provider function that returns HTML content string.
         * <pre> templateProvider:
         *       function(MyTemplateService, params) {
         *         return MyTemplateService.getTemplate(params.pageId);
         *       }</pre>
         *
         * @param {string|function=} stateConfig.controller
         * <a id='controller'></a>
         *
         *  Controller fn that should be associated with newly
         *   related scope or the name of a registered controller if passed as a string.
         *   Optionally, the ControllerAs may be declared here.
         * <pre>controller: "MyRegisteredController"</pre>
         * <pre>controller:
         *     "MyRegisteredController as fooCtrl"}</pre>
         * <pre>controller: function($scope, MyService) {
         *     $scope.data = MyService.getData(); }</pre>
         *
         * @param {function=} stateConfig.controllerProvider
         * <a id='controllerProvider'></a>
         *
         * Injectable provider function that returns the actual controller or string.
         * <pre>controllerProvider:
         *   function(MyResolveData) {
         *     if (MyResolveData.foo)
         *       return "FooCtrl"
         *     else if (MyResolveData.bar)
         *       return "BarCtrl";
         *     else return function($scope) {
         *       $scope.baz = "Qux";
         *     }
         *   }</pre>
         *
         * @param {string=} stateConfig.controllerAs
         * <a id='controllerAs'></a>
         *
         * A controller alias name. If present the controller will be
         *   published to scope under the controllerAs name.
         * <pre>controllerAs: "myCtrl"</pre>
         *
         * @param {string|object=} stateConfig.parent
         * <a id='parent'></a>
         * Optionally specifies the parent state of this state.
         *
         * <pre>parent: 'parentState'</pre>
         * <pre>parent: parentState // JS variable</pre>
         *
         * @param {object=} stateConfig.resolve
         * <a id='resolve'></a>
         *
         * An optional map&lt;string, function&gt; of dependencies which
         *   should be injected into the controller. If any of these dependencies are promises,
         *   the router will wait for them all to be resolved before the controller is instantiated.
         *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired
         *   and the values of the resolved promises are injected into any controllers that reference them.
         *   If any  of the promises are rejected the $stateChangeError event is fired.
         *
         *   The map object is:
         *
         *   - key - {string}: name of dependency to be injected into controller
         *   - factory - {string|function}: If string then it is alias for service. Otherwise if function,
         *     it is injected and return value it treated as dependency. If result is a promise, it is
         *     resolved before its value is injected into controller.
         *
         * <pre>resolve: {
         *     myResolve1:
         *       function($http, $stateParams) {
         *         return $http.get("/api/foos/"+stateParams.fooID);
         *       }
         *     }</pre>
         *
         * @param {string=} stateConfig.url
         * <a id='url'></a>
         *
         *   A url fragment with optional parameters. When a state is navigated or
         *   transitioned to, the `$stateParams` service will be populated with any
         *   parameters that were passed.
         *
         *   (See {@link ui.router.util.type:UrlMatcher UrlMatcher} `UrlMatcher`} for
         *   more details on acceptable patterns )
         *
         * examples:
         * <pre>url: "/home"
         * url: "/users/:userid"
         * url: "/books/{bookid:[a-zA-Z_-]}"
         * url: "/books/{categoryid:int}"
         * url: "/books/{publishername:string}/{categoryid:int}"
         * url: "/messages?before&after"
         * url: "/messages?{before:date}&{after:date}"
         * url: "/messages/:mailboxid?{before:date}&{after:date}"
         * </pre>
         *
         * @param {object=} stateConfig.views
         * <a id='views'></a>
         * an optional map&lt;string, object&gt; which defined multiple views, or targets views
         * manually/explicitly.
         *
         * Examples:
         *
         * Targets three named `ui-view`s in the parent state's template
         * <pre>views: {
         *     header: {
         *       controller: "headerCtrl",
         *       templateUrl: "header.html"
         *     }, body: {
         *       controller: "bodyCtrl",
         *       templateUrl: "body.html"
         *     }, footer: {
         *       controller: "footCtrl",
         *       templateUrl: "footer.html"
         *     }
         *   }</pre>
         *
         * Targets named `ui-view="header"` from grandparent state 'top''s template, and named `ui-view="body" from parent state's template.
         * <pre>views: {
         *     'header@top': {
         *       controller: "msgHeaderCtrl",
         *       templateUrl: "msgHeader.html"
         *     }, 'body': {
         *       controller: "messagesCtrl",
         *       templateUrl: "messages.html"
         *     }
         *   }</pre>
         *
         * @param {boolean=} [stateConfig.abstract=false]
         * <a id='abstract'></a>
         * An abstract state will never be directly activated,
         *   but can provide inherited properties to its common children states.
         * <pre>abstract: true</pre>
         *
         * @param {function=} stateConfig.onEnter
         * <a id='onEnter'></a>
         *
         * Callback function for when a state is entered. Good way
         *   to trigger an action or dispatch an event, such as opening a dialog.
         * If minifying your scripts, make sure to explictly annotate this function,
         * because it won't be automatically annotated by your build tools.
         *
         * <pre>onEnter: function(MyService, $stateParams) {
         *     MyService.foo($stateParams.myParam);
         * }</pre>
         *
         * @param {function=} stateConfig.onExit
         * <a id='onExit'></a>
         *
         * Callback function for when a state is exited. Good way to
         *   trigger an action or dispatch an event, such as opening a dialog.
         * If minifying your scripts, make sure to explictly annotate this function,
         * because it won't be automatically annotated by your build tools.
         *
         * <pre>onExit: function(MyService, $stateParams) {
         *     MyService.cleanup($stateParams.myParam);
         * }</pre>
         *
         * @param {boolean=} [stateConfig.reloadOnSearch=true]
         * <a id='reloadOnSearch'></a>
         *
         * If `false`, will not retrigger the same state
         *   just because a search/query parameter has changed (via $location.search() or $location.hash()).
         *   Useful for when you'd like to modify $location.search() without triggering a reload.
         * <pre>reloadOnSearch: false</pre>
         *
         * @param {object=} stateConfig.data
         * <a id='data'></a>
         *
         * Arbitrary data object, useful for custom configuration.  The parent state's `data` is
         *   prototypally inherited.  In other words, adding a data property to a state adds it to
         *   the entire subtree via prototypal inheritance.
         *
         * <pre>data: {
         *     requiredRole: 'foo'
         * } </pre>
         *
         * @param {object=} stateConfig.params
         * <a id='params'></a>
         *
         * A map which optionally configures parameters declared in the `url`, or
         *   defines additional non-url parameters.  For each parameter being
         *   configured, add a configuration object keyed to the name of the parameter.
         *
         *   Each parameter configuration object may contain the following properties:
         *
         *   - ** value ** - {object|function=}: specifies the default value for this
         *     parameter.  This implicitly sets this parameter as optional.
         *
         *     When UI-Router routes to a state and no value is
         *     specified for this parameter in the URL or transition, the
         *     default value will be used instead.  If `value` is a function,
         *     it will be injected and invoked, and the return value used.
         *
         *     *Note*: `undefined` is treated as "no default value" while `null`
         *     is treated as "the default value is `null`".
         *
         *     *Shorthand*: If you only need to configure the default value of the
         *     parameter, you may use a shorthand syntax.   In the **`params`**
         *     map, instead mapping the param name to a full parameter configuration
         *     object, simply set map it to the default parameter value, e.g.:
         *
         * <pre>// define a parameter's default value
         * params: {
         *     param1: { value: "defaultValue" }
         * }
         * // shorthand default values
         * params: {
         *     param1: "defaultValue",
         *     param2: "param2Default"
         * }</pre>
         *
         *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be
         *     treated as an array of values.  If you specified a Type, the value will be
         *     treated as an array of the specified Type.  Note: query parameter values
         *     default to a special `"auto"` mode.
         *
         *     For query parameters in `"auto"` mode, if multiple  values for a single parameter
         *     are present in the URL (e.g.: `/foo?bar=1&bar=2&bar=3`) then the values
         *     are mapped to an array (e.g.: `{ foo: [ '1', '2', '3' ] }`).  However, if
         *     only one value is present (e.g.: `/foo?bar=1`) then the value is treated as single
         *     value (e.g.: `{ foo: '1' }`).
         *
         * <pre>params: {
         *     param1: { array: true }
         * }</pre>
         *
         *   - ** squash ** - {bool|string=}: `squash` configures how a default parameter value is represented in the URL when
         *     the current parameter value is the same as the default value. If `squash` is not set, it uses the
         *     configured default squash policy.
         *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy `defaultSquashPolicy()`})
         *
         *   There are three squash settings:
         *
         *     - false: The parameter's default value is not squashed.  It is encoded and included in the URL
         *     - true: The parameter's default value is omitted from the URL.  If the parameter is preceeded and followed
         *       by slashes in the state's `url` declaration, then one of those slashes are omitted.
         *       This can allow for cleaner looking URLs.
         *     - `"<arbitrary string>"`: The parameter's default value is replaced with an arbitrary placeholder of  your choice.
         *
         * <pre>params: {
         *     param1: {
         *       value: "defaultId",
         *       squash: true
         * } }
         * // squash "defaultValue" to "~"
         * params: {
         *     param1: {
         *       value: "defaultValue",
         *       squash: "~"
         * } }
         * </pre>
         *
         *
         * @example
         * <pre>
         * // Some state name examples
         *
         * // stateName can be a single top-level name (must be unique).
         * $stateProvider.state("home", {});
         *
         * // Or it can be a nested state name. This state is a child of the
         * // above "home" state.
         * $stateProvider.state("home.newest", {});
         *
         * // Nest states as deeply as needed.
         * $stateProvider.state("home.newest.abc.xyz.inception", {});
         *
         * // state() returns $stateProvider, so you can chain state declarations.
         * $stateProvider
         *   .state("home", {})
         *   .state("about", {})
         *   .state("contacts", {});
         * </pre>
         *
         */
        this.state = state;
        function state(name, definition) {
            /*jshint validthis: true */
            if (isObject(name))
                definition = name;
            else
                definition.name = name;
            registerState(definition);
            return this;
        }

        /**
         * @ngdoc object
         * @name ui.router.state.$state
         *
         * @requires $rootScope
         * @requires $q
         * @requires ui.router.state.$view
         * @requires $injector
         * @requires ui.router.util.$resolve
         * @requires ui.router.state.$stateParams
         * @requires ui.router.router.$urlRouter
         *
         * @property {object} params A param object, e.g. {sectionId: section.id)}, that
         * you'd like to test against the current active state.
         * @property {object} current A reference to the state's config object. However
         * you passed it in. Useful for accessing custom data.
         * @property {object} transition Currently pending transition. A promise that'll
         * resolve or reject.
         *
         * @description
         * `$state` service is responsible for representing states as well as transitioning
         * between them. It also provides interfaces to ask for current state or even states
         * you're coming from.
         */
        this.$get = $get;
        $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];
        function $get($rootScope, $q, $view, $injector, $resolve, $stateParams, $urlRouter, $location, $urlMatcherFactory) {

            var TransitionSuperseded = $q.reject(new Error('transition superseded'));
            var TransitionPrevented = $q.reject(new Error('transition prevented'));
            var TransitionAborted = $q.reject(new Error('transition aborted'));
            var TransitionFailed = $q.reject(new Error('transition failed'));

            // Handles the case where a state which is the target of a transition is not found, and the user
            // can optionally retry or defer the transition
            function handleRedirect(redirect, state, params, options) {
                /**
                 * @ngdoc event
                 * @name ui.router.state.$state#$stateNotFound
                 * @eventOf ui.router.state.$state
                 * @eventType broadcast on root scope
                 * @description
                 * Fired when a requested state **cannot be found** using the provided state name during transition.
                 * The event is broadcast allowing any handlers a single chance to deal with the error (usually by
                 * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,
                 * you can see its three properties in the example. You can use `event.preventDefault()` to abort the
                 * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.
                 *
                 * @param {Object} event Event object.
                 * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.
                 * @param {State} fromState Current state object.
                 * @param {Object} fromParams Current state params.
                 *
                 * @example
                 *
                 * <pre>
                 * // somewhere, assume lazy.state has not been defined
                 * $state.go("lazy.state", {a:1, b:2}, {inherit:false});
                 *
                 * // somewhere else
                 * $scope.$on('$stateNotFound',
                 * function(event, unfoundState, fromState, fromParams){
                 *     console.log(unfoundState.to); // "lazy.state"
                 *     console.log(unfoundState.toParams); // {a:1, b:2}
                 *     console.log(unfoundState.options); // {inherit:false} + default options
                 * })
                 * </pre>
                 */
                var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);

                if (evt.defaultPrevented) {
                    $urlRouter.update();
                    return TransitionAborted;
                }

                if (!evt.retry) {
                    return null;
                }

                // Allow the handler to return a promise to defer state lookup retry
                if (options.$retry) {
                    $urlRouter.update();
                    return TransitionFailed;
                }
                var retryTransition = $state.transition = $q.when(evt.retry);

                retryTransition.then(function () {
                    if (retryTransition !== $state.transition)
                        return TransitionSuperseded;
                    redirect.options.$retry = true;
                    return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);
                }, function () {
                    return TransitionAborted;
                });
                $urlRouter.update();

                return retryTransition;
            }

            root.locals = {resolve: null, globals: {$stateParams: {}}};

            $state = {
                params: {},
                current: root.self,
                $current: root,
                transition: null
            };

            /**
             * @ngdoc function
             * @name ui.router.state.$state#reload
             * @methodOf ui.router.state.$state
             *
             * @description
             * A method that force reloads the current state. All resolves are re-resolved,
             * controllers reinstantiated, and events re-fired.
             *
             * @example
             * <pre>
             * var app angular.module('app', ['ui.router']);
             *
             * app.controller('ctrl', function ($scope, $state) {
             *   $scope.reload = function(){
             *     $state.reload();
             *   }
             * });
             * </pre>
             *
             * `reload()` is just an alias for:
             * <pre>
             * $state.transitionTo($state.current, $stateParams, {
             *   reload: true, inherit: false, notify: true
             * });
             * </pre>
             *
             * @param {string=|object=} state - A state name or a state object, which is the root of the resolves to be re-resolved.
             * @example
             * <pre>
             * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item'
             * //and current state is 'contacts.detail.item'
             * var app angular.module('app', ['ui.router']);
             *
             * app.controller('ctrl', function ($scope, $state) {
             *   $scope.reload = function(){
             *     //will reload 'contact.detail' and 'contact.detail.item' states
             *     $state.reload('contact.detail');
             *   }
             * });
             * </pre>
             *
             * `reload()` is just an alias for:
             * <pre>
             * $state.transitionTo($state.current, $stateParams, {
             *   reload: true, inherit: false, notify: true
             * });
             * </pre>

             * @returns {promise} A promise representing the state of the new transition. See
             * {@link ui.router.state.$state#methods_go $state.go}.
             */
            $state.reload = function reload(state) {
                return $state.transitionTo($state.current, $stateParams, {reload: state || true, inherit: false, notify: true});
            };

            /**
             * @ngdoc function
             * @name ui.router.state.$state#go
             * @methodOf ui.router.state.$state
             *
             * @description
             * Convenience method for transitioning to a new state. `$state.go` calls
             * `$state.transitionTo` internally but automatically sets options to
             * `{ location: true, inherit: true, relative: $state.$current, notify: true }`.
             * This allows you to easily use an absolute or relative to path and specify
             * only the parameters you'd like to update (while letting unspecified parameters
             * inherit from the currently active ancestor states).
             *
             * @example
             * <pre>
             * var app = angular.module('app', ['ui.router']);
             *
             * app.controller('ctrl', function ($scope, $state) {
             *   $scope.changeState = function () {
             *     $state.go('contact.detail');
             *   };
             * });
             * </pre>
             * <img src='../ngdoc_assets/StateGoExamples.png'/>
             *
             * @param {string} to Absolute state name or relative state path. Some examples:
             *
             * - `$state.go('contact.detail')` - will go to the `contact.detail` state
             * - `$state.go('^')` - will go to a parent state
             * - `$state.go('^.sibling')` - will go to a sibling state
             * - `$state.go('.child.grandchild')` - will go to grandchild state
             *
             * @param {object=} params A map of the parameters that will be sent to the state,
             * will populate $stateParams. Any parameters that are not specified will be inherited from currently
             * defined parameters. This allows, for example, going to a sibling state that shares parameters
             * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.
             * transitioning to a sibling will get you the parameters for all parents, transitioning to a child
             * will get you all current parameters, etc.
             * @param {object=} options Options object. The options are:
             *
             * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`
             *    will not. If string, must be `"replace"`, which will update url and also replace last history record.
             * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.
             * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'),
             *    defines which state to be relative from.
             * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.
             * - **`reload`** (v0.2.5) - {boolean=false}, If `true` will force transition even if the state or params
             *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd
             *    use this when you want to force a reload when *everything* is the same, including search params.
             *
             * @returns {promise} A promise representing the state of the new transition.
             *
             * Possible success values:
             *
             * - $state.current
             *
             * <br/>Possible rejection values:
             *
             * - 'transition superseded' - when a newer transition has been started after this one
             * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener
             * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or
             *   when a `$stateNotFound` `event.retry` promise errors.
             * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.
             * - *resolve error* - when an error has occurred with a `resolve`
             *
             */
            $state.go = function go(to, params, options) {
                return $state.transitionTo(to, params, extend({inherit: true, relative: $state.$current}, options));
            };

            /**
             * @ngdoc function
             * @name ui.router.state.$state#transitionTo
             * @methodOf ui.router.state.$state
             *
             * @description
             * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}
             * uses `transitionTo` internally. `$state.go` is recommended in most situations.
             *
             * @example
             * <pre>
             * var app = angular.module('app', ['ui.router']);
             *
             * app.controller('ctrl', function ($scope, $state) {
             *   $scope.changeState = function () {
             *     $state.transitionTo('contact.detail');
             *   };
             * });
             * </pre>
             *
             * @param {string} to State name.
             * @param {object=} toParams A map of the parameters that will be sent to the state,
             * will populate $stateParams.
             * @param {object=} options Options object. The options are:
             *
             * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`
             *    will not. If string, must be `"replace"`, which will update url and also replace last history record.
             * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.
             * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'),
             *    defines which state to be relative from.
             * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.
             * - **`reload`** (v0.2.5) - {boolean=false|string=|object=}, If `true` will force transition even if the state or params
             *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd
             *    use this when you want to force a reload when *everything* is the same, including search params.
             *    if String, then will reload the state with the name given in reload, and any children.
             *    if Object, then a stateObj is expected, will reload the state found in stateObj, and any children.
             *
             * @returns {promise} A promise representing the state of the new transition. See
             * {@link ui.router.state.$state#methods_go $state.go}.
             */
            $state.transitionTo = function transitionTo(to, toParams, options) {
                toParams = toParams || {};
                options = extend({
                    location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false
                }, options || {});

                var from = $state.$current, fromParams = $state.params, fromPath = from.path;
                var evt, toState = findState(to, options.relative);

                // Store the hash param for later (since it will be stripped out by various methods)
                var hash = toParams['#'];

                if (!isDefined(toState)) {
                    var redirect = {to: to, toParams: toParams, options: options};
                    var redirectResult = handleRedirect(redirect, from.self, fromParams, options);

                    if (redirectResult) {
                        return redirectResult;
                    }

                    // Always retry once if the $stateNotFound was not prevented
                    // (handles either redirect changed or state lazy-definition)
                    to = redirect.to;
                    toParams = redirect.toParams;
                    options = redirect.options;
                    toState = findState(to, options.relative);

                    if (!isDefined(toState)) {
                        if (!options.relative)
                            throw new Error("No such state '" + to + "'");
                        throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'");
                    }
                }
                if (toState[abstractKey])
                    throw new Error("Cannot transition to abstract state '" + to + "'");
                if (options.inherit)
                    toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);
                if (!toState.params.$$validates(toParams))
                    return TransitionFailed;

                toParams = toState.params.$$values(toParams);
                to = toState;

                var toPath = to.path;

                // Starting from the root of the path, keep all levels that haven't changed
                var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];

                if (!options.reload) {
                    while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {
                        locals = toLocals[keep] = state.locals;
                        keep++;
                        state = toPath[keep];
                    }
                } else if (isString(options.reload) || isObject(options.reload)) {
                    if (isObject(options.reload) && !options.reload.name) {
                        throw new Error('Invalid reload state object');
                    }

                    var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);
                    if (options.reload && !reloadState) {
                        throw new Error("No such reload state '" + (isString(options.reload) ? options.reload : options.reload.name) + "'");
                    }

                    while (state && state === fromPath[keep] && state !== reloadState) {
                        locals = toLocals[keep] = state.locals;
                        keep++;
                        state = toPath[keep];
                    }
                }

                // If we're going to the same state and all locals are kept, we've got nothing to do.
                // But clear 'transition', as we still want to cancel any other pending transitions.
                // TODO: We may not want to bump 'transition' if we're called from a location change
                // that we've initiated ourselves, because we might accidentally abort a legitimate
                // transition initiated from code?
                if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {
                    if (hash)
                        toParams['#'] = hash;
                    $state.params = toParams;
                    copy($state.params, $stateParams);
                    if (options.location && to.navigable && to.navigable.url) {
                        $urlRouter.push(to.navigable.url, toParams, {
                            $$avoidResync: true, replace: options.location === 'replace'
                        });
                        $urlRouter.update(true);
                    }
                    $state.transition = null;
                    return $q.when($state.current);
                }

                // Filter parameters before we pass them to event handlers etc.
                toParams = filterByKeys(to.params.$$keys(), toParams || {});

                // Broadcast start event and cancel the transition if requested
                if (options.notify) {
                    /**
                     * @ngdoc event
                     * @name ui.router.state.$state#$stateChangeStart
                     * @eventOf ui.router.state.$state
                     * @eventType broadcast on root scope
                     * @description
                     * Fired when the state transition **begins**. You can use `event.preventDefault()`
                     * to prevent the transition from happening and then the transition promise will be
                     * rejected with a `'transition prevented'` value.
                     *
                     * @param {Object} event Event object.
                     * @param {State} toState The state being transitioned to.
                     * @param {Object} toParams The params supplied to the `toState`.
                     * @param {State} fromState The current state, pre-transition.
                     * @param {Object} fromParams The params supplied to the `fromState`.
                     *
                     * @example
                     *
                     * <pre>
                     * $rootScope.$on('$stateChangeStart',
                     * function(event, toState, toParams, fromState, fromParams){
                     *     event.preventDefault();
                     *     // transitionTo() promise will be rejected with
                     *     // a 'transition prevented' error
                     * })
                     * </pre>
                     */
                    if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams).defaultPrevented) {
                        $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);
                        $urlRouter.update();
                        return TransitionPrevented;
                    }
                }

                // Resolve locals for the remaining states, but don't update any global state just
                // yet -- if anything fails to resolve the current state needs to remain untouched.
                // We also set up an inheritance chain for the locals here. This allows the view directive
                // to quickly look up the correct definition for each view in the current state. Even
                // though we create the locals object itself outside resolveState(), it is initially
                // empty and gets filled asynchronously. We need to keep track of the promise for the
                // (fully resolved) current locals, and pass this down the chain.
                var resolved = $q.when(locals);

                for (var l = keep; l < toPath.length; l++, state = toPath[l]) {
                    locals = toLocals[l] = inherit(locals);
                    resolved = resolveState(state, toParams, state === to, resolved, locals, options);
                }

                // Once everything is resolved, we are ready to perform the actual transition
                // and return a promise for the new state. We also keep track of what the
                // current promise is, so that we can detect overlapping transitions and
                // keep only the outcome of the last transition.
                var transition = $state.transition = resolved.then(function () {
                    var l, entering, exiting;

                    if ($state.transition !== transition)
                        return TransitionSuperseded;

                    // Exit 'from' states not kept
                    for (l = fromPath.length - 1; l >= keep; l--) {
                        exiting = fromPath[l];
                        if (exiting.self.onExit) {
                            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);
                        }
                        exiting.locals = null;
                    }

                    // Enter 'to' states not kept
                    for (l = keep; l < toPath.length; l++) {
                        entering = toPath[l];
                        entering.locals = toLocals[l];
                        if (entering.self.onEnter) {
                            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
                        }
                    }

                    // Re-add the saved hash before we start returning things
                    if (hash)
                        toParams['#'] = hash;

                    // Run it again, to catch any transitions in callbacks
                    if ($state.transition !== transition)
                        return TransitionSuperseded;

                    // Update globals in $state
                    $state.$current = to;
                    $state.current = to.self;
                    $state.params = toParams;
                    copy($state.params, $stateParams);
                    $state.transition = null;

                    if (options.location && to.navigable) {
                        $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {
                            $$avoidResync: true, replace: options.location === 'replace'
                        });
                    }

                    if (options.notify) {
                        /**
                         * @ngdoc event
                         * @name ui.router.state.$state#$stateChangeSuccess
                         * @eventOf ui.router.state.$state
                         * @eventType broadcast on root scope
                         * @description
                         * Fired once the state transition is **complete**.
                         *
                         * @param {Object} event Event object.
                         * @param {State} toState The state being transitioned to.
                         * @param {Object} toParams The params supplied to the `toState`.
                         * @param {State} fromState The current state, pre-transition.
                         * @param {Object} fromParams The params supplied to the `fromState`.
                         */
                        $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);
                    }
                    $urlRouter.update(true);

                    return $state.current;
                }, function (error) {
                    if ($state.transition !== transition)
                        return TransitionSuperseded;

                    $state.transition = null;
                    /**
                     * @ngdoc event
                     * @name ui.router.state.$state#$stateChangeError
                     * @eventOf ui.router.state.$state
                     * @eventType broadcast on root scope
                     * @description
                     * Fired when an **error occurs** during transition. It's important to note that if you
                     * have any errors in your resolve functions (javascript errors, non-existent services, etc)
                     * they will not throw traditionally. You must listen for this $stateChangeError event to
                     * catch **ALL** errors.
                     *
                     * @param {Object} event Event object.
                     * @param {State} toState The state being transitioned to.
                     * @param {Object} toParams The params supplied to the `toState`.
                     * @param {State} fromState The current state, pre-transition.
                     * @param {Object} fromParams The params supplied to the `fromState`.
                     * @param {Error} error The resolve error object.
                     */
                    evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);

                    if (!evt.defaultPrevented) {
                        $urlRouter.update();
                    }

                    return $q.reject(error);
                });

                return transition;
            };

            /**
             * @ngdoc function
             * @name ui.router.state.$state#is
             * @methodOf ui.router.state.$state
             *
             * @description
             * Similar to {@link ui.router.state.$state#methods_includes $state.includes},
             * but only checks for the full state name. If params is supplied then it will be
             * tested for strict equality against the current active params object, so all params
             * must match with none missing and no extras.
             *
             * @example
             * <pre>
             * $state.$current.name = 'contacts.details.item';
             *
             * // absolute name
             * $state.is('contact.details.item'); // returns true
             * $state.is(contactDetailItemStateObject); // returns true
             *
             * // relative name (. and ^), typically from a template
             * // E.g. from the 'contacts.details' template
             * <div ng-class="{highlighted: $state.is('.item')}">Item</div>
             * </pre>
             *
             * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.
             * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like
             * to test against the current active state.
             * @param {object=} options An options object.  The options are:
             *
             * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will
             * test relative to `options.relative` state (or name).
             *
             * @returns {boolean} Returns true if it is the state.
             */
            $state.is = function is(stateOrName, params, options) {
                options = extend({relative: $state.$current}, options || {});
                var state = findState(stateOrName, options.relative);

                if (!isDefined(state)) {
                    return undefined;
                }
                if ($state.$current !== state) {
                    return false;
                }
                return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;
            };

            /**
             * @ngdoc function
             * @name ui.router.state.$state#includes
             * @methodOf ui.router.state.$state
             *
             * @description
             * A method to determine if the current active state is equal to or is the child of the
             * state stateName. If any params are passed then they will be tested for a match as well.
             * Not all the parameters need to be passed, just the ones you'd like to test for equality.
             *
             * @example
             * Partial and relative names
             * <pre>
             * $state.$current.name = 'contacts.details.item';
             *
             * // Using partial names
             * $state.includes("contacts"); // returns true
             * $state.includes("contacts.details"); // returns true
             * $state.includes("contacts.details.item"); // returns true
             * $state.includes("contacts.list"); // returns false
             * $state.includes("about"); // returns false
             *
             * // Using relative names (. and ^), typically from a template
             * // E.g. from the 'contacts.details' template
             * <div ng-class="{highlighted: $state.includes('.item')}">Item</div>
             * </pre>
             *
             * Basic globbing patterns
             * <pre>
             * $state.$current.name = 'contacts.details.item.url';
             *
             * $state.includes("*.details.*.*"); // returns true
             * $state.includes("*.details.**"); // returns true
             * $state.includes("**.item.**"); // returns true
             * $state.includes("*.details.item.url"); // returns true
             * $state.includes("*.details.*.url"); // returns true
             * $state.includes("*.details.*"); // returns false
             * $state.includes("item.**"); // returns false
             * </pre>
             *
             * @param {string} stateOrName A partial name, relative name, or glob pattern
             * to be searched for within the current state name.
             * @param {object=} params A param object, e.g. `{sectionId: section.id}`,
             * that you'd like to test against the current active state.
             * @param {object=} options An options object.  The options are:
             *
             * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,
             * .includes will test relative to `options.relative` state (or name).
             *
             * @returns {boolean} Returns true if it does include the state
             */
            $state.includes = function includes(stateOrName, params, options) {
                options = extend({relative: $state.$current}, options || {});
                if (isString(stateOrName) && isGlob(stateOrName)) {
                    if (!doesStateMatchGlob(stateOrName)) {
                        return false;
                    }
                    stateOrName = $state.$current.name;
                }

                var state = findState(stateOrName, options.relative);
                if (!isDefined(state)) {
                    return undefined;
                }
                if (!isDefined($state.$current.includes[state.name])) {
                    return false;
                }
                return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;
            };


            /**
             * @ngdoc function
             * @name ui.router.state.$state#href
             * @methodOf ui.router.state.$state
             *
             * @description
             * A url generation method that returns the compiled url for the given state populated with the given params.
             *
             * @example
             * <pre>
             * expect($state.href("about.person", { person: "bob" })).toEqual("/about/bob");
             * </pre>
             *
             * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.
             * @param {object=} params An object of parameter values to fill the state's required parameters.
             * @param {object=} options Options object. The options are:
             *
             * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the
             *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka
             *    ancestor with a valid url).
             * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.
             * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'),
             *    defines which state to be relative from.
             * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. "http://www.example.com/fullurl".
             *
             * @returns {string} compiled state url
             */
            $state.href = function href(stateOrName, params, options) {
                options = extend({
                    lossy: true,
                    inherit: true,
                    absolute: false,
                    relative: $state.$current
                }, options || {});

                var state = findState(stateOrName, options.relative);

                if (!isDefined(state))
                    return null;
                if (options.inherit)
                    params = inheritParams($stateParams, params || {}, $state.$current, state);

                var nav = (state && options.lossy) ? state.navigable : state;

                if (!nav || nav.url === undefined || nav.url === null) {
                    return null;
                }
                return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {
                    absolute: options.absolute
                });
            };

            /**
             * @ngdoc function
             * @name ui.router.state.$state#get
             * @methodOf ui.router.state.$state
             *
             * @description
             * Returns the state configuration object for any specific state or all states.
             *
             * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for
             * the requested state. If not provided, returns an array of ALL state configs.
             * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.
             * @returns {Object|Array} State configuration object or array of all objects.
             */
            $state.get = function (stateOrName, context) {
                if (arguments.length === 0)
                    return map(objectKeys(states), function (name) {
                        return states[name].self;
                    });
                var state = findState(stateOrName, context || $state.$current);
                return (state && state.self) ? state.self : null;
            };

            function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {
                // Make a restricted $stateParams with only the parameters that apply to this state if
                // necessary. In addition to being available to the controller and onEnter/onExit callbacks,
                // we also need $stateParams to be available for any $injector calls we make during the
                // dependency resolution process.
                var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);
                var locals = {$stateParams: $stateParams};

                // Resolve 'global' dependencies for the state, i.e. those not specific to a view.
                // We're also including $stateParams in this; that way the parameters are restricted
                // to the set that should be visible to the state, and are independent of when we update
                // the global $state and $stateParams values.
                dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
                var promises = [dst.resolve.then(function (globals) {
                        dst.globals = globals;
                    })];
                if (inherited)
                    promises.push(inherited);

                function resolveViews() {
                    var viewsPromises = [];

                    // Resolve template and dependencies for all views.
                    forEach(state.views, function (view, name) {
                        var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});
                        injectables.$template = [function () {
                                return $view.load(name, {view: view, locals: dst.globals, params: $stateParams, notify: options.notify}) || '';
                            }];

                        viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {
                            // References to the controller (only instantiated at link time)
                            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
                                var injectLocals = angular.extend({}, injectables, dst.globals);
                                result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
                            } else {
                                result.$$controller = view.controller;
                            }
                            // Provide access to the state itself for internal use
                            result.$$state = state;
                            result.$$controllerAs = view.controllerAs;
                            dst[name] = result;
                        }));
                    });

                    return $q.all(viewsPromises).then(function () {
                        return dst.globals;
                    });
                }

                // Wait for all the promises and then return the activation object
                return $q.all(promises).then(resolveViews).then(function (values) {
                    return dst;
                });
            }

            return $state;
        }

        function shouldSkipReload(to, toParams, from, fromParams, locals, options) {
            // Return true if there are no differences in non-search (path/object) params, false if there are differences
            function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {
                // Identify whether all the parameters that differ between `fromParams` and `toParams` were search params.
                function notSearchParam(key) {
                    return fromAndToState.params[key].location != "search";
                }
                var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);
                var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));
                var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);
                return nonQueryParamSet.$$equals(fromParams, toParams);
            }

            // If reload was not explicitly requested
            // and we're transitioning to the same state we're already in
            // and    the locals didn't change
            //     or they changed in a way that doesn't merit reloading
            //        (reloadOnParams:false, or reloadOnSearch.false and only search params changed)
            // Then return true.
            if (!options.reload && to === from &&
                    (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {
                return true;
            }
        }
    }

    angular.module('ui.router.state')
            .value('$stateParams', {})
            .provider('$state', $StateProvider);


    $ViewProvider.$inject = [];
    function $ViewProvider() {

        this.$get = $get;
        /**
         * @ngdoc object
         * @name ui.router.state.$view
         *
         * @requires ui.router.util.$templateFactory
         * @requires $rootScope
         *
         * @description
         *
         */
        $get.$inject = ['$rootScope', '$templateFactory'];
        function $get($rootScope, $templateFactory) {
            return {
                // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })
                /**
                 * @ngdoc function
                 * @name ui.router.state.$view#load
                 * @methodOf ui.router.state.$view
                 *
                 * @description
                 *
                 * @param {string} name name
                 * @param {object} options option object.
                 */
                load: function load(name, options) {
                    var result, defaults = {
                        template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}
                    };
                    options = extend(defaults, options);

                    if (options.view) {
                        result = $templateFactory.fromConfig(options.view, options.params, options.locals);
                    }
                    if (result && options.notify) {
                        /**
                         * @ngdoc event
                         * @name ui.router.state.$state#$viewContentLoading
                         * @eventOf ui.router.state.$view
                         * @eventType broadcast on root scope
                         * @description
                         *
                         * Fired once the view **begins loading**, *before* the DOM is rendered.
                         *
                         * @param {Object} event Event object.
                         * @param {Object} viewConfig The view config properties (template, controller, etc).
                         *
                         * @example
                         *
                         * <pre>
                         * $scope.$on('$viewContentLoading',
                         * function(event, viewConfig){
                         *     // Access to all the view config properties.
                         *     // and one special property 'targetView'
                         *     // viewConfig.targetView
                         * });
                         * </pre>
                         */
                        $rootScope.$broadcast('$viewContentLoading', options);
                    }
                    return result;
                }
            };
        }
    }

    angular.module('ui.router.state').provider('$view', $ViewProvider);

    /**
     * @ngdoc object
     * @name ui.router.state.$uiViewScrollProvider
     *
     * @description
     * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.
     */
    function $ViewScrollProvider() {

        var useAnchorScroll = false;

        /**
         * @ngdoc function
         * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll
         * @methodOf ui.router.state.$uiViewScrollProvider
         *
         * @description
         * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for
         * scrolling based on the url anchor.
         */
        this.useAnchorScroll = function () {
            useAnchorScroll = true;
        };

        /**
         * @ngdoc object
         * @name ui.router.state.$uiViewScroll
         *
         * @requires $anchorScroll
         * @requires $timeout
         *
         * @description
         * When called with a jqLite element, it scrolls the element into view (after a
         * `$timeout` so the DOM has time to refresh).
         *
         * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,
         * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.
         */
        this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {
                if (useAnchorScroll) {
                    return $anchorScroll;
                }

                return function ($element) {
                    return $timeout(function () {
                        $element[0].scrollIntoView();
                    }, 0, false);
                };
            }];
    }

    angular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);

    /**
     * @ngdoc directive
     * @name ui.router.state.directive:ui-view
     *
     * @requires ui.router.state.$state
     * @requires $compile
     * @requires $controller
     * @requires $injector
     * @requires ui.router.state.$uiViewScroll
     * @requires $document
     *
     * @restrict ECA
     *
     * @description
     * The ui-view directive tells $state where to place your templates.
     *
     * @param {string=} name A view name. The name should be unique amongst the other views in the
     * same state. You can have views of the same name that live in different states.
     *
     * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window
     * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll
     * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you
     * scroll ui-view elements into view when they are populated during a state activation.
     *
     * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)
     * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*
     *
     * @param {string=} onload Expression to evaluate whenever the view updates.
     *
     * @example
     * A view can be unnamed or named.
     * <pre>
     * <!-- Unnamed -->
     * <div ui-view></div>
     *
     * <!-- Named -->
     * <div ui-view="viewName"></div>
     * </pre>
     *
     * You can only have one unnamed view within any template (or root html). If you are only using a
     * single view and it is unnamed then you can populate it like so:
     * <pre>
     * <div ui-view></div>
     * $stateProvider.state("home", {
     *   template: "<h1>HELLO!</h1>"
     * })
     * </pre>
     *
     * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#views `views`}
     * config property, by name, in this case an empty name:
     * <pre>
     * $stateProvider.state("home", {
     *   views: {
     *     "": {
     *       template: "<h1>HELLO!</h1>"
     *     }
     *   }
     * })
     * </pre>
     *
     * But typically you'll only use the views property if you name your view or have more than one view
     * in the same template. There's not really a compelling reason to name a view if its the only one,
     * but you could if you wanted, like so:
     * <pre>
     * <div ui-view="main"></div>
     * </pre>
     * <pre>
     * $stateProvider.state("home", {
     *   views: {
     *     "main": {
     *       template: "<h1>HELLO!</h1>"
     *     }
     *   }
     * })
     * </pre>
     *
     * Really though, you'll use views to set up multiple views:
     * <pre>
     * <div ui-view></div>
     * <div ui-view="chart"></div>
     * <div ui-view="data"></div>
     * </pre>
     *
     * <pre>
     * $stateProvider.state("home", {
     *   views: {
     *     "": {
     *       template: "<h1>HELLO!</h1>"
     *     },
     *     "chart": {
     *       template: "<chart_thing/>"
     *     },
     *     "data": {
     *       template: "<data_thing/>"
     *     }
     *   }
     * })
     * </pre>
     *
     * Examples for `autoscroll`:
     *
     * <pre>
     * <!-- If autoscroll present with no expression,
     *      then scroll ui-view into view -->
     * <ui-view autoscroll/>
     *
     * <!-- If autoscroll present with valid expression,
     *      then scroll ui-view into view if expression evaluates to true -->
     * <ui-view autoscroll='true'/>
     * <ui-view autoscroll='false'/>
     * <ui-view autoscroll='scopeVariable'/>
     * </pre>
     */
    $ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];
    function $ViewDirective($state, $injector, $uiViewScroll, $interpolate) {

        function getService() {
            return ($injector.has) ? function (service) {
                return $injector.has(service) ? $injector.get(service) : null;
            } : function (service) {
                try {
                    return $injector.get(service);
                } catch (e) {
                    return null;
                }
            };
        }

        var service = getService(),
                $animator = service('$animator'),
                $animate = service('$animate');

        // Returns a set of DOM manipulation functions based on which Angular version
        // it should use
        function getRenderer(attrs, scope) {
            var statics = function () {
                return {
                    enter: function (element, target, cb) {
                        target.after(element);
                        cb();
                    },
                    leave: function (element, cb) {
                        element.remove();
                        cb();
                    }
                };
            };

            if ($animate) {
                return {
                    enter: function (element, target, cb) {
                        var promise = $animate.enter(element, null, target, cb);
                        if (promise && promise.then)
                            promise.then(cb);
                    },
                    leave: function (element, cb) {
                        var promise = $animate.leave(element, cb);
                        if (promise && promise.then)
                            promise.then(cb);
                    }
                };
            }

            if ($animator) {
                var animate = $animator && $animator(scope, attrs);

                return {
                    enter: function (element, target, cb) {
                        animate.enter(element, null, target);
                        cb();
                    },
                    leave: function (element, cb) {
                        animate.leave(element);
                        cb();
                    }
                };
            }

            return statics();
        }

        var directive = {
            restrict: 'ECA',
            terminal: true,
            priority: 400,
            transclude: 'element',
            compile: function (tElement, tAttrs, $transclude) {
                return function (scope, $element, attrs) {
                    var previousEl, currentEl, currentScope, latestLocals,
                            onloadExp = attrs.onload || '',
                            autoScrollExp = attrs.autoscroll,
                            renderer = getRenderer(attrs, scope);

                    scope.$on('$stateChangeSuccess', function () {
                        updateView(false);
                    });
                    scope.$on('$viewContentLoading', function () {
                        updateView(false);
                    });

                    updateView(true);

                    function cleanupLastView() {
                        if (previousEl) {
                            previousEl.remove();
                            previousEl = null;
                        }

                        if (currentScope) {
                            currentScope.$destroy();
                            currentScope = null;
                        }

                        if (currentEl) {
                            renderer.leave(currentEl, function () {
                                previousEl = null;
                            });

                            previousEl = currentEl;
                            currentEl = null;
                        }
                    }

                    function updateView(firstTime) {
                        var newScope,
                                name = getUiViewName(scope, attrs, $element, $interpolate),
                                previousLocals = name && $state.$current && $state.$current.locals[name];

                        if (!firstTime && previousLocals === latestLocals)
                            return; // nothing to do
                        newScope = scope.$new();
                        latestLocals = $state.$current.locals[name];

                        var clone = $transclude(newScope, function (clone) {
                            renderer.enter(clone, $element, function onUiViewEnter() {
                                if (currentScope) {
                                    currentScope.$emit('$viewContentAnimationEnded');
                                }

                                if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {
                                    $uiViewScroll(clone);
                                }
                            });
                            cleanupLastView();
                        });

                        currentEl = clone;
                        currentScope = newScope;
                        /**
                         * @ngdoc event
                         * @name ui.router.state.directive:ui-view#$viewContentLoaded
                         * @eventOf ui.router.state.directive:ui-view
                         * @eventType emits on ui-view directive scope
                         * @description           *
                         * Fired once the view is **loaded**, *after* the DOM is rendered.
                         *
                         * @param {Object} event Event object.
                         */
                        currentScope.$emit('$viewContentLoaded');
                        currentScope.$eval(onloadExp);
                    }
                };
            }
        };

        return directive;
    }

    $ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];
    function $ViewDirectiveFill($compile, $controller, $state, $interpolate) {
        return {
            restrict: 'ECA',
            priority: -400,
            compile: function (tElement) {
                var initial = tElement.html();
                return function (scope, $element, attrs) {
                    var current = $state.$current,
                            name = getUiViewName(scope, attrs, $element, $interpolate),
                            locals = current && current.locals[name];

                    if (!locals) {
                        return;
                    }

                    $element.data('$uiView', {name: name, state: locals.$$state});
                    $element.html(locals.$template ? locals.$template : initial);

                    var link = $compile($element.contents());

                    if (locals.$$controller) {
                        locals.$scope = scope;
                        locals.$element = $element;
                        var controller = $controller(locals.$$controller, locals);
                        if (locals.$$controllerAs) {
                            scope[locals.$$controllerAs] = controller;
                        }
                        $element.data('$ngControllerController', controller);
                        $element.children().data('$ngControllerController', controller);
                    }

                    link(scope);
                };
            }
        };
    }

    /**
     * Shared ui-view code for both directives:
     * Given scope, element, and its attributes, return the view's name
     */
    function getUiViewName(scope, attrs, element, $interpolate) {
        var name = $interpolate(attrs.uiView || attrs.name || '')(scope);
        var inherited = element.inheritedData('$uiView');
        return name.indexOf('@') >= 0 ? name : (name + '@' + (inherited ? inherited.state.name : ''));
    }

    angular.module('ui.router.state').directive('uiView', $ViewDirective);
    angular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);

    function parseStateRef(ref, current) {
        var preparsed = ref.match(/^\s*({[^}]*})\s*$/), parsed;
        if (preparsed)
            ref = current + '(' + preparsed[1] + ')';
        parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/);
        if (!parsed || parsed.length !== 4)
            throw new Error("Invalid state ref '" + ref + "'");
        return {state: parsed[1], paramExpr: parsed[3] || null};
    }

    function stateContext(el) {
        var stateData = el.parent().inheritedData('$uiView');

        if (stateData && stateData.state && stateData.state.name) {
            return stateData.state;
        }
    }

    /**
     * @ngdoc directive
     * @name ui.router.state.directive:ui-sref
     *
     * @requires ui.router.state.$state
     * @requires $timeout
     *
     * @restrict A
     *
     * @description
     * A directive that binds a link (`<a>` tag) to a state. If the state has an associated
     * URL, the directive will automatically generate & update the `href` attribute via
     * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking
     * the link will trigger a state transition with optional parameters.
     *
     * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be
     * handled natively by the browser.
     *
     * You can also use relative state paths within ui-sref, just like the relative
     * paths passed to `$state.go()`. You just need to be aware that the path is relative
     * to the state that the link lives in, in other words the state that loaded the
     * template containing the link.
     *
     * You can specify options to pass to {@link ui.router.state.$state#go $state.go()}
     * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,
     * and `reload`.
     *
     * @example
     * Here's an example of how you'd use ui-sref and how it would compile. If you have the
     * following template:
     * <pre>
     * <a ui-sref="home">Home</a> | <a ui-sref="about">About</a> | <a ui-sref="{page: 2}">Next page</a>
     *
     * <ul>
     *     <li ng-repeat="contact in contacts">
     *         <a ui-sref="contacts.detail({ id: contact.id })">{{ contact.name }}</a>
     *     </li>
     * </ul>
     * </pre>
     *
     * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):
     * <pre>
     * <a href="#/home" ui-sref="home">Home</a> | <a href="#/about" ui-sref="about">About</a> | <a href="#/contacts?page=2" ui-sref="{page: 2}">Next page</a>
     *
     * <ul>
     *     <li ng-repeat="contact in contacts">
     *         <a href="#/contacts/1" ui-sref="contacts.detail({ id: contact.id })">Joe</a>
     *     </li>
     *     <li ng-repeat="contact in contacts">
     *         <a href="#/contacts/2" ui-sref="contacts.detail({ id: contact.id })">Alice</a>
     *     </li>
     *     <li ng-repeat="contact in contacts">
     *         <a href="#/contacts/3" ui-sref="contacts.detail({ id: contact.id })">Bob</a>
     *     </li>
     * </ul>
     *
     * <a ui-sref="home" ui-sref-opts="{reload: true}">Home</a>
     * </pre>
     *
     * @param {string} ui-sref 'stateName' can be any valid absolute or relative state
     * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#go $state.go()}
     */
    $StateRefDirective.$inject = ['$state', '$timeout'];
    function $StateRefDirective($state, $timeout) {
        var allowedOptions = ['location', 'inherit', 'reload', 'absolute'];

        return {
            restrict: 'A',
            require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
            link: function (scope, element, attrs, uiSrefActive) {
                var ref = parseStateRef(attrs.uiSref, $state.current.name);
                var params = null, url = null, base = stateContext(element) || $state.$current;
                // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.
                var hrefKind = Object.prototype.toString.call(element.prop('href')) === '[object SVGAnimatedString]' ?
                        'xlink:href' : 'href';
                var newHref = null, isAnchor = element.prop("tagName").toUpperCase() === "A";
                var isForm = element[0].nodeName === "FORM";
                var attr = isForm ? "action" : hrefKind, nav = true;

                var options = {relative: base, inherit: true};
                var optionsOverride = scope.$eval(attrs.uiSrefOpts) || {};

                angular.forEach(allowedOptions, function (option) {
                    if (option in optionsOverride) {
                        options[option] = optionsOverride[option];
                    }
                });

                var update = function (newVal) {
                    if (newVal)
                        params = angular.copy(newVal);
                    if (!nav)
                        return;

                    newHref = $state.href(ref.state, params, options);

                    var activeDirective = uiSrefActive[1] || uiSrefActive[0];
                    if (activeDirective) {
                        activeDirective.$$addStateInfo(ref.state, params);
                    }
                    if (newHref === null) {
                        nav = false;
                        return false;
                    }
                    attrs.$set(attr, newHref);
                };

                if (ref.paramExpr) {
                    scope.$watch(ref.paramExpr, function (newVal, oldVal) {
                        if (newVal !== params)
                            update(newVal);
                    }, true);
                    params = angular.copy(scope.$eval(ref.paramExpr));
                }
                update();

                if (isForm)
                    return;

                element.bind("click", function (e) {
                    var button = e.which || e.button;
                    if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || element.attr('target'))) {
                        // HACK: This is to allow ng-clicks to be processed before the transition is initiated:
                        var transition = $timeout(function () {
                            $state.go(ref.state, params, options);
                        });
                        e.preventDefault();

                        // if the state has no URL, ignore one preventDefault from the <a> directive.
                        var ignorePreventDefaultCount = isAnchor && !newHref ? 1 : 0;
                        e.preventDefault = function () {
                            if (ignorePreventDefaultCount-- <= 0)
                                $timeout.cancel(transition);
                        };
                    }
                });
            }
        };
    }

    /**
     * @ngdoc directive
     * @name ui.router.state.directive:ui-sref-active
     *
     * @requires ui.router.state.$state
     * @requires ui.router.state.$stateParams
     * @requires $interpolate
     *
     * @restrict A
     *
     * @description
     * A directive working alongside ui-sref to add classes to an element when the
     * related ui-sref directive's state is active, and removing them when it is inactive.
     * The primary use-case is to simplify the special appearance of navigation menus
     * relying on `ui-sref`, by having the "active" state's menu button appear different,
     * distinguishing it from the inactive menu items.
     *
     * ui-sref-active can live on the same element as ui-sref or on a parent element. The first
     * ui-sref-active found at the same level or above the ui-sref will be used.
     *
     * Will activate when the ui-sref's target state or any child state is active. If you
     * need to activate only when the ui-sref target state is active and *not* any of
     * it's children, then you will use
     * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}
     *
     * @example
     * Given the following template:
     * <pre>
     * <ul>
     *   <li ui-sref-active="active" class="item">
     *     <a href ui-sref="app.user({user: 'bilbobaggins'})">@bilbobaggins</a>
     *   </li>
     * </ul>
     * </pre>
     *
     *
     * When the app state is "app.user" (or any children states), and contains the state parameter "user" with value "bilbobaggins",
     * the resulting HTML will appear as (note the 'active' class):
     * <pre>
     * <ul>
     *   <li ui-sref-active="active" class="item active">
     *     <a ui-sref="app.user({user: 'bilbobaggins'})" href="/users/bilbobaggins">@bilbobaggins</a>
     *   </li>
     * </ul>
     * </pre>
     *
     * The class name is interpolated **once** during the directives link time (any further changes to the
     * interpolated value are ignored).
     *
     * Multiple classes may be specified in a space-separated format:
     * <pre>
     * <ul>
     *   <li ui-sref-active='class1 class2 class3'>
     *     <a ui-sref="app.user">link</a>
     *   </li>
     * </ul>
     * </pre>
     */

    /**
     * @ngdoc directive
     * @name ui.router.state.directive:ui-sref-active-eq
     *
     * @requires ui.router.state.$state
     * @requires ui.router.state.$stateParams
     * @requires $interpolate
     *
     * @restrict A
     *
     * @description
     * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will only activate
     * when the exact target state used in the `ui-sref` is active; no child states.
     *
     */
    $StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];
    function $StateRefActiveDirective($state, $stateParams, $interpolate) {
        return  {
            restrict: "A",
            controller: ['$scope', '$element', '$attrs', function ($scope, $element, $attrs) {
                    var states = [], activeClass;

                    // There probably isn't much point in $observing this
                    // uiSrefActive and uiSrefActiveEq share the same directive object with some
                    // slight difference in logic routing
                    activeClass = $interpolate($attrs.uiSrefActiveEq || $attrs.uiSrefActive || '', false)($scope);

                    // Allow uiSref to communicate with uiSrefActive[Equals]
                    this.$$addStateInfo = function (newState, newParams) {
                        var state = $state.get(newState, stateContext($element));

                        states.push({
                            state: state || {name: newState},
                            params: newParams
                        });

                        update();
                    };

                    $scope.$on('$stateChangeSuccess', update);

                    // Update route state
                    function update() {
                        if (anyMatch()) {
                            $element.addClass(activeClass);
                        } else {
                            $element.removeClass(activeClass);
                        }
                    }

                    function anyMatch() {
                        for (var i = 0; i < states.length; i++) {
                            if (isMatch(states[i].state, states[i].params)) {
                                return true;
                            }
                        }
                        return false;
                    }

                    function isMatch(state, params) {
                        if (typeof $attrs.uiSrefActiveEq !== 'undefined') {
                            return $state.is(state.name, params);
                        } else {
                            return $state.includes(state.name, params);
                        }
                    }
                }]
        };
    }

    angular.module('ui.router.state')
            .directive('uiSref', $StateRefDirective)
            .directive('uiSrefActive', $StateRefActiveDirective)
            .directive('uiSrefActiveEq', $StateRefActiveDirective);

    /**
     * @ngdoc filter
     * @name ui.router.state.filter:isState
     *
     * @requires ui.router.state.$state
     *
     * @description
     * Translates to {@link ui.router.state.$state#methods_is $state.is("stateName")}.
     */
    $IsStateFilter.$inject = ['$state'];
    function $IsStateFilter($state) {
        var isFilter = function (state) {
            return $state.is(state);
        };
        isFilter.$stateful = true;
        return isFilter;
    }

    /**
     * @ngdoc filter
     * @name ui.router.state.filter:includedByState
     *
     * @requires ui.router.state.$state
     *
     * @description
     * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.
     */
    $IncludedByStateFilter.$inject = ['$state'];
    function $IncludedByStateFilter($state) {
        var includesFilter = function (state) {
            return $state.includes(state);
        };
        includesFilter.$stateful = true;
        return  includesFilter;
    }

    angular.module('ui.router.state')
            .filter('isState', $IsStateFilter)
            .filter('includedByState', $IncludedByStateFilter);
})(window, window.angular);
'use strict';
        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         *     Any commits to this file should be reviewed with security in mind.  *
         *   Changes to this file can potentially create security vulnerabilities. *
         *          An approval from 2 Core members with history of modifying      *
         *                         this file is required.                          *
         *                                                                         *
         *  Does the change somehow allow for arbitrary javascript to be executed? *
         *    Or allows for someone to change the prototype of built-in objects?   *
         *     Or gives undesired access to variables likes document or window?    *
         * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

        var $sanitizeMinErr = angular.$$minErr('$sanitize');
        /**
         * @ngdoc module
         * @name ngSanitize
         * @description
         *
         * # ngSanitize
         *
         * The `ngSanitize` module provides functionality to sanitize HTML.
         *
         *
         * <div doc-module-components="ngSanitize"></div>
         *
         * See {@link ngSanitize.$sanitize `$sanitize`} for usage.
         */

                /**
                 * @ngdoc service
                 * @name $sanitize
                 * @kind function
                 *
                 * @description
                 *   Sanitizes an html string by stripping all potentially dangerous tokens.
                 *
                 *   The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are
                 *   then serialized back to properly escaped html string. This means that no unsafe input can make
                 *   it into the returned string.
                 *
                 *   The whitelist for URL sanitization of attribute values is configured using the functions
                 *   `aHrefSanitizationWhitelist` and `imgSrcSanitizationWhitelist` of {@link ng.$compileProvider
                 *   `$compileProvider`}.
                 *
                 *   The input may also contain SVG markup if this is enabled via {@link $sanitizeProvider}.
                 *
                 * @param {string} html HTML input.
                 * @returns {string} Sanitized HTML.
                 *
                 * @example
                 <example module="sanitizeExample" deps="angular-sanitize.js">
                 <file name="index.html">
                 <script>
                 angular.module('sanitizeExample', ['ngSanitize'])
                 .controller('ExampleController', ['$scope', '$sce', function($scope, $sce) {
                 $scope.snippet =
                 '<p style="color:blue">an html\n' +
                 '<em onmouseover="this.textContent=\'PWN3D!\'">click here</em>\n' +
                 'snippet</p>';
                 $scope.deliberatelyTrustDangerousSnippet = function() {
                 return $sce.trustAsHtml($scope.snippet);
                 };
                 }]);
                 </script>
                 <div ng-controller="ExampleController">
                 Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
                 <table>
                 <tr>
                 <td>Directive</td>
                 <td>How</td>
                 <td>Source</td>
                 <td>Rendered</td>
                 </tr>
                 <tr id="bind-html-with-sanitize">
                 <td>ng-bind-html</td>
                 <td>Automatically uses $sanitize</td>
                 <td><pre>&lt;div ng-bind-html="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
                 <td><div ng-bind-html="snippet"></div></td>
                 </tr>
                 <tr id="bind-html-with-trust">
                 <td>ng-bind-html</td>
                 <td>Bypass $sanitize by explicitly trusting the dangerous value</td>
                 <td>
                 <pre>&lt;div ng-bind-html="deliberatelyTrustDangerousSnippet()"&gt;
                 &lt;/div&gt;</pre>
                 </td>
                 <td><div ng-bind-html="deliberatelyTrustDangerousSnippet()"></div></td>
                 </tr>
                 <tr id="bind-default">
                 <td>ng-bind</td>
                 <td>Automatically escapes</td>
                 <td><pre>&lt;div ng-bind="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
                 <td><div ng-bind="snippet"></div></td>
                 </tr>
                 </table>
                 </div>
                 </file>
                 <file name="protractor.js" type="protractor">
                 it('should sanitize the html snippet by default', function() {
                 expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).
                 toBe('<p>an html\n<em>click here</em>\nsnippet</p>');
                 });
                 it('should inline raw snippet if bound to a trusted value', function() {
                 expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).
                 toBe("<p style=\"color:blue\">an html\n" +
                 "<em onmouseover=\"this.textContent='PWN3D!'\">click here</em>\n" +
                 "snippet</p>");
                 });
                 it('should escape snippet without any filter', function() {
                 expect(element(by.css('#bind-default div')).getInnerHtml()).
                 toBe("&lt;p style=\"color:blue\"&gt;an html\n" +
                 "&lt;em onmouseover=\"this.textContent='PWN3D!'\"&gt;click here&lt;/em&gt;\n" +
                 "snippet&lt;/p&gt;");
                 });
                 it('should update', function() {
                 element(by.model('snippet')).clear();
                 element(by.model('snippet')).sendKeys('new <b onclick="alert(1)">text</b>');
                 expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).
                 toBe('new <b>text</b>');
                 expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).toBe(
                 'new <b onclick="alert(1)">text</b>');
                 expect(element(by.css('#bind-default div')).getInnerHtml()).toBe(
                 "new &lt;b onclick=\"alert(1)\"&gt;text&lt;/b&gt;");
                 });
                 </file>
                 </example>
                 */


                        /**
                         * @ngdoc provider
                         * @name $sanitizeProvider
                         *
                         * @description
                         * Creates and configures {@link $sanitize} instance.
                         */
                                function $SanitizeProvider() {
                                var svgEnabled = false;
                                        this.$get = ['$$sanitizeUri', function($$sanitizeUri) {
                                        if (svgEnabled) {
                                        angular.extend(validElements, svgElements);
                                        }
                                        return function(html) {
                                        var buf = [];
                                                htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
                                                return !/^unsafe:/.test($$sanitizeUri(uri, isImage));
                                                }));
                                                return buf.join('');
                                        };
                                        }];
                                        /**
                                         * @ngdoc method
                                         * @name $sanitizeProvider#enableSvg
                                         * @kind function
                                         *
                                         * @description
                                         * Enables a subset of svg to be supported by the sanitizer.
                                         *
                                         * <div class="alert alert-warning">
                                         *   <p>By enabling this setting without taking other precautions, you might expose your
                                         *   application to click-hijacking attacks. In these attacks, sanitized svg elements could be positioned
                                         *   outside of the containing element and be rendered over other elements on the page (e.g. a login
                                         *   link). Such behavior can then result in phishing incidents.</p>
                                         *
                                         *   <p>To protect against these, explicitly setup `overflow: hidden` css rule for all potential svg
                                         *   tags within the sanitized content:</p>
                                         *
                                         *   <br>
                                         *
                                         *   <pre><code>
                                         *   .rootOfTheIncludedContent svg {
                                         *     overflow: hidden !important;
                                         *   }
                                         *   </code></pre>
                                         * </div>
                                         *
                                         * @param {boolean=} flag Enable or disable SVG support in the sanitizer.
                                         * @returns {boolean|ng.$sanitizeProvider} Returns the currently configured value if called
                                         *    without an argument or self for chaining otherwise.
                                         */
                                        this.enableSvg = function(enableSvg) {
                                        if (angular.isDefined(enableSvg)) {
                                        svgEnabled = enableSvg;
                                                return this;
                                        } else {
                                        return svgEnabled;
                                        }
                                        };
                                        }

                        function sanitizeText(chars) {
                        var buf = [];
                                var writer = htmlSanitizeWriter(buf, angular.noop);
                                writer.chars(chars);
                                return buf.join('');
                                }


// Regular Expressions for parsing tags and attributes
                        var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
                                // Match everything outside of normal chars and " (quote character)
                                NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
// Good source of info about elements and attributes
// http://dev.w3.org/html5/spec/Overview.html#semantics
// http://simon.html5.org/html-elements

// Safe Void Elements - HTML5
// http://dev.w3.org/html5/spec/Overview.html#void-elements
                                var voidElements = toMap("area,br,col,hr,img,wbr");
// Elements that you can, intentionally, leave open (and which close themselves)
// http://dev.w3.org/html5/spec/Overview.html#optional-tags
                                var optionalEndTagBlockElements = toMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
                                optionalEndTagInlineElements = toMap("rp,rt"),
                                optionalEndTagElements = angular.extend({},
                                        optionalEndTagInlineElements,
                                        optionalEndTagBlockElements);
// Safe Block Elements - HTML5
                                var blockElements = angular.extend({}, optionalEndTagBlockElements, toMap("address,article," +
                                        "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," +
                                        "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,section,table,ul"));
// Inline Elements - HTML5
                                var inlineElements = angular.extend({}, optionalEndTagInlineElements, toMap("a,abbr,acronym,b," +
                                        "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," +
                                        "samp,small,span,strike,strong,sub,sup,time,tt,u,var"));
// SVG Elements
// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Elements
// Note: the elements animate,animateColor,animateMotion,animateTransform,set are intentionally omitted.
// They can potentially allow for arbitrary javascript to be executed. See #11290
                                var svgElements = toMap("circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph," +
                                        "hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline," +
                                        "radialGradient,rect,stop,svg,switch,text,title,tspan");
// Blocked Elements (will be stripped)
                                var blockedElements = toMap("script,style");
                                var validElements = angular.extend({},
                                        voidElements,
                                        blockElements,
                                        inlineElements,
                                        optionalEndTagElements);
//Attributes that have href and hence need to be sanitized
                                var uriAttrs = toMap("background,cite,href,longdesc,src,xlink:href");
                                var htmlAttrs = toMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' +
                                        'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' +
                                        'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' +
                                        'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' +
                                        'valign,value,vspace,width');
// SVG attributes (without "id" and "name" attributes)
// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Attributes
                                var svgAttrs = toMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' +
                                        'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' +
                                        'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' +
                                        'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' +
                                        'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' +
                                        'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' +
                                        'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' +
                                        'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' +
                                        'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' +
                                        'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' +
                                        'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' +
                                        'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' +
                                        'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' +
                                        'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' +
                                        'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);
                                var validAttrs = angular.extend({},
                                        uriAttrs,
                                        svgAttrs,
                                        htmlAttrs);
                                function toMap(str, lowercaseKeys) {
                                var obj = {}, items = str.split(','), i;
                                        for (i = 0; i < items.length; i++) {
                                obj[lowercaseKeys ? angular.lowercase(items[i]) : items[i]] = true;
                                }
                                return obj;
                                        }

                        var inertBodyElement;
                                (function(window) {
                                var doc;
                                        if (window.document && window.document.implementation) {
                                doc = window.document.implementation.createHTMLDocument("inert");
                                } else {
                                throw $sanitizeMinErr('noinert', "Can't create an inert html document");
                                }
                                var docElement = doc.documentElement || doc.getDocumentElement();
                                        var bodyElements = docElement.getElementsByTagName('body');
                                        // usually there should be only one body element in the document, but IE doesn't have any, so we need to create one
                                        if (bodyElements.length === 1) {
                                inertBodyElement = bodyElements[0];
                                } else {
                                var html = doc.createElement('html');
                                        inertBodyElement = doc.createElement('body');
                                        html.appendChild(inertBodyElement);
                                        doc.appendChild(html);
                                }
                                })(window);
                                /**
                                 * @example
                                 * htmlParser(htmlString, {
                                 *     start: function(tag, attrs) {},
                                 *     end: function(tag) {},
                                 *     chars: function(text) {},
                                 *     comment: function(text) {}
                                 * });
                                 *
                                 * @param {string} html string
                                 * @param {object} handler
                                 */
                                        function htmlParser(html, handler) {
                                        if (html === null || html === undefined) {
                                        html = '';
                                        } else if (typeof html !== 'string') {
                                        html = '' + html;
                                        }
                                        inertBodyElement.innerHTML = html;
                                                //mXSS protection
                                                var mXSSAttempts = 5;
                                                do {
                                                if (mXSSAttempts === 0) {
                                                throw $sanitizeMinErr('uinput', "Failed to sanitize html because the input is unstable");
                                                }
                                                mXSSAttempts--;
                                                        // strip custom-namespaced attributes on IE<=11
                                                        if (window.document.documentMode) {
                                                stripCustomNsAttrs(inertBodyElement);
                                                }
                                                html = inertBodyElement.innerHTML; //trigger mXSS
                                                        inertBodyElement.innerHTML = html;
                                                } while (html !== inertBodyElement.innerHTML);
                                                var node = inertBodyElement.firstChild;
                                                while (node) {
                                        switch (node.nodeType) {
                                        case 1: // ELEMENT_NODE
                                                handler.start(node.nodeName.toLowerCase(), attrToMap(node.attributes));
                                                break;
                                                case 3: // TEXT NODE
                                                handler.chars(node.textContent);
                                                break;
                                        }

                                        var nextNode;
                                                if (!(nextNode = node.firstChild)) {
                                        if (node.nodeType === 1) {
                                        handler.end(node.nodeName.toLowerCase());
                                        }
                                        nextNode = node.nextSibling;
                                                if (!nextNode) {
                                        while (nextNode == null) {
                                        node = node.parentNode;
                                                if (node === inertBodyElement) break;
                                                nextNode = node.nextSibling;
                                                if (node.nodeType === 1) {
                                        handler.end(node.nodeName.toLowerCase());
                                        }
                                        }
                                        }
                                        }
                                        node = nextNode;
                                        }

                                        while (node = inertBodyElement.firstChild) {
                                        inertBodyElement.removeChild(node);
                                        }
                                        }

                                function attrToMap(attrs) {
                                var map = {};
                                        for (var i = 0, ii = attrs.length; i < ii; i++) {
                                var attr = attrs[i];
                                        map[attr.name] = attr.value;
                                }
                                return map;
                                        }


                                /**
                                 * Escapes all potentially dangerous characters, so that the
                                 * resulting string can be safely inserted into attribute or
                                 * element text.
                                 * @param value
                                 * @returns {string} escaped text
                                 */
                                function encodeEntities(value) {
                                return value.
                                        replace(/&/g, '&amp;').
                                        replace(SURROGATE_PAIR_REGEXP, function(value) {
                                        var hi = value.charCodeAt(0);
                                                var low = value.charCodeAt(1);
                                                return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
                                        }).
                                        replace(NON_ALPHANUMERIC_REGEXP, function(value) {
                                        return '&#' + value.charCodeAt(0) + ';';
                                        }).
                                        replace(/</g, '&lt;').
                                        replace(/>/g, '&gt;');
                                        }

                                /**
                                 * create an HTML/XML writer which writes to buffer
                                 * @param {Array} buf use buf.join('') to get out sanitized html string
                                 * @returns {object} in the form of {
                                 *     start: function(tag, attrs) {},
                                 *     end: function(tag) {},
                                 *     chars: function(text) {},
                                 *     comment: function(text) {}
                                 * }
                                 */
                                function htmlSanitizeWriter(buf, uriValidator) {
                                var ignoreCurrentElement = false;
                                        var out = angular.bind(buf, buf.push);
                                        return {
                                        start: function(tag, attrs) {
                                        tag = angular.lowercase(tag);
                                                if (!ignoreCurrentElement && blockedElements[tag]) {
                                        ignoreCurrentElement = tag;
                                        }
                                        if (!ignoreCurrentElement && validElements[tag] === true) {
                                        out('<');
                                                out(tag);
                                                angular.forEach(attrs, function(value, key) {
                                                var lkey = angular.lowercase(key);
                                                        var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');
                                                        if (validAttrs[lkey] === true &&
                                                                (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
                                                out(' ');
                                                        out(key);
                                                        out('="');
                                                        out(encodeEntities(value));
                                                        out('"');
                                                }
                                                });
                                                out('>');
                                        }
                                        },
                                                end: function(tag) {
                                                tag = angular.lowercase(tag);
                                                        if (!ignoreCurrentElement && validElements[tag] === true && voidElements[tag] !== true) {
                                                out('</');
                                                        out(tag);
                                                        out('>');
                                                }
                                                if (tag == ignoreCurrentElement) {
                                                ignoreCurrentElement = false;
                                                }
                                                },
                                                chars: function(chars) {
                                                if (!ignoreCurrentElement) {
                                                out(encodeEntities(chars));
                                                }
                                                }
                                        };
                                        }


                                /**
                                 * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1' attribute to declare
                                 * ns1 namespace and prefixes the attribute with 'ns1' (e.g. 'ns1:xlink:foo'). This is undesirable since we don't want
                                 * to allow any of these custom attributes. This method strips them all.
                                 *
                                 * @param node Root element to process
                                 */
                                function stripCustomNsAttrs(node) {
                                if (node.nodeType === window.Node.ELEMENT_NODE) {
                                var attrs = node.attributes;
                                        for (var i = 0, l = attrs.length; i < l; i++) {
                                var attrNode = attrs[i];
                                        var attrName = attrNode.name.toLowerCase();
                                        if (attrName === 'xmlns:ns1' || attrName.lastIndexOf('ns1:', 0) === 0) {
                                node.removeAttributeNode(attrNode);
                                        i--;
                                        l--;
                                }
                                }
                                }

                                var nextNode = node.firstChild;
                                        if (nextNode) {
                                stripCustomNsAttrs(nextNode);
                                }

                                nextNode = node.nextSibling;
                                        if (nextNode) {
                                stripCustomNsAttrs(nextNode);
                                }
                                }



// define ngSanitize module and register $sanitize service
                                angular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);
/**!
 * AngularJS file upload directives and services. Supoorts: file upload/drop/paste, resume, cancel/abort,
 * progress, resize, thumbnail, preview, validation and CORS
 * @author  Danial  <danial.farid@gmail.com>
 * @version 12.2.13
 */

if (window.XMLHttpRequest && !(window.FileAPI && FileAPI.shouldLoad)) {
    window.XMLHttpRequest.prototype.setRequestHeader = (function (orig) {
        return function (header, value) {
            if (header === '__setXHR_') {
                var val = value(this);
                // fix for angular < 1.2.0
                if (val instanceof Function) {
                    val(this);
                }
            } else {
                orig.apply(this, arguments);
            }
        };
    })(window.XMLHttpRequest.prototype.setRequestHeader);
}

var ngFileUpload = angular.module('ngFileUpload', []);

ngFileUpload.version = '12.2.13';

ngFileUpload.service('UploadBase', ['$http', '$q', '$timeout', function ($http, $q, $timeout) {
        var upload = this;
        upload.promisesCount = 0;

        this.isResumeSupported = function () {
            return window.Blob && window.Blob.prototype.slice;
        };

        var resumeSupported = this.isResumeSupported();

        function sendHttp(config) {
            config.method = config.method || 'POST';
            config.headers = config.headers || {};

            var deferred = config._deferred = config._deferred || $q.defer();
            var promise = deferred.promise;

            function notifyProgress(e) {
                if (deferred.notify) {
                    deferred.notify(e);
                }
                if (promise.progressFunc) {
                    $timeout(function () {
                        promise.progressFunc(e);
                    });
                }
            }

            function getNotifyEvent(n) {
                if (config._start != null && resumeSupported) {
                    return {
                        loaded: n.loaded + config._start,
                        total: (config._file && config._file.size) || n.total,
                        type: n.type, config: config,
                        lengthComputable: true, target: n.target
                    };
                } else {
                    return n;
                }
            }

            if (!config.disableProgress) {
                config.headers.__setXHR_ = function () {
                    return function (xhr) {
                        if (!xhr || !xhr.upload || !xhr.upload.addEventListener)
                            return;
                        config.__XHR = xhr;
                        if (config.xhrFn)
                            config.xhrFn(xhr);
                        xhr.upload.addEventListener('progress', function (e) {
                            e.config = config;
                            notifyProgress(getNotifyEvent(e));
                        }, false);
                        //fix for firefox not firing upload progress end, also IE8-9
                        xhr.upload.addEventListener('load', function (e) {
                            if (e.lengthComputable) {
                                e.config = config;
                                notifyProgress(getNotifyEvent(e));
                            }
                        }, false);
                    };
                };
            }

            function uploadWithAngular() {
                $http(config).then(function (r) {
                    if (resumeSupported && config._chunkSize && !config._finished && config._file) {
                        var fileSize = config._file && config._file.size || 0;
                        notifyProgress({
                            loaded: Math.min(config._end, fileSize),
                            total: fileSize,
                            config: config,
                            type: 'progress'
                        }
                        );
                        upload.upload(config, true);
                    } else {
                        if (config._finished)
                            delete config._finished;
                        deferred.resolve(r);
                    }
                }, function (e) {
                    deferred.reject(e);
                }, function (n) {
                    deferred.notify(n);
                }
                );
            }

            if (!resumeSupported) {
                uploadWithAngular();
            } else if (config._chunkSize && config._end && !config._finished) {
                config._start = config._end;
                config._end += config._chunkSize;
                uploadWithAngular();
            } else if (config.resumeSizeUrl) {
                $http.get(config.resumeSizeUrl).then(function (resp) {
                    if (config.resumeSizeResponseReader) {
                        config._start = config.resumeSizeResponseReader(resp.data);
                    } else {
                        config._start = parseInt((resp.data.size == null ? resp.data : resp.data.size).toString());
                    }
                    if (config._chunkSize) {
                        config._end = config._start + config._chunkSize;
                    }
                    uploadWithAngular();
                }, function (e) {
                    throw e;
                });
            } else if (config.resumeSize) {
                config.resumeSize().then(function (size) {
                    config._start = size;
                    if (config._chunkSize) {
                        config._end = config._start + config._chunkSize;
                    }
                    uploadWithAngular();
                }, function (e) {
                    throw e;
                });
            } else {
                if (config._chunkSize) {
                    config._start = 0;
                    config._end = config._start + config._chunkSize;
                }
                uploadWithAngular();
            }


            promise.success = function (fn) {
                promise.then(function (response) {
                    fn(response.data, response.status, response.headers, config);
                });
                return promise;
            };

            promise.error = function (fn) {
                promise.then(null, function (response) {
                    fn(response.data, response.status, response.headers, config);
                });
                return promise;
            };

            promise.progress = function (fn) {
                promise.progressFunc = fn;
                promise.then(null, null, function (n) {
                    fn(n);
                });
                return promise;
            };
            promise.abort = promise.pause = function () {
                if (config.__XHR) {
                    $timeout(function () {
                        config.__XHR.abort();
                    });
                }
                return promise;
            };
            promise.xhr = function (fn) {
                config.xhrFn = (function (origXhrFn) {
                    return function () {
                        if (origXhrFn)
                            origXhrFn.apply(promise, arguments);
                        fn.apply(promise, arguments);
                    };
                })(config.xhrFn);
                return promise;
            };

            upload.promisesCount++;
            if (promise['finally'] && promise['finally'] instanceof Function) {
                promise['finally'](function () {
                    upload.promisesCount--;
                });
            }
            return promise;
        }

        this.isUploadInProgress = function () {
            return upload.promisesCount > 0;
        };

        this.rename = function (file, name) {
            file.ngfName = name;
            return file;
        };

        this.jsonBlob = function (val) {
            if (val != null && !angular.isString(val)) {
                val = JSON.stringify(val);
            }
            var blob = new window.Blob([val], {type: 'application/json'});
            blob._ngfBlob = true;
            return blob;
        };

        this.json = function (val) {
            return angular.toJson(val);
        };

        function copy(obj) {
            var clone = {};
            for (var key in obj) {
                if (obj.hasOwnProperty(key)) {
                    clone[key] = obj[key];
                }
            }
            return clone;
        }

        this.isFile = function (file) {
            return file != null && (file instanceof window.Blob || (file.flashId && file.name && file.size));
        };

        this.upload = function (config, internal) {
            function toResumeFile(file, formData) {
                if (file._ngfBlob)
                    return file;
                config._file = config._file || file;
                if (config._start != null && resumeSupported) {
                    if (config._end && config._end >= file.size) {
                        config._finished = true;
                        config._end = file.size;
                    }
                    var slice = file.slice(config._start, config._end || file.size);
                    slice.name = file.name;
                    slice.ngfName = file.ngfName;
                    if (config._chunkSize) {
                        formData.append('_chunkSize', config._chunkSize);
                        formData.append('_currentChunkSize', config._end - config._start);
                        formData.append('_chunkNumber', Math.floor(config._start / config._chunkSize));
                        formData.append('_totalSize', config._file.size);
                    }
                    return slice;
                }
                return file;
            }

            function addFieldToFormData(formData, val, key) {
                if (val !== undefined) {
                    if (angular.isDate(val)) {
                        val = val.toISOString();
                    }
                    if (angular.isString(val)) {
                        formData.append(key, val);
                    } else if (upload.isFile(val)) {
                        var file = toResumeFile(val, formData);
                        var split = key.split(',');
                        if (split[1]) {
                            file.ngfName = split[1].replace(/^\s+|\s+$/g, '');
                            key = split[0];
                        }
                        config._fileKey = config._fileKey || key;
                        formData.append(key, file, file.ngfName || file.name);
                    } else {
                        if (angular.isObject(val)) {
                            if (val.$$ngfCircularDetection)
                                throw 'ngFileUpload: Circular reference in config.data. Make sure specified data for Upload.upload() has no circular reference: ' + key;

                            val.$$ngfCircularDetection = true;
                            try {
                                for (var k in val) {
                                    if (val.hasOwnProperty(k) && k !== '$$ngfCircularDetection') {
                                        var objectKey = config.objectKey == null ? '[i]' : config.objectKey;
                                        if (val.length && parseInt(k) > -1) {
                                            objectKey = config.arrayKey == null ? objectKey : config.arrayKey;
                                        }
                                        addFieldToFormData(formData, val[k], key + objectKey.replace(/[ik]/g, k));
                                    }
                                }
                            } finally {
                                delete val.$$ngfCircularDetection;
                            }
                        } else {
                            formData.append(key, val);
                        }
                    }
                }
            }

            function digestConfig() {
                config._chunkSize = upload.translateScalars(config.resumeChunkSize);
                config._chunkSize = config._chunkSize ? parseInt(config._chunkSize.toString()) : null;

                config.headers = config.headers || {};
                config.headers['Content-Type'] = undefined;
                config.transformRequest = config.transformRequest ?
                        (angular.isArray(config.transformRequest) ?
                                config.transformRequest : [config.transformRequest]) : [];
                config.transformRequest.push(function (data) {
                    var formData = new window.FormData(), key;
                    data = data || config.fields || {};
                    if (config.file) {
                        data.file = config.file;
                    }
                    for (key in data) {
                        if (data.hasOwnProperty(key)) {
                            var val = data[key];
                            if (config.formDataAppender) {
                                config.formDataAppender(formData, key, val);
                            } else {
                                addFieldToFormData(formData, val, key);
                            }
                        }
                    }

                    return formData;
                });
            }

            if (!internal)
                config = copy(config);
            if (!config._isDigested) {
                config._isDigested = true;
                digestConfig();
            }

            return sendHttp(config);
        };

        this.http = function (config) {
            config = copy(config);
            config.transformRequest = config.transformRequest || function (data) {
                if ((window.ArrayBuffer && data instanceof window.ArrayBuffer) || data instanceof window.Blob) {
                    return data;
                }
                return $http.defaults.transformRequest[0].apply(this, arguments);
            };
            config._chunkSize = upload.translateScalars(config.resumeChunkSize);
            config._chunkSize = config._chunkSize ? parseInt(config._chunkSize.toString()) : null;

            return sendHttp(config);
        };

        this.translateScalars = function (str) {
            if (angular.isString(str)) {
                if (str.search(/kb/i) === str.length - 2) {
                    return parseFloat(str.substring(0, str.length - 2) * 1024);
                } else if (str.search(/mb/i) === str.length - 2) {
                    return parseFloat(str.substring(0, str.length - 2) * 1048576);
                } else if (str.search(/gb/i) === str.length - 2) {
                    return parseFloat(str.substring(0, str.length - 2) * 1073741824);
                } else if (str.search(/b/i) === str.length - 1) {
                    return parseFloat(str.substring(0, str.length - 1));
                } else if (str.search(/s/i) === str.length - 1) {
                    return parseFloat(str.substring(0, str.length - 1));
                } else if (str.search(/m/i) === str.length - 1) {
                    return parseFloat(str.substring(0, str.length - 1) * 60);
                } else if (str.search(/h/i) === str.length - 1) {
                    return parseFloat(str.substring(0, str.length - 1) * 3600);
                }
            }
            return str;
        };

        this.urlToBlob = function (url) {
            var defer = $q.defer();
            $http({url: url, method: 'get', responseType: 'arraybuffer'}).then(function (resp) {
                var arrayBufferView = new Uint8Array(resp.data);
                var type = resp.headers('content-type') || 'image/WebP';
                var blob = new window.Blob([arrayBufferView], {type: type});
                var matches = url.match(/.*\/(.+?)(\?.*)?$/);
                if (matches.length > 1) {
                    blob.name = matches[1];
                }
                defer.resolve(blob);
            }, function (e) {
                defer.reject(e);
            });
            return defer.promise;
        };

        this.setDefaults = function (defaults) {
            this.defaults = defaults || {};
        };

        this.defaults = {};
        this.version = ngFileUpload.version;
    }

]);

ngFileUpload.service('Upload', ['$parse', '$timeout', '$compile', '$q', 'UploadExif', function ($parse, $timeout, $compile, $q, UploadExif) {
        var upload = UploadExif;
        upload.getAttrWithDefaults = function (attr, name) {
            if (attr[name] != null)
                return attr[name];
            var def = upload.defaults[name];
            return (def == null ? def : (angular.isString(def) ? def : JSON.stringify(def)));
        };

        upload.attrGetter = function (name, attr, scope, params) {
            var attrVal = this.getAttrWithDefaults(attr, name);
            if (scope) {
                try {
                    if (params) {
                        return $parse(attrVal)(scope, params);
                    } else {
                        return $parse(attrVal)(scope);
                    }
                } catch (e) {
                    // hangle string value without single qoute
                    if (name.search(/min|max|pattern/i)) {
                        return attrVal;
                    } else {
                        throw e;
                    }
                }
            } else {
                return attrVal;
            }
        };

        upload.shouldUpdateOn = function (type, attr, scope) {
            var modelOptions = upload.attrGetter('ngfModelOptions', attr, scope);
            if (modelOptions && modelOptions.updateOn) {
                return modelOptions.updateOn.split(' ').indexOf(type) > -1;
            }
            return true;
        };

        upload.emptyPromise = function () {
            var d = $q.defer();
            var args = arguments;
            $timeout(function () {
                d.resolve.apply(d, args);
            });
            return d.promise;
        };

        upload.rejectPromise = function () {
            var d = $q.defer();
            var args = arguments;
            $timeout(function () {
                d.reject.apply(d, args);
            });
            return d.promise;
        };

        upload.happyPromise = function (promise, data) {
            var d = $q.defer();
            promise.then(function (result) {
                d.resolve(result);
            }, function (error) {
                $timeout(function () {
                    throw error;
                });
                d.resolve(data);
            });
            return d.promise;
        };

        function applyExifRotations(files, attr, scope) {
            var promises = [upload.emptyPromise()];
            angular.forEach(files, function (f, i) {
                if (f.type.indexOf('image/jpeg') === 0 && upload.attrGetter('ngfFixOrientation', attr, scope, {$file: f})) {
                    promises.push(upload.happyPromise(upload.applyExifRotation(f), f).then(function (fixedFile) {
                        files.splice(i, 1, fixedFile);
                    }));
                }
            });
            return $q.all(promises);
        }

        function resizeFile(files, attr, scope, ngModel) {
            var resizeVal = upload.attrGetter('ngfResize', attr, scope);
            if (!resizeVal || !upload.isResizeSupported() || !files.length)
                return upload.emptyPromise();
            if (resizeVal instanceof Function) {
                var defer = $q.defer();
                return resizeVal(files).then(function (p) {
                    resizeWithParams(p, files, attr, scope, ngModel).then(function (r) {
                        defer.resolve(r);
                    }, function (e) {
                        defer.reject(e);
                    });
                }, function (e) {
                    defer.reject(e);
                });
            } else {
                return resizeWithParams(resizeVal, files, attr, scope, ngModel);
            }
        }

        function resizeWithParams(params, files, attr, scope, ngModel) {
            var promises = [upload.emptyPromise()];

            function handleFile(f, i) {
                if (f.type.indexOf('image') === 0) {
                    if (params.pattern && !upload.validatePattern(f, params.pattern))
                        return;
                    params.resizeIf = function (width, height) {
                        return upload.attrGetter('ngfResizeIf', attr, scope,
                                {$width: width, $height: height, $file: f});
                    };
                    var promise = upload.resize(f, params);
                    promises.push(promise);
                    promise.then(function (resizedFile) {
                        files.splice(i, 1, resizedFile);
                    }, function (e) {
                        f.$error = 'resize';
                        (f.$errorMessages = (f.$errorMessages || {})).resize = true;
                        f.$errorParam = (e ? (e.message ? e.message : e) + ': ' : '') + (f && f.name);
                        ngModel.$ngfValidations.push({name: 'resize', valid: false});
                        upload.applyModelValidation(ngModel, files);
                    });
                }
            }

            for (var i = 0; i < files.length; i++) {
                handleFile(files[i], i);
            }
            return $q.all(promises);
        }

        upload.updateModel = function (ngModel, attr, scope, fileChange, files, evt, noDelay) {
            function update(files, invalidFiles, newFiles, dupFiles, isSingleModel) {
                attr.$$ngfPrevValidFiles = files;
                attr.$$ngfPrevInvalidFiles = invalidFiles;
                var file = files && files.length ? files[0] : null;
                var invalidFile = invalidFiles && invalidFiles.length ? invalidFiles[0] : null;

                if (ngModel) {
                    upload.applyModelValidation(ngModel, files);
                    ngModel.$setViewValue(isSingleModel ? file : files);
                }

                if (fileChange) {
                    $parse(fileChange)(scope, {
                        $files: files,
                        $file: file,
                        $newFiles: newFiles,
                        $duplicateFiles: dupFiles,
                        $invalidFiles: invalidFiles,
                        $invalidFile: invalidFile,
                        $event: evt
                    });
                }

                var invalidModel = upload.attrGetter('ngfModelInvalid', attr);
                if (invalidModel) {
                    $timeout(function () {
                        $parse(invalidModel).assign(scope, isSingleModel ? invalidFile : invalidFiles);
                    });
                }
                $timeout(function () {
                    // scope apply changes
                });
            }

            var allNewFiles, dupFiles = [], prevValidFiles, prevInvalidFiles,
                    invalids = [], valids = [];

            function removeDuplicates() {
                function equals(f1, f2) {
                    return f1.name === f2.name && (f1.$ngfOrigSize || f1.size) === (f2.$ngfOrigSize || f2.size) &&
                            f1.type === f2.type;
                }

                function isInPrevFiles(f) {
                    var j;
                    for (j = 0; j < prevValidFiles.length; j++) {
                        if (equals(f, prevValidFiles[j])) {
                            return true;
                        }
                    }
                    for (j = 0; j < prevInvalidFiles.length; j++) {
                        if (equals(f, prevInvalidFiles[j])) {
                            return true;
                        }
                    }
                    return false;
                }

                if (files) {
                    allNewFiles = [];
                    dupFiles = [];
                    for (var i = 0; i < files.length; i++) {
                        if (isInPrevFiles(files[i])) {
                            dupFiles.push(files[i]);
                        } else {
                            allNewFiles.push(files[i]);
                        }
                    }
                }
            }

            function toArray(v) {
                return angular.isArray(v) ? v : [v];
            }

            function resizeAndUpdate() {
                function updateModel() {
                    $timeout(function () {
                        update(keep ? prevValidFiles.concat(valids) : valids,
                                keep ? prevInvalidFiles.concat(invalids) : invalids,
                                files, dupFiles, isSingleModel);
                    }, options && options.debounce ? options.debounce.change || options.debounce : 0);
                }

                var resizingFiles = validateAfterResize ? allNewFiles : valids;
                resizeFile(resizingFiles, attr, scope, ngModel).then(function () {
                    if (validateAfterResize) {
                        upload.validate(allNewFiles, keep ? prevValidFiles.length : 0, ngModel, attr, scope)
                                .then(function (validationResult) {
                                    valids = validationResult.validsFiles;
                                    invalids = validationResult.invalidsFiles;
                                    updateModel();
                                });
                    } else {
                        updateModel();
                    }
                }, function () {
                    for (var i = 0; i < resizingFiles.length; i++) {
                        var f = resizingFiles[i];
                        if (f.$error === 'resize') {
                            var index = valids.indexOf(f);
                            if (index > -1) {
                                valids.splice(index, 1);
                                invalids.push(f);
                            }
                            updateModel();
                        }
                    }
                });
            }

            prevValidFiles = attr.$$ngfPrevValidFiles || [];
            prevInvalidFiles = attr.$$ngfPrevInvalidFiles || [];
            if (ngModel && ngModel.$modelValue) {
                prevValidFiles = toArray(ngModel.$modelValue);
            }

            var keep = upload.attrGetter('ngfKeep', attr, scope);
            allNewFiles = (files || []).slice(0);
            if (keep === 'distinct' || upload.attrGetter('ngfKeepDistinct', attr, scope) === true) {
                removeDuplicates(attr, scope);
            }

            var isSingleModel = !keep && !upload.attrGetter('ngfMultiple', attr, scope) && !upload.attrGetter('multiple', attr);

            if (keep && !allNewFiles.length)
                return;

            upload.attrGetter('ngfBeforeModelChange', attr, scope, {
                $files: files,
                $file: files && files.length ? files[0] : null,
                $newFiles: allNewFiles,
                $duplicateFiles: dupFiles,
                $event: evt
            });

            var validateAfterResize = upload.attrGetter('ngfValidateAfterResize', attr, scope);

            var options = upload.attrGetter('ngfModelOptions', attr, scope);
            upload.validate(allNewFiles, keep ? prevValidFiles.length : 0, ngModel, attr, scope)
                    .then(function (validationResult) {
                        if (noDelay) {
                            update(allNewFiles, [], files, dupFiles, isSingleModel);
                        } else {
                            if ((!options || !options.allowInvalid) && !validateAfterResize) {
                                valids = validationResult.validFiles;
                                invalids = validationResult.invalidFiles;
                            } else {
                                valids = allNewFiles;
                            }
                            if (upload.attrGetter('ngfFixOrientation', attr, scope) && upload.isExifSupported()) {
                                applyExifRotations(valids, attr, scope).then(function () {
                                    resizeAndUpdate();
                                });
                            } else {
                                resizeAndUpdate();
                            }
                        }
                    });
        };

        return upload;
    }]);

ngFileUpload.directive('ngfSelect', ['$parse', '$timeout', '$compile', 'Upload', function ($parse, $timeout, $compile, Upload) {
        var generatedElems = [];

        function isDelayedClickSupported(ua) {
            // fix for android native browser < 4.4 and safari windows
            var m = ua.match(/Android[^\d]*(\d+)\.(\d+)/);
            if (m && m.length > 2) {
                var v = Upload.defaults.androidFixMinorVersion || 4;
                return parseInt(m[1]) < 4 || (parseInt(m[1]) === v && parseInt(m[2]) < v);
            }

            // safari on windows
            return ua.indexOf('Chrome') === -1 && /.*Windows.*Safari.*/.test(ua);
        }

        function linkFileSelect(scope, elem, attr, ngModel, $parse, $timeout, $compile, upload) {
            /** @namespace attr.ngfSelect */
            /** @namespace attr.ngfChange */
            /** @namespace attr.ngModel */
            /** @namespace attr.ngfModelOptions */
            /** @namespace attr.ngfMultiple */
            /** @namespace attr.ngfCapture */
            /** @namespace attr.ngfValidate */
            /** @namespace attr.ngfKeep */
            var attrGetter = function (name, scope) {
                return upload.attrGetter(name, attr, scope);
            };

            function isInputTypeFile() {
                return elem[0].tagName.toLowerCase() === 'input' && attr.type && attr.type.toLowerCase() === 'file';
            }

            function fileChangeAttr() {
                return attrGetter('ngfChange') || attrGetter('ngfSelect');
            }

            function changeFn(evt) {
                if (upload.shouldUpdateOn('change', attr, scope)) {
                    var fileList = evt.__files_ || (evt.target && evt.target.files), files = [];
                    /* Handle duplicate call in  IE11 */
                    if (!fileList)
                        return;
                    for (var i = 0; i < fileList.length; i++) {
                        files.push(fileList[i]);
                    }
                    upload.updateModel(ngModel, attr, scope, fileChangeAttr(),
                            files.length ? files : null, evt);
                }
            }

            upload.registerModelChangeValidator(ngModel, attr, scope);

            var unwatches = [];
            if (attrGetter('ngfMultiple')) {
                unwatches.push(scope.$watch(attrGetter('ngfMultiple'), function () {
                    fileElem.attr('multiple', attrGetter('ngfMultiple', scope));
                }));
            }
            if (attrGetter('ngfCapture')) {
                unwatches.push(scope.$watch(attrGetter('ngfCapture'), function () {
                    fileElem.attr('capture', attrGetter('ngfCapture', scope));
                }));
            }
            if (attrGetter('ngfAccept')) {
                unwatches.push(scope.$watch(attrGetter('ngfAccept'), function () {
                    fileElem.attr('accept', attrGetter('ngfAccept', scope));
                }));
            }
            unwatches.push(attr.$observe('accept', function () {
                fileElem.attr('accept', attrGetter('accept'));
            }));
            function bindAttrToFileInput(fileElem, label) {
                function updateId(val) {
                    fileElem.attr('id', 'ngf-' + val);
                    label.attr('id', 'ngf-label-' + val);
                }

                for (var i = 0; i < elem[0].attributes.length; i++) {
                    var attribute = elem[0].attributes[i];
                    if (attribute.name !== 'type' && attribute.name !== 'class' && attribute.name !== 'style') {
                        if (attribute.name === 'id') {
                            updateId(attribute.value);
                            unwatches.push(attr.$observe('id', updateId));
                        } else {
                            fileElem.attr(attribute.name, (!attribute.value && (attribute.name === 'required' ||
                                    attribute.name === 'multiple')) ? attribute.name : attribute.value);
                        }
                    }
                }
            }

            function createFileInput() {
                if (isInputTypeFile()) {
                    return elem;
                }

                var fileElem = angular.element('<input type="file">');

                var label = angular.element('<label>upload</label>');
                label.css('visibility', 'hidden').css('position', 'absolute').css('overflow', 'hidden')
                        .css('width', '0px').css('height', '0px').css('border', 'none')
                        .css('margin', '0px').css('padding', '0px').attr('tabindex', '-1');
                bindAttrToFileInput(fileElem, label);

                generatedElems.push({el: elem, ref: label});

                document.body.appendChild(label.append(fileElem)[0]);

                return fileElem;
            }

            function clickHandler(evt) {
                if (elem.attr('disabled'))
                    return false;
                if (attrGetter('ngfSelectDisabled', scope))
                    return;

                var r = detectSwipe(evt);
                // prevent the click if it is a swipe
                if (r != null)
                    return r;

                resetModel(evt);

                // fix for md when the element is removed from the DOM and added back #460
                try {
                    if (!isInputTypeFile() && !document.body.contains(fileElem[0])) {
                        generatedElems.push({el: elem, ref: fileElem.parent()});
                        document.body.appendChild(fileElem.parent()[0]);
                        fileElem.bind('change', changeFn);
                    }
                } catch (e) {/*ignore*/
                }

                if (isDelayedClickSupported(navigator.userAgent)) {
                    setTimeout(function () {
                        fileElem[0].click();
                    }, 0);
                } else {
                    fileElem[0].click();
                }

                return false;
            }


            var initialTouchStartY = 0;
            var initialTouchStartX = 0;

            function detectSwipe(evt) {
                var touches = evt.changedTouches || (evt.originalEvent && evt.originalEvent.changedTouches);
                if (touches) {
                    if (evt.type === 'touchstart') {
                        initialTouchStartX = touches[0].clientX;
                        initialTouchStartY = touches[0].clientY;
                        return true; // don't block event default
                    } else {
                        // prevent scroll from triggering event
                        if (evt.type === 'touchend') {
                            var currentX = touches[0].clientX;
                            var currentY = touches[0].clientY;
                            if ((Math.abs(currentX - initialTouchStartX) > 20) ||
                                    (Math.abs(currentY - initialTouchStartY) > 20)) {
                                evt.stopPropagation();
                                evt.preventDefault();
                                return false;
                            }
                        }
                        return true;
                    }
                }
            }

            var fileElem = elem;

            function resetModel(evt) {
                if (upload.shouldUpdateOn('click', attr, scope) && fileElem.val()) {
                    fileElem.val(null);
                    upload.updateModel(ngModel, attr, scope, fileChangeAttr(), null, evt, true);
                }
            }

            if (!isInputTypeFile()) {
                fileElem = createFileInput();
            }
            fileElem.bind('change', changeFn);

            if (!isInputTypeFile()) {
                elem.bind('click touchstart touchend', clickHandler);
            } else {
                elem.bind('click', resetModel);
            }

            function ie10SameFileSelectFix(evt) {
                if (fileElem && !fileElem.attr('__ngf_ie10_Fix_')) {
                    if (!fileElem[0].parentNode) {
                        fileElem = null;
                        return;
                    }
                    evt.preventDefault();
                    evt.stopPropagation();
                    fileElem.unbind('click');
                    var clone = fileElem.clone();
                    fileElem.replaceWith(clone);
                    fileElem = clone;
                    fileElem.attr('__ngf_ie10_Fix_', 'true');
                    fileElem.bind('change', changeFn);
                    fileElem.bind('click', ie10SameFileSelectFix);
                    fileElem[0].click();
                    return false;
                } else {
                    fileElem.removeAttr('__ngf_ie10_Fix_');
                }
            }

            if (navigator.appVersion.indexOf('MSIE 10') !== -1) {
                fileElem.bind('click', ie10SameFileSelectFix);
            }

            if (ngModel)
                ngModel.$formatters.push(function (val) {
                    if (val == null || val.length === 0) {
                        if (fileElem.val()) {
                            fileElem.val(null);
                        }
                    }
                    return val;
                });

            scope.$on('$destroy', function () {
                if (!isInputTypeFile())
                    fileElem.parent().remove();
                angular.forEach(unwatches, function (unwatch) {
                    unwatch();
                });
            });

            $timeout(function () {
                for (var i = 0; i < generatedElems.length; i++) {
                    var g = generatedElems[i];
                    if (!document.body.contains(g.el[0])) {
                        generatedElems.splice(i, 1);
                        g.ref.remove();
                    }
                }
            });

            if (window.FileAPI && window.FileAPI.ngfFixIE) {
                window.FileAPI.ngfFixIE(elem, fileElem, changeFn);
            }
        }

        return {
            restrict: 'AEC',
            require: '?ngModel',
            link: function (scope, elem, attr, ngModel) {
                linkFileSelect(scope, elem, attr, ngModel, $parse, $timeout, $compile, Upload);
            }
        };
    }]);

(function () {

    ngFileUpload.service('UploadDataUrl', ['UploadBase', '$timeout', '$q', function (UploadBase, $timeout, $q) {
            var upload = UploadBase;
            upload.base64DataUrl = function (file) {
                if (angular.isArray(file)) {
                    var d = $q.defer(), count = 0;
                    angular.forEach(file, function (f) {
                        upload.dataUrl(f, true)['finally'](function () {
                            count++;
                            if (count === file.length) {
                                var urls = [];
                                angular.forEach(file, function (ff) {
                                    urls.push(ff.$ngfDataUrl);
                                });
                                d.resolve(urls, file);
                            }
                        });
                    });
                    return d.promise;
                } else {
                    return upload.dataUrl(file, true);
                }
            };
            upload.dataUrl = function (file, disallowObjectUrl) {
                if (!file)
                    return upload.emptyPromise(file, file);
                if ((disallowObjectUrl && file.$ngfDataUrl != null) || (!disallowObjectUrl && file.$ngfBlobUrl != null)) {
                    return upload.emptyPromise(disallowObjectUrl ? file.$ngfDataUrl : file.$ngfBlobUrl, file);
                }
                var p = disallowObjectUrl ? file.$$ngfDataUrlPromise : file.$$ngfBlobUrlPromise;
                if (p)
                    return p;

                var deferred = $q.defer();
                $timeout(function () {
                    if (window.FileReader && file &&
                            (!window.FileAPI || navigator.userAgent.indexOf('MSIE 8') === -1 || file.size < 20000) &&
                            (!window.FileAPI || navigator.userAgent.indexOf('MSIE 9') === -1 || file.size < 4000000)) {
                        //prefer URL.createObjectURL for handling refrences to files of all sizes
                        //since it doesn´t build a large string in memory
                        var URL = window.URL || window.webkitURL;
                        if (URL && URL.createObjectURL && !disallowObjectUrl) {
                            var url;
                            try {
                                url = URL.createObjectURL(file);
                            } catch (e) {
                                $timeout(function () {
                                    file.$ngfBlobUrl = '';
                                    deferred.reject();
                                });
                                return;
                            }
                            $timeout(function () {
                                file.$ngfBlobUrl = url;
                                if (url) {
                                    deferred.resolve(url, file);
                                    upload.blobUrls = upload.blobUrls || [];
                                    upload.blobUrlsTotalSize = upload.blobUrlsTotalSize || 0;
                                    upload.blobUrls.push({url: url, size: file.size});
                                    upload.blobUrlsTotalSize += file.size || 0;
                                    var maxMemory = upload.defaults.blobUrlsMaxMemory || 268435456;
                                    var maxLength = upload.defaults.blobUrlsMaxQueueSize || 200;
                                    while ((upload.blobUrlsTotalSize > maxMemory || upload.blobUrls.length > maxLength) && upload.blobUrls.length > 1) {
                                        var obj = upload.blobUrls.splice(0, 1)[0];
                                        URL.revokeObjectURL(obj.url);
                                        upload.blobUrlsTotalSize -= obj.size;
                                    }
                                }
                            });
                        } else {
                            var fileReader = new FileReader();
                            fileReader.onload = function (e) {
                                $timeout(function () {
                                    file.$ngfDataUrl = e.target.result;
                                    deferred.resolve(e.target.result, file);
                                    $timeout(function () {
                                        delete file.$ngfDataUrl;
                                    }, 1000);
                                });
                            };
                            fileReader.onerror = function () {
                                $timeout(function () {
                                    file.$ngfDataUrl = '';
                                    deferred.reject();
                                });
                            };
                            fileReader.readAsDataURL(file);
                        }
                    } else {
                        $timeout(function () {
                            file[disallowObjectUrl ? '$ngfDataUrl' : '$ngfBlobUrl'] = '';
                            deferred.reject();
                        });
                    }
                });

                if (disallowObjectUrl) {
                    p = file.$$ngfDataUrlPromise = deferred.promise;
                } else {
                    p = file.$$ngfBlobUrlPromise = deferred.promise;
                }
                p['finally'](function () {
                    delete file[disallowObjectUrl ? '$$ngfDataUrlPromise' : '$$ngfBlobUrlPromise'];
                });
                return p;
            };
            return upload;
        }]);

    function getTagType(el) {
        if (el.tagName.toLowerCase() === 'img')
            return 'image';
        if (el.tagName.toLowerCase() === 'audio')
            return 'audio';
        if (el.tagName.toLowerCase() === 'video')
            return 'video';
        return /./;
    }

    function linkFileDirective(Upload, $timeout, scope, elem, attr, directiveName, resizeParams, isBackground) {
        function constructDataUrl(file) {
            var disallowObjectUrl = Upload.attrGetter('ngfNoObjectUrl', attr, scope);
            Upload.dataUrl(file, disallowObjectUrl)['finally'](function () {
                $timeout(function () {
                    var src = (disallowObjectUrl ? file.$ngfDataUrl : file.$ngfBlobUrl) || file.$ngfDataUrl;
                    if (isBackground) {
                        elem.css('background-image', 'url(\'' + (src || '') + '\')');
                    } else {
                        elem.attr('src', src);
                    }
                    if (src) {
                        elem.removeClass('ng-hide');
                    } else {
                        elem.addClass('ng-hide');
                    }
                });
            });
        }

        $timeout(function () {
            var unwatch = scope.$watch(attr[directiveName], function (file) {
                var size = resizeParams;
                if (directiveName === 'ngfThumbnail') {
                    if (!size) {
                        size = {
                            width: elem[0].naturalWidth || elem[0].clientWidth,
                            height: elem[0].naturalHeight || elem[0].clientHeight
                        };
                    }
                    if (size.width === 0 && window.getComputedStyle) {
                        var style = getComputedStyle(elem[0]);
                        if (style.width && style.width.indexOf('px') > -1 && style.height && style.height.indexOf('px') > -1) {
                            size = {
                                width: parseInt(style.width.slice(0, -2)),
                                height: parseInt(style.height.slice(0, -2))
                            };
                        }
                    }
                }

                if (angular.isString(file)) {
                    elem.removeClass('ng-hide');
                    if (isBackground) {
                        return elem.css('background-image', 'url(\'' + file + '\')');
                    } else {
                        return elem.attr('src', file);
                    }
                }
                if (file && file.type && file.type.search(getTagType(elem[0])) === 0 &&
                        (!isBackground || file.type.indexOf('image') === 0)) {
                    if (size && Upload.isResizeSupported()) {
                        size.resizeIf = function (width, height) {
                            return Upload.attrGetter('ngfResizeIf', attr, scope,
                                    {$width: width, $height: height, $file: file});
                        };
                        Upload.resize(file, size).then(
                                function (f) {
                                    constructDataUrl(f);
                                }, function (e) {
                            throw e;
                        }
                        );
                    } else {
                        constructDataUrl(file);
                    }
                } else {
                    elem.addClass('ng-hide');
                }
            });

            scope.$on('$destroy', function () {
                unwatch();
            });
        });
    }


    /** @namespace attr.ngfSrc */
    /** @namespace attr.ngfNoObjectUrl */
    ngFileUpload.directive('ngfSrc', ['Upload', '$timeout', function (Upload, $timeout) {
            return {
                restrict: 'AE',
                link: function (scope, elem, attr) {
                    linkFileDirective(Upload, $timeout, scope, elem, attr, 'ngfSrc',
                            Upload.attrGetter('ngfResize', attr, scope), false);
                }
            };
        }]);

    /** @namespace attr.ngfBackground */
    /** @namespace attr.ngfNoObjectUrl */
    ngFileUpload.directive('ngfBackground', ['Upload', '$timeout', function (Upload, $timeout) {
            return {
                restrict: 'AE',
                link: function (scope, elem, attr) {
                    linkFileDirective(Upload, $timeout, scope, elem, attr, 'ngfBackground',
                            Upload.attrGetter('ngfResize', attr, scope), true);
                }
            };
        }]);

    /** @namespace attr.ngfThumbnail */
    /** @namespace attr.ngfAsBackground */
    /** @namespace attr.ngfSize */
    /** @namespace attr.ngfNoObjectUrl */
    ngFileUpload.directive('ngfThumbnail', ['Upload', '$timeout', function (Upload, $timeout) {
            return {
                restrict: 'AE',
                link: function (scope, elem, attr) {
                    var size = Upload.attrGetter('ngfSize', attr, scope);
                    linkFileDirective(Upload, $timeout, scope, elem, attr, 'ngfThumbnail', size,
                            Upload.attrGetter('ngfAsBackground', attr, scope));
                }
            };
        }]);

    ngFileUpload.config(['$compileProvider', function ($compileProvider) {
            if ($compileProvider.imgSrcSanitizationWhitelist)
                $compileProvider.imgSrcSanitizationWhitelist(/^\s*(https?|ftp|mailto|tel|webcal|local|file|data|blob):/);
            if ($compileProvider.aHrefSanitizationWhitelist)
                $compileProvider.aHrefSanitizationWhitelist(/^\s*(https?|ftp|mailto|tel|webcal|local|file|data|blob):/);
        }]);

    ngFileUpload.filter('ngfDataUrl', ['UploadDataUrl', '$sce', function (UploadDataUrl, $sce) {
            return function (file, disallowObjectUrl, trustedUrl) {
                if (angular.isString(file)) {
                    return $sce.trustAsResourceUrl(file);
                }
                var src = file && ((disallowObjectUrl ? file.$ngfDataUrl : file.$ngfBlobUrl) || file.$ngfDataUrl);
                if (file && !src) {
                    if (!file.$ngfDataUrlFilterInProgress && angular.isObject(file)) {
                        file.$ngfDataUrlFilterInProgress = true;
                        UploadDataUrl.dataUrl(file, disallowObjectUrl);
                    }
                    return '';
                }
                if (file)
                    delete file.$ngfDataUrlFilterInProgress;
                return (file && src ? (trustedUrl ? $sce.trustAsResourceUrl(src) : src) : file) || '';
            };
        }]);

})();

ngFileUpload.service('UploadValidate', ['UploadDataUrl', '$q', '$timeout', function (UploadDataUrl, $q, $timeout) {
        var upload = UploadDataUrl;

        function globStringToRegex(str) {
            var regexp = '', excludes = [];
            if (str.length > 2 && str[0] === '/' && str[str.length - 1] === '/') {
                regexp = str.substring(1, str.length - 1);
            } else {
                var split = str.split(',');
                if (split.length > 1) {
                    for (var i = 0; i < split.length; i++) {
                        var r = globStringToRegex(split[i]);
                        if (r.regexp) {
                            regexp += '(' + r.regexp + ')';
                            if (i < split.length - 1) {
                                regexp += '|';
                            }
                        } else {
                            excludes = excludes.concat(r.excludes);
                        }
                    }
                } else {
                    if (str.indexOf('!') === 0) {
                        excludes.push('^((?!' + globStringToRegex(str.substring(1)).regexp + ').)*$');
                    } else {
                        if (str.indexOf('.') === 0) {
                            str = '*' + str;
                        }
                        regexp = '^' + str.replace(new RegExp('[.\\\\+*?\\[\\^\\]$(){}=!<>|:\\-]', 'g'), '\\$&') + '$';
                        regexp = regexp.replace(/\\\*/g, '.*').replace(/\\\?/g, '.');
                    }
                }
            }
            return {regexp: regexp, excludes: excludes};
        }

        upload.validatePattern = function (file, val) {
            if (!val) {
                return true;
            }
            var pattern = globStringToRegex(val), valid = true;
            if (pattern.regexp && pattern.regexp.length) {
                var regexp = new RegExp(pattern.regexp, 'i');
                valid = (file.type != null && regexp.test(file.type)) ||
                        (file.name != null && regexp.test(file.name));
            }
            var len = pattern.excludes.length;
            while (len--) {
                var exclude = new RegExp(pattern.excludes[len], 'i');
                valid = valid && (file.type == null || exclude.test(file.type)) &&
                        (file.name == null || exclude.test(file.name));
            }
            return valid;
        };

        upload.ratioToFloat = function (val) {
            var r = val.toString(), xIndex = r.search(/[x:]/i);
            if (xIndex > -1) {
                r = parseFloat(r.substring(0, xIndex)) / parseFloat(r.substring(xIndex + 1));
            } else {
                r = parseFloat(r);
            }
            return r;
        };

        upload.registerModelChangeValidator = function (ngModel, attr, scope) {
            if (ngModel) {
                ngModel.$formatters.push(function (files) {
                    if (ngModel.$dirty) {
                        var filesArray = files;
                        if (files && !angular.isArray(files)) {
                            filesArray = [files];
                        }
                        upload.validate(filesArray, 0, ngModel, attr, scope).then(function () {
                            upload.applyModelValidation(ngModel, filesArray);
                        });
                    }
                    return files;
                });
            }
        };

        function markModelAsDirty(ngModel, files) {
            if (files != null && !ngModel.$dirty) {
                if (ngModel.$setDirty) {
                    ngModel.$setDirty();
                } else {
                    ngModel.$dirty = true;
                }
            }
        }

        upload.applyModelValidation = function (ngModel, files) {
            markModelAsDirty(ngModel, files);
            angular.forEach(ngModel.$ngfValidations, function (validation) {
                ngModel.$setValidity(validation.name, validation.valid);
            });
        };

        upload.getValidationAttr = function (attr, scope, name, validationName, file) {
            var dName = 'ngf' + name[0].toUpperCase() + name.substr(1);
            var val = upload.attrGetter(dName, attr, scope, {$file: file});
            if (val == null) {
                val = upload.attrGetter('ngfValidate', attr, scope, {$file: file});
                if (val) {
                    var split = (validationName || name).split('.');
                    val = val[split[0]];
                    if (split.length > 1) {
                        val = val && val[split[1]];
                    }
                }
            }
            return val;
        };

        upload.validate = function (files, prevLength, ngModel, attr, scope) {
            ngModel = ngModel || {};
            ngModel.$ngfValidations = ngModel.$ngfValidations || [];

            angular.forEach(ngModel.$ngfValidations, function (v) {
                v.valid = true;
            });

            var attrGetter = function (name, params) {
                return upload.attrGetter(name, attr, scope, params);
            };

            var ignoredErrors = (upload.attrGetter('ngfIgnoreInvalid', attr, scope) || '').split(' ');
            var runAllValidation = upload.attrGetter('ngfRunAllValidations', attr, scope);

            if (files == null || files.length === 0) {
                return upload.emptyPromise({'validFiles': files, 'invalidFiles': []});
            }

            files = files.length === undefined ? [files] : files.slice(0);
            var invalidFiles = [];

            function validateSync(name, validationName, fn) {
                if (files) {
                    var i = files.length, valid = null;
                    while (i--) {
                        var file = files[i];
                        if (file) {
                            var val = upload.getValidationAttr(attr, scope, name, validationName, file);
                            if (val != null) {
                                if (!fn(file, val, i)) {
                                    if (ignoredErrors.indexOf(name) === -1) {
                                        file.$error = name;
                                        (file.$errorMessages = (file.$errorMessages || {}))[name] = true;
                                        file.$errorParam = val;
                                        if (invalidFiles.indexOf(file) === -1) {
                                            invalidFiles.push(file);
                                        }
                                        if (!runAllValidation) {
                                            files.splice(i, 1);
                                        }
                                        valid = false;
                                    } else {
                                        files.splice(i, 1);
                                    }
                                }
                            }
                        }
                    }
                    if (valid !== null) {
                        ngModel.$ngfValidations.push({name: name, valid: valid});
                    }
                }
            }

            validateSync('pattern', null, upload.validatePattern);
            validateSync('minSize', 'size.min', function (file, val) {
                return file.size + 0.1 >= upload.translateScalars(val);
            });
            validateSync('maxSize', 'size.max', function (file, val) {
                return file.size - 0.1 <= upload.translateScalars(val);
            });
            var totalSize = 0;
            validateSync('maxTotalSize', null, function (file, val) {
                totalSize += file.size;
                if (totalSize > upload.translateScalars(val)) {
                    files.splice(0, files.length);
                    return false;
                }
                return true;
            });

            validateSync('validateFn', null, function (file, r) {
                return r === true || r === null || r === '';
            });

            if (!files.length) {
                return upload.emptyPromise({'validFiles': [], 'invalidFiles': invalidFiles});
            }

            function validateAsync(name, validationName, type, asyncFn, fn) {
                function resolveResult(defer, file, val) {
                    function resolveInternal(fn) {
                        if (fn()) {
                            if (ignoredErrors.indexOf(name) === -1) {
                                file.$error = name;
                                (file.$errorMessages = (file.$errorMessages || {}))[name] = true;
                                file.$errorParam = val;
                                if (invalidFiles.indexOf(file) === -1) {
                                    invalidFiles.push(file);
                                }
                                if (!runAllValidation) {
                                    var i = files.indexOf(file);
                                    if (i > -1)
                                        files.splice(i, 1);
                                }
                                defer.resolve(false);
                            } else {
                                var j = files.indexOf(file);
                                if (j > -1)
                                    files.splice(j, 1);
                                defer.resolve(true);
                            }
                        } else {
                            defer.resolve(true);
                        }
                    }

                    if (val != null) {
                        asyncFn(file, val).then(function (d) {
                            resolveInternal(function () {
                                return !fn(d, val);
                            });
                        }, function () {
                            resolveInternal(function () {
                                return attrGetter('ngfValidateForce', {$file: file});
                            });
                        });
                    } else {
                        defer.resolve(true);
                    }
                }

                var promises = [upload.emptyPromise(true)];
                if (files) {
                    files = files.length === undefined ? [files] : files;
                    angular.forEach(files, function (file) {
                        var defer = $q.defer();
                        promises.push(defer.promise);
                        if (type && (file.type == null || file.type.search(type) !== 0)) {
                            defer.resolve(true);
                            return;
                        }
                        if (name === 'dimensions' && upload.attrGetter('ngfDimensions', attr) != null) {
                            upload.imageDimensions(file).then(function (d) {
                                resolveResult(defer, file,
                                        attrGetter('ngfDimensions', {$file: file, $width: d.width, $height: d.height}));
                            }, function () {
                                defer.resolve(false);
                            });
                        } else if (name === 'duration' && upload.attrGetter('ngfDuration', attr) != null) {
                            upload.mediaDuration(file).then(function (d) {
                                resolveResult(defer, file,
                                        attrGetter('ngfDuration', {$file: file, $duration: d}));
                            }, function () {
                                defer.resolve(false);
                            });
                        } else {
                            resolveResult(defer, file,
                                    upload.getValidationAttr(attr, scope, name, validationName, file));
                        }
                    });
                }
                var deffer = $q.defer();
                $q.all(promises).then(function (values) {
                    var isValid = true;
                    for (var i = 0; i < values.length; i++) {
                        if (!values[i]) {
                            isValid = false;
                            break;
                        }
                    }
                    ngModel.$ngfValidations.push({name: name, valid: isValid});
                    deffer.resolve(isValid);
                });
                return deffer.promise;
            }

            var deffer = $q.defer();
            var promises = [];

            promises.push(validateAsync('maxHeight', 'height.max', /image/,
                    this.imageDimensions, function (d, val) {
                        return d.height <= val;
                    }));
            promises.push(validateAsync('minHeight', 'height.min', /image/,
                    this.imageDimensions, function (d, val) {
                        return d.height >= val;
                    }));
            promises.push(validateAsync('maxWidth', 'width.max', /image/,
                    this.imageDimensions, function (d, val) {
                        return d.width <= val;
                    }));
            promises.push(validateAsync('minWidth', 'width.min', /image/,
                    this.imageDimensions, function (d, val) {
                        return d.width >= val;
                    }));
            promises.push(validateAsync('dimensions', null, /image/,
                    function (file, val) {
                        return upload.emptyPromise(val);
                    }, function (r) {
                return r;
            }));
            promises.push(validateAsync('ratio', null, /image/,
                    this.imageDimensions, function (d, val) {
                        var split = val.toString().split(','), valid = false;
                        for (var i = 0; i < split.length; i++) {
                            if (Math.abs((d.width / d.height) - upload.ratioToFloat(split[i])) < 0.01) {
                                valid = true;
                            }
                        }
                        return valid;
                    }));
            promises.push(validateAsync('maxRatio', 'ratio.max', /image/,
                    this.imageDimensions, function (d, val) {
                        return (d.width / d.height) - upload.ratioToFloat(val) < 0.0001;
                    }));
            promises.push(validateAsync('minRatio', 'ratio.min', /image/,
                    this.imageDimensions, function (d, val) {
                        return (d.width / d.height) - upload.ratioToFloat(val) > -0.0001;
                    }));
            promises.push(validateAsync('maxDuration', 'duration.max', /audio|video/,
                    this.mediaDuration, function (d, val) {
                        return d <= upload.translateScalars(val);
                    }));
            promises.push(validateAsync('minDuration', 'duration.min', /audio|video/,
                    this.mediaDuration, function (d, val) {
                        return d >= upload.translateScalars(val);
                    }));
            promises.push(validateAsync('duration', null, /audio|video/,
                    function (file, val) {
                        return upload.emptyPromise(val);
                    }, function (r) {
                return r;
            }));

            promises.push(validateAsync('validateAsyncFn', null, null,
                    function (file, val) {
                        return val;
                    }, function (r) {
                return r === true || r === null || r === '';
            }));

            $q.all(promises).then(function () {

                if (runAllValidation) {
                    for (var i = 0; i < files.length; i++) {
                        var file = files[i];
                        if (file.$error) {
                            files.splice(i--, 1);
                        }
                    }
                }

                runAllValidation = false;
                validateSync('maxFiles', null, function (file, val, i) {
                    return prevLength + i < val;
                });

                deffer.resolve({'validFiles': files, 'invalidFiles': invalidFiles});
            });
            return deffer.promise;
        };

        upload.imageDimensions = function (file) {
            if (file.$ngfWidth && file.$ngfHeight) {
                var d = $q.defer();
                $timeout(function () {
                    d.resolve({width: file.$ngfWidth, height: file.$ngfHeight});
                });
                return d.promise;
            }
            if (file.$ngfDimensionPromise)
                return file.$ngfDimensionPromise;

            var deferred = $q.defer();
            $timeout(function () {
                if (file.type.indexOf('image') !== 0) {
                    deferred.reject('not image');
                    return;
                }
                upload.dataUrl(file).then(function (dataUrl) {
                    var img = angular.element('<img>').attr('src', dataUrl)
                            .css('visibility', 'hidden').css('position', 'fixed')
                            .css('max-width', 'none !important').css('max-height', 'none !important');

                    function success() {
                        var width = img[0].naturalWidth || img[0].clientWidth;
                        var height = img[0].naturalHeight || img[0].clientHeight;
                        img.remove();
                        file.$ngfWidth = width;
                        file.$ngfHeight = height;
                        deferred.resolve({width: width, height: height});
                    }

                    function error() {
                        img.remove();
                        deferred.reject('load error');
                    }

                    img.on('load', success);
                    img.on('error', error);

                    var secondsCounter = 0;
                    function checkLoadErrorInCaseOfNoCallback() {
                        $timeout(function () {
                            if (img[0].parentNode) {
                                if (img[0].clientWidth) {
                                    success();
                                } else if (secondsCounter++ > 10) {
                                    error();
                                } else {
                                    checkLoadErrorInCaseOfNoCallback();
                                }
                            }
                        }, 1000);
                    }

                    checkLoadErrorInCaseOfNoCallback();

                    angular.element(document.getElementsByTagName('body')[0]).append(img);
                }, function () {
                    deferred.reject('load error');
                });
            });

            file.$ngfDimensionPromise = deferred.promise;
            file.$ngfDimensionPromise['finally'](function () {
                delete file.$ngfDimensionPromise;
            });
            return file.$ngfDimensionPromise;
        };

        upload.mediaDuration = function (file) {
            if (file.$ngfDuration) {
                var d = $q.defer();
                $timeout(function () {
                    d.resolve(file.$ngfDuration);
                });
                return d.promise;
            }
            if (file.$ngfDurationPromise)
                return file.$ngfDurationPromise;

            var deferred = $q.defer();
            $timeout(function () {
                if (file.type.indexOf('audio') !== 0 && file.type.indexOf('video') !== 0) {
                    deferred.reject('not media');
                    return;
                }
                upload.dataUrl(file).then(function (dataUrl) {
                    var el = angular.element(file.type.indexOf('audio') === 0 ? '<audio>' : '<video>')
                            .attr('src', dataUrl).css('visibility', 'none').css('position', 'fixed');

                    function success() {
                        var duration = el[0].duration;
                        file.$ngfDuration = duration;
                        el.remove();
                        deferred.resolve(duration);
                    }

                    function error() {
                        el.remove();
                        deferred.reject('load error');
                    }

                    el.on('loadedmetadata', success);
                    el.on('error', error);
                    var count = 0;

                    function checkLoadError() {
                        $timeout(function () {
                            if (el[0].parentNode) {
                                if (el[0].duration) {
                                    success();
                                } else if (count > 10) {
                                    error();
                                } else {
                                    checkLoadError();
                                }
                            }
                        }, 1000);
                    }

                    checkLoadError();

                    angular.element(document.body).append(el);
                }, function () {
                    deferred.reject('load error');
                });
            });

            file.$ngfDurationPromise = deferred.promise;
            file.$ngfDurationPromise['finally'](function () {
                delete file.$ngfDurationPromise;
            });
            return file.$ngfDurationPromise;
        };
        return upload;
    }
]);

ngFileUpload.service('UploadResize', ['UploadValidate', '$q', function (UploadValidate, $q) {
        var upload = UploadValidate;

        /**
         * Conserve aspect ratio of the original region. Useful when shrinking/enlarging
         * images to fit into a certain area.
         * Source:  http://stackoverflow.com/a/14731922
         *
         * @param {Number} srcWidth Source area width
         * @param {Number} srcHeight Source area height
         * @param {Number} maxWidth Nestable area maximum available width
         * @param {Number} maxHeight Nestable area maximum available height
         * @return {Object} { width, height }
         */
        var calculateAspectRatioFit = function (srcWidth, srcHeight, maxWidth, maxHeight, centerCrop) {
            var ratio = centerCrop ? Math.max(maxWidth / srcWidth, maxHeight / srcHeight) :
                    Math.min(maxWidth / srcWidth, maxHeight / srcHeight);
            return {
                width: srcWidth * ratio, height: srcHeight * ratio,
                marginX: srcWidth * ratio - maxWidth, marginY: srcHeight * ratio - maxHeight
            };
        };

        // Extracted from https://github.com/romelgomez/angular-firebase-image-upload/blob/master/app/scripts/fileUpload.js#L89
        var resize = function (imagen, width, height, quality, type, ratio, centerCrop, resizeIf) {
            var deferred = $q.defer();
            var canvasElement = document.createElement('canvas');
            var imageElement = document.createElement('img');
            imageElement.setAttribute('style', 'visibility:hidden;position:fixed;z-index:-100000');
            document.body.appendChild(imageElement);

            imageElement.onload = function () {
                var imgWidth = imageElement.width, imgHeight = imageElement.height;
                imageElement.parentNode.removeChild(imageElement);
                if (resizeIf != null && resizeIf(imgWidth, imgHeight) === false) {
                    deferred.reject('resizeIf');
                    return;
                }
                try {
                    if (ratio) {
                        var ratioFloat = upload.ratioToFloat(ratio);
                        var imgRatio = imgWidth / imgHeight;
                        if (imgRatio < ratioFloat) {
                            width = imgWidth;
                            height = width / ratioFloat;
                        } else {
                            height = imgHeight;
                            width = height * ratioFloat;
                        }
                    }
                    if (!width) {
                        width = imgWidth;
                    }
                    if (!height) {
                        height = imgHeight;
                    }
                    var dimensions = calculateAspectRatioFit(imgWidth, imgHeight, width, height, centerCrop);
                    canvasElement.width = Math.min(dimensions.width, width);
                    canvasElement.height = Math.min(dimensions.height, height);
                    var context = canvasElement.getContext('2d');
                    context.drawImage(imageElement,
                            Math.min(0, -dimensions.marginX / 2), Math.min(0, -dimensions.marginY / 2),
                            dimensions.width, dimensions.height);
                    deferred.resolve(canvasElement.toDataURL(type || 'image/WebP', quality || 0.934));
                } catch (e) {
                    deferred.reject(e);
                }
            };
            imageElement.onerror = function () {
                imageElement.parentNode.removeChild(imageElement);
                deferred.reject();
            };
            imageElement.src = imagen;
            return deferred.promise;
        };

        upload.dataUrltoBlob = function (dataurl, name, origSize) {
            var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1],
                    bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);
            while (n--) {
                u8arr[n] = bstr.charCodeAt(n);
            }
            var blob = new window.Blob([u8arr], {type: mime});
            blob.name = name;
            blob.$ngfOrigSize = origSize;
            return blob;
        };

        upload.isResizeSupported = function () {
            var elem = document.createElement('canvas');
            return window.atob && elem.getContext && elem.getContext('2d') && window.Blob;
        };

        if (upload.isResizeSupported()) {
            // add name getter to the blob constructor prototype
            Object.defineProperty(window.Blob.prototype, 'name', {
                get: function () {
                    return this.$ngfName;
                },
                set: function (v) {
                    this.$ngfName = v;
                },
                configurable: true
            });
        }

        upload.resize = function (file, options) {
            if (file.type.indexOf('image') !== 0)
                return upload.emptyPromise(file);

            var deferred = $q.defer();
            upload.dataUrl(file, true).then(function (url) {
                resize(url, options.width, options.height, options.quality, options.type || file.type,
                        options.ratio, options.centerCrop, options.resizeIf)
                        .then(function (dataUrl) {
                            if (file.type === 'image/jpeg' && options.restoreExif !== false) {
                                try {
                                    dataUrl = upload.restoreExif(url, dataUrl);
                                } catch (e) {
                                    setTimeout(function () {
                                        throw e;
                                    }, 1);
                                }
                            }
                            try {
                                var blob = upload.dataUrltoBlob(dataUrl, file.name, file.size);
                                deferred.resolve(blob);
                            } catch (e) {
                                deferred.reject(e);
                            }
                        }, function (r) {
                            if (r === 'resizeIf') {
                                deferred.resolve(file);
                            }
                            deferred.reject(r);
                        });
            }, function (e) {
                deferred.reject(e);
            });
            return deferred.promise;
        };

        return upload;
    }]);

(function () {
    ngFileUpload.directive('ngfDrop', ['$parse', '$timeout', '$window', 'Upload', '$http', '$q',
        function ($parse, $timeout, $window, Upload, $http, $q) {
            return {
                restrict: 'AEC',
                require: '?ngModel',
                link: function (scope, elem, attr, ngModel) {
                    linkDrop(scope, elem, attr, ngModel, $parse, $timeout, $window, Upload, $http, $q);
                }
            };
        }]);

    ngFileUpload.directive('ngfNoFileDrop', function () {
        return function (scope, elem) {
            if (dropAvailable())
                elem.css('display', 'none');
        };
    });

    ngFileUpload.directive('ngfDropAvailable', ['$parse', '$timeout', 'Upload', function ($parse, $timeout, Upload) {
            return function (scope, elem, attr) {
                if (dropAvailable()) {
                    var model = $parse(Upload.attrGetter('ngfDropAvailable', attr));
                    $timeout(function () {
                        model(scope);
                        if (model.assign) {
                            model.assign(scope, true);
                        }
                    });
                }
            };
        }]);

    function linkDrop(scope, elem, attr, ngModel, $parse, $timeout, $window, upload, $http, $q) {
        var available = dropAvailable();

        var attrGetter = function (name, scope, params) {
            return upload.attrGetter(name, attr, scope, params);
        };

        if (attrGetter('dropAvailable')) {
            $timeout(function () {
                if (scope[attrGetter('dropAvailable')]) {
                    scope[attrGetter('dropAvailable')].value = available;
                } else {
                    scope[attrGetter('dropAvailable')] = available;
                }
            });
        }
        if (!available) {
            if (attrGetter('ngfHideOnDropNotAvailable', scope) === true) {
                elem.css('display', 'none');
            }
            return;
        }

        function isDisabled() {
            return elem.attr('disabled') || attrGetter('ngfDropDisabled', scope);
        }

        if (attrGetter('ngfSelect') == null) {
            upload.registerModelChangeValidator(ngModel, attr, scope);
        }

        var leaveTimeout = null;
        var stopPropagation = $parse(attrGetter('ngfStopPropagation'));
        var dragOverDelay = 1;
        var actualDragOverClass;

        elem[0].addEventListener('dragover', function (evt) {
            if (isDisabled() || !upload.shouldUpdateOn('drop', attr, scope))
                return;
            evt.preventDefault();
            if (stopPropagation(scope))
                evt.stopPropagation();
            // handling dragover events from the Chrome download bar
            if (navigator.userAgent.indexOf('Chrome') > -1) {
                var b = evt.dataTransfer.effectAllowed;
                evt.dataTransfer.dropEffect = ('move' === b || 'linkMove' === b) ? 'move' : 'copy';
            }
            $timeout.cancel(leaveTimeout);
            if (!actualDragOverClass) {
                actualDragOverClass = 'C';
                calculateDragOverClass(scope, attr, evt, function (clazz) {
                    actualDragOverClass = clazz;
                    elem.addClass(actualDragOverClass);
                    attrGetter('ngfDrag', scope, {$isDragging: true, $class: actualDragOverClass, $event: evt});
                });
            }
        }, false);
        elem[0].addEventListener('dragenter', function (evt) {
            if (isDisabled() || !upload.shouldUpdateOn('drop', attr, scope))
                return;
            evt.preventDefault();
            if (stopPropagation(scope))
                evt.stopPropagation();
        }, false);
        elem[0].addEventListener('dragleave', function (evt) {
            if (isDisabled() || !upload.shouldUpdateOn('drop', attr, scope))
                return;
            evt.preventDefault();
            if (stopPropagation(scope))
                evt.stopPropagation();
            leaveTimeout = $timeout(function () {
                if (actualDragOverClass)
                    elem.removeClass(actualDragOverClass);
                actualDragOverClass = null;
                attrGetter('ngfDrag', scope, {$isDragging: false, $event: evt});
            }, dragOverDelay || 100);
        }, false);
        elem[0].addEventListener('drop', function (evt) {
            if (isDisabled() || !upload.shouldUpdateOn('drop', attr, scope))
                return;
            evt.preventDefault();
            if (stopPropagation(scope))
                evt.stopPropagation();
            if (actualDragOverClass)
                elem.removeClass(actualDragOverClass);
            actualDragOverClass = null;
            extractFilesAndUpdateModel(evt.dataTransfer, evt, 'dropUrl');
        }, false);
        elem[0].addEventListener('paste', function (evt) {
            if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1 &&
                    attrGetter('ngfEnableFirefoxPaste', scope)) {
                evt.preventDefault();
            }
            if (isDisabled() || !upload.shouldUpdateOn('paste', attr, scope))
                return;
            extractFilesAndUpdateModel(evt.clipboardData || evt.originalEvent.clipboardData, evt, 'pasteUrl');
        }, false);

        if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1 &&
                attrGetter('ngfEnableFirefoxPaste', scope)) {
            elem.attr('contenteditable', true);
            elem.on('keypress', function (e) {
                if (!e.metaKey && !e.ctrlKey) {
                    e.preventDefault();
                }
            });
        }

        function extractFilesAndUpdateModel(source, evt, updateOnType) {
            if (!source)
                return;
            // html needs to be calculated on the same process otherwise the data will be wiped
            // after promise resolve or setTimeout.
            var html;
            try {
                html = source && source.getData && source.getData('text/html');
            } catch (e) {/* Fix IE11 that throw error calling getData */
            }
            extractFiles(source.items, source.files, attrGetter('ngfAllowDir', scope) !== false,
                    attrGetter('multiple') || attrGetter('ngfMultiple', scope)).then(function (files) {
                if (files.length) {
                    updateModel(files, evt);
                } else {
                    extractFilesFromHtml(updateOnType, html).then(function (files) {
                        updateModel(files, evt);
                    });
                }
            });
        }

        function updateModel(files, evt) {
            upload.updateModel(ngModel, attr, scope, attrGetter('ngfChange') || attrGetter('ngfDrop'), files, evt);
        }

        function extractFilesFromHtml(updateOn, html) {
            if (!upload.shouldUpdateOn(updateOn, attr, scope) || typeof html !== 'string')
                return upload.rejectPromise([]);
            var urls = [];
            html.replace(/<(img src|img [^>]* src) *=\"([^\"]*)\"/gi, function (m, n, src) {
                urls.push(src);
            });
            var promises = [], files = [];
            if (urls.length) {
                angular.forEach(urls, function (url) {
                    promises.push(upload.urlToBlob(url).then(function (blob) {
                        files.push(blob);
                    }));
                });
                var defer = $q.defer();
                $q.all(promises).then(function () {
                    defer.resolve(files);
                }, function (e) {
                    defer.reject(e);
                });
                return defer.promise;
            }
            return upload.emptyPromise();
        }

        function calculateDragOverClass(scope, attr, evt, callback) {
            var obj = attrGetter('ngfDragOverClass', scope, {$event: evt}), dClass = 'dragover';
            if (angular.isString(obj)) {
                dClass = obj;
            } else if (obj) {
                if (obj.delay)
                    dragOverDelay = obj.delay;
                if (obj.accept || obj.reject) {
                    var items = evt.dataTransfer.items;
                    if (items == null || !items.length) {
                        dClass = obj.accept;
                    } else {
                        var pattern = obj.pattern || attrGetter('ngfPattern', scope, {$event: evt});
                        var len = items.length;
                        while (len--) {
                            if (!upload.validatePattern(items[len], pattern)) {
                                dClass = obj.reject;
                                break;
                            } else {
                                dClass = obj.accept;
                            }
                        }
                    }
                }
            }
            callback(dClass);
        }

        function extractFiles(items, fileList, allowDir, multiple) {
            var maxFiles = upload.getValidationAttr(attr, scope, 'maxFiles');
            if (maxFiles == null) {
                maxFiles = Number.MAX_VALUE;
            }
            var maxTotalSize = upload.getValidationAttr(attr, scope, 'maxTotalSize');
            if (maxTotalSize == null) {
                maxTotalSize = Number.MAX_VALUE;
            }
            var includeDir = attrGetter('ngfIncludeDir', scope);
            var files = [], totalSize = 0;

            function traverseFileTree(entry, path) {
                var defer = $q.defer();
                if (entry != null) {
                    if (entry.isDirectory) {
                        var promises = [upload.emptyPromise()];
                        if (includeDir) {
                            var file = {type: 'directory'};
                            file.name = file.path = (path || '') + entry.name;
                            files.push(file);
                        }
                        var dirReader = entry.createReader();
                        var entries = [];
                        var readEntries = function () {
                            dirReader.readEntries(function (results) {
                                try {
                                    if (!results.length) {
                                        angular.forEach(entries.slice(0), function (e) {
                                            if (files.length <= maxFiles && totalSize <= maxTotalSize) {
                                                promises.push(traverseFileTree(e, (path ? path : '') + entry.name + '/'));
                                            }
                                        });
                                        $q.all(promises).then(function () {
                                            defer.resolve();
                                        }, function (e) {
                                            defer.reject(e);
                                        });
                                    } else {
                                        entries = entries.concat(Array.prototype.slice.call(results || [], 0));
                                        readEntries();
                                    }
                                } catch (e) {
                                    defer.reject(e);
                                }
                            }, function (e) {
                                defer.reject(e);
                            });
                        };
                        readEntries();
                    } else {
                        entry.file(function (file) {
                            try {
                                file.path = (path ? path : '') + file.name;
                                if (includeDir) {
                                    file = upload.rename(file, file.path);
                                }
                                files.push(file);
                                totalSize += file.size;
                                defer.resolve();
                            } catch (e) {
                                defer.reject(e);
                            }
                        }, function (e) {
                            defer.reject(e);
                        });
                    }
                }
                return defer.promise;
            }

            var promises = [upload.emptyPromise()];

            if (items && items.length > 0 && $window.location.protocol !== 'file:') {
                for (var i = 0; i < items.length; i++) {
                    if (items[i].webkitGetAsEntry && items[i].webkitGetAsEntry() && items[i].webkitGetAsEntry().isDirectory) {
                        var entry = items[i].webkitGetAsEntry();
                        if (entry.isDirectory && !allowDir) {
                            continue;
                        }
                        if (entry != null) {
                            promises.push(traverseFileTree(entry));
                        }
                    } else {
                        var f = items[i].getAsFile();
                        if (f != null) {
                            files.push(f);
                            totalSize += f.size;
                        }
                    }
                    if (files.length > maxFiles || totalSize > maxTotalSize ||
                            (!multiple && files.length > 0))
                        break;
                }
            } else {
                if (fileList != null) {
                    for (var j = 0; j < fileList.length; j++) {
                        var file = fileList.item(j);
                        if (file.type || file.size > 0) {
                            files.push(file);
                            totalSize += file.size;
                        }
                        if (files.length > maxFiles || totalSize > maxTotalSize ||
                                (!multiple && files.length > 0))
                            break;
                    }
                }
            }

            var defer = $q.defer();
            $q.all(promises).then(function () {
                if (!multiple && !includeDir && files.length) {
                    var i = 0;
                    while (files[i] && files[i].type === 'directory')
                        i++;
                    defer.resolve([files[i]]);
                } else {
                    defer.resolve(files);
                }
            }, function (e) {
                defer.reject(e);
            });

            return defer.promise;
        }
    }

    function dropAvailable() {
        var div = document.createElement('div');
        return ('draggable' in div) && ('ondrop' in div) && !/Edge\/12./i.test(navigator.userAgent);
    }

})();

// customized version of https://github.com/exif-js/exif-js
ngFileUpload.service('UploadExif', ['UploadResize', '$q', function (UploadResize, $q) {
        var upload = UploadResize;

        upload.isExifSupported = function () {
            return window.FileReader && new FileReader().readAsArrayBuffer && upload.isResizeSupported();
        };

        function applyTransform(ctx, orientation, width, height) {
            switch (orientation) {
                case 2:
                    return ctx.transform(-1, 0, 0, 1, width, 0);
                case 3:
                    return ctx.transform(-1, 0, 0, -1, width, height);
                case 4:
                    return ctx.transform(1, 0, 0, -1, 0, height);
                case 5:
                    return ctx.transform(0, 1, 1, 0, 0, 0);
                case 6:
                    return ctx.transform(0, 1, -1, 0, height, 0);
                case 7:
                    return ctx.transform(0, -1, -1, 0, height, width);
                case 8:
                    return ctx.transform(0, -1, 1, 0, 0, width);
            }
        }

        upload.readOrientation = function (file) {
            var defer = $q.defer();
            var reader = new FileReader();
            var slicedFile = file.slice ? file.slice(0, 64 * 1024) : file;
            reader.readAsArrayBuffer(slicedFile);
            reader.onerror = function (e) {
                return defer.reject(e);
            };
            reader.onload = function (e) {
                var result = {orientation: 1};
                var view = new DataView(this.result);
                if (view.getUint16(0, false) !== 0xFFD8)
                    return defer.resolve(result);

                var length = view.byteLength,
                        offset = 2;
                while (offset < length) {
                    var marker = view.getUint16(offset, false);
                    offset += 2;
                    if (marker === 0xFFE1) {
                        if (view.getUint32(offset += 2, false) !== 0x45786966)
                            return defer.resolve(result);

                        var little = view.getUint16(offset += 6, false) === 0x4949;
                        offset += view.getUint32(offset + 4, little);
                        var tags = view.getUint16(offset, little);
                        offset += 2;
                        for (var i = 0; i < tags; i++)
                            if (view.getUint16(offset + (i * 12), little) === 0x0112) {
                                var orientation = view.getUint16(offset + (i * 12) + 8, little);
                                if (orientation >= 2 && orientation <= 8) {
                                    view.setUint16(offset + (i * 12) + 8, 1, little);
                                    result.fixedArrayBuffer = e.target.result;
                                }
                                result.orientation = orientation;
                                return defer.resolve(result);
                            }
                    } else if ((marker & 0xFF00) !== 0xFF00)
                        break;
                    else
                        offset += view.getUint16(offset, false);
                }
                return defer.resolve(result);
            };
            return defer.promise;
        };

        function arrayBufferToBase64(buffer) {
            var binary = '';
            var bytes = new Uint8Array(buffer);
            var len = bytes.byteLength;
            for (var i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        upload.applyExifRotation = function (file) {
            if (file.type.indexOf('image/jpeg') !== 0) {
                return upload.emptyPromise(file);
            }

            var deferred = $q.defer();
            upload.readOrientation(file).then(function (result) {
                if (result.orientation < 2 || result.orientation > 8) {
                    return deferred.resolve(file);
                }
                upload.dataUrl(file, true).then(function (url) {
                    var canvas = document.createElement('canvas');
                    var img = document.createElement('img');

                    img.onload = function () {
                        try {
                            canvas.width = result.orientation > 4 ? img.height : img.width;
                            canvas.height = result.orientation > 4 ? img.width : img.height;
                            var ctx = canvas.getContext('2d');
                            applyTransform(ctx, result.orientation, img.width, img.height);
                            ctx.drawImage(img, 0, 0);
                            var dataUrl = canvas.toDataURL(file.type || 'image/WebP', 0.934);
                            dataUrl = upload.restoreExif(arrayBufferToBase64(result.fixedArrayBuffer), dataUrl);
                            var blob = upload.dataUrltoBlob(dataUrl, file.name);
                            deferred.resolve(blob);
                        } catch (e) {
                            return deferred.reject(e);
                        }
                    };
                    img.onerror = function () {
                        deferred.reject();
                    };
                    img.src = url;
                }, function (e) {
                    deferred.reject(e);
                });
            }, function (e) {
                deferred.reject(e);
            });
            return deferred.promise;
        };

        upload.restoreExif = function (orig, resized) {
            var ExifRestorer = {};

            ExifRestorer.KEY_STR = 'ABCDEFGHIJKLMNOP' +
                    'QRSTUVWXYZabcdef' +
                    'ghijklmnopqrstuv' +
                    'wxyz0123456789+/' +
                    '=';

            ExifRestorer.encode64 = function (input) {
                var output = '',
                        chr1, chr2, chr3 = '',
                        enc1, enc2, enc3, enc4 = '',
                        i = 0;

                do {
                    chr1 = input[i++];
                    chr2 = input[i++];
                    chr3 = input[i++];

                    enc1 = chr1 >> 2;
                    enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                    enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                    enc4 = chr3 & 63;

                    if (isNaN(chr2)) {
                        enc3 = enc4 = 64;
                    } else if (isNaN(chr3)) {
                        enc4 = 64;
                    }

                    output = output +
                            this.KEY_STR.charAt(enc1) +
                            this.KEY_STR.charAt(enc2) +
                            this.KEY_STR.charAt(enc3) +
                            this.KEY_STR.charAt(enc4);
                    chr1 = chr2 = chr3 = '';
                    enc1 = enc2 = enc3 = enc4 = '';
                } while (i < input.length);

                return output;
            };

            ExifRestorer.restore = function (origFileBase64, resizedFileBase64) {
                if (origFileBase64.match('data:image/jpeg;base64,')) {
                    origFileBase64 = origFileBase64.replace('data:image/jpeg;base64,', '');
                }

                var rawImage = this.decode64(origFileBase64);
                var segments = this.slice2Segments(rawImage);

                var image = this.exifManipulation(resizedFileBase64, segments);

                return 'data:image/jpeg;base64,' + this.encode64(image);
            };


            ExifRestorer.exifManipulation = function (resizedFileBase64, segments) {
                var exifArray = this.getExifArray(segments),
                        newImageArray = this.insertExif(resizedFileBase64, exifArray);
                return new Uint8Array(newImageArray);
            };


            ExifRestorer.getExifArray = function (segments) {
                var seg;
                for (var x = 0; x < segments.length; x++) {
                    seg = segments[x];
                    if (seg[0] === 255 & seg[1] === 225) //(ff e1)
                    {
                        return seg;
                    }
                }
                return [];
            };


            ExifRestorer.insertExif = function (resizedFileBase64, exifArray) {
                var imageData = resizedFileBase64.replace('data:image/jpeg;base64,', ''),
                        buf = this.decode64(imageData),
                        separatePoint = buf.indexOf(255, 3),
                        mae = buf.slice(0, separatePoint),
                        ato = buf.slice(separatePoint),
                        array = mae;

                array = array.concat(exifArray);
                array = array.concat(ato);
                return array;
            };


            ExifRestorer.slice2Segments = function (rawImageArray) {
                var head = 0,
                        segments = [];

                while (1) {
                    if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 218) {
                        break;
                    }
                    if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 216) {
                        head += 2;
                    } else {
                        var length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3],
                                endPoint = head + length + 2,
                                seg = rawImageArray.slice(head, endPoint);
                        segments.push(seg);
                        head = endPoint;
                    }
                    if (head > rawImageArray.length) {
                        break;
                    }
                }

                return segments;
            };


            ExifRestorer.decode64 = function (input) {
                var chr1, chr2, chr3 = '',
                        enc1, enc2, enc3, enc4 = '',
                        i = 0,
                        buf = [];

                // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
                var base64test = /[^A-Za-z0-9\+\/\=]/g;
                if (base64test.exec(input)) {
                    console.log('There were invalid base64 characters in the input text.\n' +
                            'Valid base64 characters are A-Z, a-z, 0-9, ' + ', ' / ',and "="\n' +
                            'Expect errors in decoding.');
                }
                input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');

                do {
                    enc1 = this.KEY_STR.indexOf(input.charAt(i++));
                    enc2 = this.KEY_STR.indexOf(input.charAt(i++));
                    enc3 = this.KEY_STR.indexOf(input.charAt(i++));
                    enc4 = this.KEY_STR.indexOf(input.charAt(i++));

                    chr1 = (enc1 << 2) | (enc2 >> 4);
                    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
                    chr3 = ((enc3 & 3) << 6) | enc4;

                    buf.push(chr1);

                    if (enc3 !== 64) {
                        buf.push(chr2);
                    }
                    if (enc4 !== 64) {
                        buf.push(chr3);
                    }

                    chr1 = chr2 = chr3 = '';
                    enc1 = enc2 = enc3 = enc4 = '';

                } while (i < input.length);

                return buf;
            };

            return ExifRestorer.restore(orig, resized);  //<= EXIF
        };

        return upload;
    }]);